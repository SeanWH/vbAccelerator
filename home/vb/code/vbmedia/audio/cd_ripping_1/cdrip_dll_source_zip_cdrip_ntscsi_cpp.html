<html lang="en" >
<head>
<title>vbAccelerator - Contents of code file: CDRip_NTScsi.cpp</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="vbAccelerator - Contents of code file: CDRip_NTScsi.cpp" /><link rel="stylesheet" href="..\..\..\..\..\res\screen.css" media="SCREEN" /><link rel="stylesheet" href="..\..\..\..\..\res\print.css" media="PRINT" /><link rel="SHORTCUT ICON" href="/home/res/vbaccel.ico" /><link rel="copyright" href="/home/The_Site/Copyright/article.asp" /><link rel="contents" href="./CDRip_DLL_Source.asp" /><link rel="meta" type="application/rdf+xml" href="./CDRip DLL Source.rdf" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><td colspan="3">
<!-- TF 468x60 JScript HORIZ NoPop code -->
<script language=javascript><!--
document.write('<scr'+'ipt language=javascript src="http://a.tribalfusion.com/j.ad?site=VBAcceleratorcom&adSpace=ROS&size=468x60&type=horiz&pop=0&requestID='+((new Date()).getTime() % 2147483648) + Math.random()+'"></scr'+'ipt>');
//-->
</script>
<noscript>
   <a href="javascript:window.alert(&quot;http://a.tribalfusion.com/i.click?site=VBAcceleratorcom&adSpace=ROS&size=468x60&requestID=1423477941\nThis link was not retrieved.&quot;)" target=_blank>
   <img src="http://cdn5.tribalfusion.com/media/493786.gif" 
                  width=468 height=60 border=0 alt="Click Here"></a>
</noscript>
<!-- TF 468x60 JScript HORIZ NoPop code -->
</td></tr><tr class="navbar"><td><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">VB</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">vbMedia</a>&#160;.&#160;<a href="..\index.html">Audio</a>&#160;.&#160;<a href="article.html">CD Ripping in VB Part 1</a>&#160;.&#160;<a href="cdrip_dll_source.html">CDRip DLL Source</a>&#160;.&#160;CDRip_NTScsi.cpp</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="..\..\..\..\..\res\download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="cdrip_dll_source.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />CDRip DLL Source</a> (87K)</p><p class="nav"><a href="cdrip_dll.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />CDRip DLL</a> (84K)</p><p /><p class="nav"><a href="vb5_cd_ripper.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />VB5 CD Ripper</a> (103K)</p><p /><p class="nav"><a href="vb6_cd_ripper.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />VB6 CD Ripper</a> (99K)</p><br /><br /><img src="..\..\..\..\..\res\information.png" width="125" height="21" alt="Information" /><p class="nav">Zip:15102</p><p class="nav">&#160;&#160;<a href="..\..\..\..\..\..\linkto_asp\id=15102&type=zip&title=cdrip_20dll_20source_2ezip_5fcdrip_5fntscsi.html">Link to code Zip</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;VB5</p><p class="nav">&#160;&#160;VB6</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="..\..\..\..\..\res\bugtrak.png" width="125" height="21" alt="BugTrak System" /><p class="nav">No logged bugs.</p><br /><br /><img src="..\..\..\..\..\res\updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="..\..\..\..\..\res\update.png" width="8" height="8" alt="Update" />6 May 2004<br />First Posted</p><br /><br /><img src="..\..\..\..\..\res\related.png" width="125" height="21" alt="Related Items" /><p class="nav"><img src="..\..\..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\..\..\..\..\resources\links\other\cdex\article.html">CDEx</a></p><p class="nav"><img src="..\..\..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\cd_tracklistings\article.html">CD Track Listing Using freedb.org</a></p><br /><br /><img src="..\..\..\..\..\res\search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="javascript:window.alert(&quot;http://www.google.com/search\nThis link was not retrieved.&quot;)"><img src="..\..\..\..\..\..\..\www_google_com\logos\logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="..\..\..\..\..\the_site\newsite\article.html"><img src="..\..\..\..\..\res\newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>vbAccelerator - Contents of code file: CDRip_NTScsi.cpp</h1><p>This file is part of the download <a href="cdrip_dll_source.html">CDRip DLL Source</a>, which is described in the article <a href="article.html">CD Ripping in VB Part 1</a>.</p><pre>/*
 * written by A.L. Faber
 * partly copyright (C) 1999 Jay A. Key
 **********************************************************************
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 **********************************************************************
 *
 */

#include "StdAfx.h"
#include "CDRomSettings.h"
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include "AspiDebug.h"
#include "NTScsi.h"


typedef struct {
   BYTE ha;
   BYTE tgt;
   BYTE lun;
   BYTE driveLetter;
   BOOL bUsed;
   HANDLE hDevice;
   BYTE inqData[36];
} NTSCSIDRIVE;

typedef struct
{
   BYTE      numAdapters;
   NTSCSIDRIVE   drive[26];
} NTSCSIDRIVES;

void GetDriveInformation( BYTE i, NTSCSIDRIVE *pDrive );

static HANDLE GetFileHandle( BYTE i );

static BOOL bNtScsiAvailable = FALSE;
static NTSCSIDRIVES NtScsiDrives;
static BOOL bUseNtScsi = FALSE;

/*
 * Initialization of SCSI Pass Through Interface code.  Responsible for
 * setting up the array of SCSI devices.  This code will be a little
 * different from the normal code -- it will query each drive letter from
 * C: through Z: to see if it is  a CD.  When we identify a CD, we then 
 * send CDB with the INQUIRY command to it -- NT will automagically fill in
 * the PathId, TargetId, and Lun for us.
 */

int NtScsiInit( void )
{
   BYTE i;
   char buf[4];
   UINT uDriveType;
   int retVal = 0;

   if ( bNtScsiAvailable )
   {
      return 0;
   }

   memset( &amp;NtScsiDrives, 0x00, sizeof(NtScsiDrives) );

   for( i = 0; i &lt; 26; i++ )
   {
      NtScsiDrives.drive[i].hDevice = INVALID_HANDLE_VALUE;
   }

   for( i = 2; i &lt; 26; i++ )
   {
      wsprintf( buf, "%c:\\", (char)('A'+i) );
      uDriveType = GetDriveType( buf );

      /* check if this is a CDROM drive */
      if ( uDriveType == DRIVE_CDROM )
      {
         GetDriveInformation( i, &amp;NtScsiDrives.drive[i] );

         if ( NtScsiDrives.drive[i].bUsed )
            retVal++;
      }
   }

   NtScsiDrives.numAdapters = NtScsiGetNumAdapters( );

   bNtScsiAvailable = TRUE;

   if ( retVal &gt; 0 )
   {
      bUseNtScsi = TRUE;
   }

   return retVal;
}


int NtScsiDeInit( void )
{
   BYTE i;

   if ( !bNtScsiAvailable )
      return 0;

   for( i = 2; i &lt; 26; i++ )
   {
      if ( NtScsiDrives.drive[i].bUsed )
      {
         CloseHandle( NtScsiDrives.drive[i].hDevice );
      }
   }

   NtScsiDrives.numAdapters = NtScsiGetNumAdapters( );

   ZeroMemory( &amp;NtScsiDrives, sizeof(NtScsiDrives) );
   bNtScsiAvailable = FALSE;
   return -1;
}


/*
 * Returns the number of "adapters" present. 
 */
BYTE NtScsiGetNumAdapters( void )
{
   BYTE buf[256];
   WORD i;
   BYTE numAdapters = 0;

   memset( buf,0x00, sizeof(buf) );

   // PortNumber 0 should exist, so pre-mark it.  This avoids problems
   // when the primary IDE drives are on PortNumber 0, but can't be opened
   // because of insufficient privelege (ie. non-admin).
   buf[0] = 1;

   for( i = 0; i &lt; 26; i++ )
   {
      if ( NtScsiDrives.drive[i].bUsed )
         buf[NtScsiDrives.drive[i].ha] = 1;
   }

   for( i = 0; i &lt;= 255; i++ )
   {
      if ( buf[i] )
      numAdapters++;
   }

   DebugPrintf( "NtScsiGetNumAdapters detected %d adapters" , numAdapters );

   return numAdapters;
}


/*
 * Replacement for GetASPI32SupportInfo from wnaspi32.dll
 */
DWORD NtScsiGetASPI32SupportInfo( void )
{
   DWORD retVal;


   if ( !NtScsiDrives.numAdapters )
       retVal = (DWORD)(MAKEWORD(0,SS_NO_ADAPTERS));
   else
      retVal = (DWORD)(MAKEWORD(NtScsiDrives.numAdapters,SS_COMP));

   DebugPrintf( "NtScsiGetASPI32SupportInfo returns %d" , retVal );

   return retVal;
}

/*
 * Needs to call the appropriate function for the lpsrb-&gt;SRB_Cmd specified.
 * Valid types are SC_HA_INQUIRY, SC_GET_DEV_TYPE, SC_EXEC_SCSI_CMD,
 * and SC_RESET_DEV.
 */
DWORD NtScsiSendASPI32Command( LPSRB lpsrb )
{
   if ( !lpsrb )
      return SS_ERR;

   switch( lpsrb-&gt;SRB_Cmd )
    {
      case SC_HA_INQUIRY:
         return NtScsiHandleHaInquiry( (LPSRB_HAINQUIRY)lpsrb );
      break;

      case SC_GET_DEV_TYPE:
         return NtScsiGetDeviceType( (LPSRB_GDEVBLOCK)lpsrb );
      break;

      case SC_EXEC_SCSI_CMD:
        return NtScsiExecSCSICommand( (LPSRB_EXECSCSICMD)lpsrb, FALSE );
      break;

      case SC_RESET_DEV:
      default:
        lpsrb-&gt;SRB_Status = SS_ERR;
        return SS_ERR;
      break;
    }

   return SS_ERR;  // should never get to here...
}


/*
 * Universal function to get a file handle to the CD device.  Since
 * NT 4.0 wants just the GENERIC_READ flag, and Win2K wants both
 * GENERIC_READ and GENERIC_WRITE (why a read-only CD device needs
 * GENERIC_WRITE access is beyond me...), the easist workaround is to just
 * try them both.
 */
static HANDLE GetFileHandle( BYTE i )
{
   char         buf[12];
   HANDLE         fh = NULL;
   OSVERSIONINFO   osver;
   DWORD         dwFlags;

   memset( &amp;osver, 0x00, sizeof(osver) );
   osver.dwOSVersionInfoSize = sizeof(osver);
   GetVersionEx( &amp;osver );

   // if Win2K or greater, add GENERIC_WRITE
   dwFlags = GENERIC_READ;

   if ( (osver.dwPlatformId == VER_PLATFORM_WIN32_NT) &amp;&amp; (osver.dwMajorVersion
    &gt; 4) )
   {
      dwFlags |= GENERIC_WRITE;

      DebugPrintf( "NtScsi: GetFileHandle(): Setting for Win2K" );

   }

   wsprintf( buf, "\\\\.\\%c:", (char)('A'+i) );
   fh = CreateFile( buf, dwFlags, FILE_SHARE_READ, NULL,OPEN_EXISTING, 0, NULL
    );

   if ( fh == INVALID_HANDLE_VALUE )
   {
      // it went foobar somewhere, so try it with the GENERIC_WRITE bit flipped
      dwFlags ^= GENERIC_WRITE;
      fh = CreateFile( buf, dwFlags, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0,
       NULL );
    }

   if ( fh == INVALID_HANDLE_VALUE )
   {
      DebugPrintf( "NtScsi: CreateFile() failed! -&gt; %d", GetLastError() );
   }
   else
   {
      DebugPrintf( "NtScsi: CreateFile() returned %d", GetLastError() );
   }

   return fh;
}



/*
 * fills in a pDrive structure with information from a SCSI_INQUIRY
 * and obtains the ha:tgt:lun values via IOCTL_SCSI_GET_ADDRESS
 */
void GetDriveInformation( BYTE i, NTSCSIDRIVE *pDrive )
{
   HANDLE fh;
   char buf[1024];
   BOOL status;
   PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER pswb;
   PSCSI_ADDRESS pscsiAddr;
   ULONG length, returned;
   BYTE inqData[100];

#ifdef _DEBUG_SCSIPT
   DebugPrintf( "NtScsi: Checking drive %c:", 'A'+i );
#endif

   fh = GetFileHandle( i );

   if ( fh == INVALID_HANDLE_VALUE )
   {
#ifdef _DEBUG_SCSIPT
      DebugPrintf( "       : fh == INVALID_HANDLE_VALUE" );
#endif
      return;
    }

#ifdef _DEBUG_SCSIPT
  DebugPrintf( "       : Index %d: fh == %08X", i, fh );
#endif


  /*
   * Get the drive inquiry data
   */
  ZeroMemory( &amp;buf, 1024 );
  ZeroMemory( inqData, 100 );
  pswb                      = (PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER)buf;
  pswb-&gt;spt.Length          = sizeof(SCSI_PASS_THROUGH);
  pswb-&gt;spt.CdbLength       = 6;
  pswb-&gt;spt.SenseInfoLength = 24;
  pswb-&gt;spt.DataIn          = SCSI_IOCTL_DATA_IN;
  pswb-&gt;spt.DataTransferLength = 100;
  pswb-&gt;spt.TimeOutValue    = 2;
  pswb-&gt;spt.DataBuffer      = inqData;
  pswb-&gt;spt.SenseInfoOffset =
   offsetof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER,ucSenseBuf );
  pswb-&gt;spt.Cdb[0]          = 0x12;
  pswb-&gt;spt.Cdb[4]          = 100;

  length = sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER);
  status = DeviceIoControl( fh,
             IOCTL_SCSI_PASS_THROUGH_DIRECT,
             pswb,
             length,
             pswb,
             length,
             &amp;returned,
             NULL );

  if ( !status )
    {
      CloseHandle( fh );
#ifdef _DEBUG_SCSIPT
      DebugPrintf( "AKRip32: SCSIPT: Error DeviceIoControl() -&gt; %d",
      GetLastError() );
#endif
      return;
    }

  memcpy( pDrive-&gt;inqData, inqData, 36 );

  /*
   * get the address (path/tgt/lun) of the drive via IOCTL_SCSI_GET_ADDRESS
   */
  ZeroMemory( &amp;buf, 1024 );
  pscsiAddr = (PSCSI_ADDRESS)buf;
  pscsiAddr-&gt;Length = sizeof(SCSI_ADDRESS);
  if ( DeviceIoControl( fh, IOCTL_SCSI_GET_ADDRESS, NULL, 0,
         pscsiAddr, sizeof(SCSI_ADDRESS), &amp;returned,
         NULL ) )
    {
#ifdef _DEBUG_SCSIPT
      DebugPrintf( "Device %c: Port=%d, PathId=%d, TargetId=%d, Lun=%d",
      (char)i+'A', pscsiAddr-&gt;PortNumber, pscsiAddr-&gt;PathId,
      pscsiAddr-&gt;TargetId, pscsiAddr-&gt;Lun );
#endif
      pDrive-&gt;bUsed     = TRUE;
      pDrive-&gt;ha        = pscsiAddr-&gt;PortNumber;
      pDrive-&gt;tgt       = pscsiAddr-&gt;TargetId;
      pDrive-&gt;lun       = pscsiAddr-&gt;Lun;
      pDrive-&gt;driveLetter = i;
      pDrive-&gt;hDevice   = INVALID_HANDLE_VALUE;
    }
  else
    {
      pDrive-&gt;bUsed     = FALSE;
#ifdef _DEBUG_SCSIPT
      DebugPrintf( "NtScsi: Device %s: Error DeviceIoControl(): %d",
       (char)i+'A', GetLastError() );
#endif
      return;
    }

#ifdef _DEBUG_SCSIPT
  DebugPrintf( "NtScsi: Adding drive %c: (%d:%d:%d)", 'A'+i,
       pDrive-&gt;ha, pDrive-&gt;tgt, pDrive-&gt;lun );
#endif

  CloseHandle( fh );
}



DWORD NtScsiHandleHaInquiry( LPSRB_HAINQUIRY lpsrb )
{
  DWORD *pMTL;

  lpsrb-&gt;HA_Count    = NtScsiDrives.numAdapters;

  if ( lpsrb-&gt;SRB_HaId &gt;= NtScsiDrives.numAdapters )
    {
      lpsrb-&gt;SRB_Status = SS_INVALID_HA;
      return SS_INVALID_HA;
    }
  lpsrb-&gt;HA_SCSI_ID  = 7;  // who cares... we're not really an ASPI manager
  memcpy( lpsrb-&gt;HA_ManagerId,  "AKASPI v0.000001", 16 );
  memcpy( lpsrb-&gt;HA_Identifier, "SCSI Adapter    ", 16 );
  lpsrb-&gt;HA_Identifier[13] = (char)('0'+lpsrb-&gt;SRB_HaId);
  ZeroMemory( lpsrb-&gt;HA_Unique, 16 );
  lpsrb-&gt;HA_Unique[3] = 8;
  pMTL = (LPDWORD)&amp;lpsrb-&gt;HA_Unique[4];
  *pMTL = 64 * 1024;

  lpsrb-&gt;SRB_Status = SS_COMP;
  return SS_COMP;
}


/*
 * Scans through the drive array and returns DTYPE_CDROM type for all items
 * found, and DTYPE_UNKNOWN for all others.
 */
DWORD NtScsiGetDeviceType( LPSRB_GDEVBLOCK lpsrb )
{
#ifdef _DEBUG_SCSIPT
  DebugPrintf( "AKRip32: NtScsiGetDeviceType( %d:%d:%d )",lpsrb-&gt;SRB_HaId,
   lpsrb-&gt;SRB_Target, lpsrb-&gt;SRB_Lun );
#endif

  lpsrb-&gt;SRB_Status = SS_NO_DEVICE;
  if ( NtScsiGetDeviceIndex( lpsrb-&gt;SRB_HaId, lpsrb-&gt;SRB_Target, lpsrb-&gt;SRB_Lun
   ) )
    lpsrb-&gt;SRB_Status = SS_COMP;

  if ( lpsrb-&gt;SRB_Status == SS_COMP )
    lpsrb-&gt;SRB_DeviceType = DTC_CDROM;
  else
    lpsrb-&gt;SRB_DeviceType = DTC_UNKNOWN;

  return lpsrb-&gt;SRB_Status;
}


/*
 * Looks up the index in the drive array for a given ha:tgt:lun triple
 */
BYTE NtScsiGetDeviceIndex( BYTE ha, BYTE tgt, BYTE lun )
{
   BYTE i;

   DebugPrintf( "NtScsiGetDeviceIndex" );

   for( i = 2; i &lt; 26; i++ )
    {
      if ( NtScsiDrives.drive[i].bUsed )
      {
         NTSCSIDRIVE *lpd;
         lpd = &amp;NtScsiDrives.drive[i];
         if ( (lpd-&gt;ha == ha) &amp;&amp; (lpd-&gt;tgt == tgt) &amp;&amp; (lpd-&gt;lun == lun) )
            return i;
      }
    }
   return 0;
}

/*
 * Converts ASPI-style SRB to SCSI Pass Through IOCTL
 */
DWORD NtScsiExecSCSICommand( LPSRB_EXECSCSICMD lpsrb, BOOL bBeenHereBefore )
{
  BOOL status;
  SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER swb;
  ULONG length, returned;
  //BYTE i;
  BYTE idx;

  idx = NtScsiGetDeviceIndex( lpsrb-&gt;SRB_HaId, lpsrb-&gt;SRB_Target,
   lpsrb-&gt;SRB_Lun );

  if ( idx == 0 )
    {
      lpsrb-&gt;SRB_Status = SS_ERR;
      return SS_ERR;
    }

  if ( lpsrb-&gt;CDBByte[0] == 0x12 ) // is it an INQUIRY?
    {
      lpsrb-&gt;SRB_Status = SS_COMP;
      memcpy( lpsrb-&gt;SRB_BufPointer, NtScsiDrives.drive[idx].inqData, 36 );
      return SS_COMP;
    }

  if ( NtScsiDrives.drive[idx].hDevice == INVALID_HANDLE_VALUE )
    NtScsiDrives.drive[idx].hDevice = GetFileHandle(
     NtScsiDrives.drive[idx].driveLetter );

  ZeroMemory( &amp;swb, sizeof(swb) );
  swb.spt.Length            = sizeof(SCSI_PASS_THROUGH);
  swb.spt.CdbLength         = lpsrb-&gt;SRB_CDBLen;
  if ( lpsrb-&gt;SRB_Flags &amp; SRB_DIR_IN )
    swb.spt.DataIn          = SCSI_IOCTL_DATA_IN;
  else if ( lpsrb-&gt;SRB_Flags &amp; SRB_DIR_OUT )
    swb.spt.DataIn          = SCSI_IOCTL_DATA_OUT;
  else
    swb.spt.DataIn          = SCSI_IOCTL_DATA_UNSPECIFIED;
  swb.spt.DataTransferLength = lpsrb-&gt;SRB_BufLen;
  swb.spt.TimeOutValue      = 5;
  swb.spt.DataBuffer        = lpsrb-&gt;SRB_BufPointer;
  swb.spt.SenseInfoOffset   =
    offsetof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER, ucSenseBuf );
  memcpy( swb.spt.Cdb, lpsrb-&gt;CDBByte, lpsrb-&gt;SRB_CDBLen );
  length = sizeof(swb);

#ifdef _DEBUG_SCSIPT
  DebugPrintf( "NtScsiExecSCSICmd: calling DeviceIoControl()" );
  DebugPrintf( "       : cmd == 0x%02X", swb.spt.Cdb[0] );
#endif
  status = DeviceIoControl( NtScsiDrives.drive[idx].hDevice,
             IOCTL_SCSI_PASS_THROUGH_DIRECT,
             &amp;swb,
             length,
             &amp;swb,
             length,
             &amp;returned,
             NULL );

  if ( status )
    {
      lpsrb-&gt;SRB_Status = SS_COMP;
#ifdef _DEBUG_SCSIPT
      DebugPrintf( "       : SRB_Status == SS_COMP" );
#endif
    }
  else
    {
      DWORD dwErrCode;

      lpsrb-&gt;SRB_Status = SS_ERR;
      lpsrb-&gt;SRB_TargStat = 0x0004;
      dwErrCode = GetLastError();
#ifdef _DEBUG_SCSIPT
      DebugPrintf( "       : error == %d   handle == %08X", dwErrCode,
       NtScsiDrives.drive[idx].hDevice );
#endif
      /*
       * KLUDGE ALERT! KLUDGE ALERT! KLUDGE ALERT!
       * Whenever a disk changer switches disks, it may render the device
       * handle invalid.  We try to catch these errors here and recover
       * from them.
       */
      if ( !bBeenHereBefore &amp;&amp;
      ((dwErrCode == ERROR_MEDIA_CHANGED) || (dwErrCode ==
       ERROR_INVALID_HANDLE)) )
   {
     if ( dwErrCode != ERROR_INVALID_HANDLE )
       CloseHandle( NtScsiDrives.drive[idx].hDevice );
     GetDriveInformation( idx, &amp;NtScsiDrives.drive[idx] );

     DebugPrintf( "NtScsiExecSCSICommand: Retrying after ERROR_MEDIA_CHANGED" );

     return NtScsiExecSCSICommand( lpsrb, TRUE );
   }
    }

  return lpsrb-&gt;SRB_Status;
}



BOOL UsingSCSIPT( void )
{
  return bUseNtScsi;
}



/*
 * Calls GetFileHandle for the CD refered to by ha:tgt:lun to open it for
 * use
 */
void NtScsiOpenCDHandle( BYTE ha, BYTE tgt, BYTE lun )
{
  BYTE idx;

#ifdef _DEBUG_SCSIPT
  DebugPrintf( "AKRip32: NtScsiOpenCDHandle( %d, %d, %d )", ha, tgt, lun );
#endif

  idx = NtScsiGetDeviceIndex( ha, tgt, lun );

  if ( idx &amp;&amp; NtScsiDrives.drive[idx].hDevice == INVALID_HANDLE_VALUE )
    NtScsiDrives.drive[idx].hDevice = GetFileHandle(
     NtScsiDrives.drive[idx].driveLetter );  
}
</pre><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<noscript>
<A HREF="javascript:window.alert(&quot;http://vbaccelerator.com/home/include/adredir.asp?url=http://oneandone.co.uk/xml/init?k_id=5791003&image=http://oneandone.co.uk/xml/banner?size=1&number=4\nThis link was not retrieved.&quot;)" ><IMG SRC="..\..\..\..\..\..\..\oneandone_co_uk\xml\banner\size=1&number=4.html" ALT="1&1 Web Hosting" WIDTH=468 HEIGHT=60 BORDER=0></A>
</noscript>

</p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">VB</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">vbMedia</a>&#160;.&#160;<a href="..\index.html">Audio</a>&#160;.&#160;<a href="article.html">CD Ripping in VB Part 1</a>&#160;.&#160;<a href="cdrip_dll_source.html">CDRip DLL Source</a>&#160;.&#160;CDRip_NTScsi.cpp</p><br /><table style="font-size: 100%;"><tr><td valign="top"><a href="javascript:window.alert(&quot;http://creativecommons.org/licenses/by/1.0/\nThis link was not retrieved.&quot;)"><img src="..\..\..\..\..\res\cc.png" width="88" height="31" alt="Creative Commons Licence" /></a></td></a></td><td valign="top"><p class="nav" style="padding-bottom: 4px;">All contents of this web site are licensed under a <a href="javascript:window.alert(&quot;http://creativecommons.org/licenses/by/1.0/\nThis link was not retrieved.&quot;)">Creative Commons Licence</a>, except where otherwise noted.</p><p class="nav"><a href="..\..\..\..\..\the_site\copyright\article.html">Copyright</a> &#169; 2004 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>, vbAccelerator Ltd.<br />Last Updated: 12 June 2004</p></td></tr></table></td><td></td></tr></table>
</body></html>