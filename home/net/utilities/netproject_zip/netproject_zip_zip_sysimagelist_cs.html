<html lang="en" >
<head>
<title>vbAccelerator - Contents of code file: SysImageList.cs</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="vbAccelerator - Contents of code file: SysImageList.cs" /><link rel="stylesheet" href="..\..\..\res\screen.css" media="SCREEN" /><link rel="stylesheet" href="..\..\..\res\print.css" media="PRINT" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><td colspan="3">
<!-- TF 468x60 JScript HORIZ NoPop code -->
<script language=javascript><!--
document.write('<scr'+'ipt language=javascript src="http://a.tribalfusion.com/j.ad?site=VBAcceleratorcom&adSpace=ROS&size=468x60&type=horiz&pop=0&requestID='+((new Date()).getTime() % 2147483648) + Math.random()+'"></scr'+'ipt>');
//-->
</script>
<noscript>
   <a href="javascript:window.alert(&quot;http://a.tribalfusion.com/i.click?site=VBAcceleratorcom&adSpace=ROS&size=468x60&requestID=1423477941\nThis link was not retrieved.&quot;)" target=_blank>
   <img src="http://cdn5.tribalfusion.com/media/493786.gif" 
                  width=468 height=60 border=0 alt="Click Here"></a>
</noscript>
<!-- TF 468x60 JScript HORIZ NoPop code -->
</td></tr><tr class="navbar"><td><a href="..\..\..\index.html"><img width="125" height="25" src="..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\index.html">NET</a>&#160;.&#160;<a href="..\index.html">Utilities</a>&#160;.&#160;<a href="article.html">NetProjectZip</a>&#160;.&#160;<a href="netproject_zip.html">NetProject Zip</a>&#160;.&#160;SysImageList.cs</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="..\..\..\res\download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="netproject_zip.html"><img src="..\..\..\res\get.png" width="8" height="8" alt="Download Page" />NetProject Zip</a> (73K)</p><br /><br /><img src="..\..\..\res\information.png" width="125" height="21" alt="Information" /><p class="nav">Zip:4472</p><p class="nav">&#160;&#160;<a href="..\..\..\..\linkto_asp\id=4472&type=zip&title=netproject_20zip_2ezip_5fsysimagelist.html">Link to code Zip</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;.NET</p><p class="nav">&#160;&#160;VB.NET</p><p class="nav">&#160;&#160;C#</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="..\..\..\res\bugtrak.png" width="125" height="21" alt="BugTrak System" /><p class="nav">No logged bugs.</p><br /><br /><img src="..\..\..\res\updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="..\..\..\res\update.png" width="8" height="8" alt="Update" />5 Apr 2003<br />Updated to version 0.50 of SharpZipLib</p><p class="update"><a href="updates.html">Update History &gt;</a></p><br /><br /><img src="..\..\..\res\related.png" width="125" height="21" alt="Related Items" /><p class="nav"><img src="..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\..\..\resources\links\net\sharpziplib\article.html">SharpZipLib</a></p><p class="nav"><img src="..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\..\..\vb\utilities\vbpzip\article.html">Visual Basic Project Zip Utility</a></p><p class="nav"><img src="..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\..\code\libraries\shell_projects\sysimagelist\article.html">System Image List</a></p><br /><br /><img src="..\..\..\res\search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="javascript:window.alert(&quot;http://www.google.com/search\nThis link was not retrieved.&quot;)"><img src="..\..\..\..\..\www_google_com\logos\logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="..\..\..\the_site\newsite\article.html"><img src="..\..\..\res\newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>vbAccelerator - Contents of code file: SysImageList.cs</h1><pre>using System;
using System.Drawing;
using System.Runtime.InteropServices;

namespace vbAccelerator.Components.ImageList
{

   #region Public Enumerations
   public enum SysImageListSize : int
   {
      /// &lt;summary&gt;
      /// System Large Icon Size (typically 32x32)
      /// &lt;/summary&gt;
      largeIcons = 0x0,
      /// &lt;summary&gt;
      /// System Small Icon Size (typically 16x16)
      /// &lt;/summary&gt;
      smallIcons = 0x1,
      /// &lt;summary&gt;
      /// System Extra Large Icon Size (typically 48x48).
      /// Only available under XP; other OS return the
      /// Large Icon ImageList.
      /// &lt;/summary&gt;
      extraLargeIcons = 0x2
   }

   [Flags]
   public enum ImageListDrawItemConstants : int
   {
      /// &lt;summary&gt;
      /// Draw item normally.
      /// &lt;/summary&gt;
      ILD_NORMAL = 0x0,
      /// &lt;summary&gt;
      /// Draw item transparently.
      /// &lt;/summary&gt;
      ILD_TRANSPARENT = 0x1,
      /// &lt;summary&gt;
      /// Draw item blended with 25% of the specified foreground colour
      /// or the Highlight colour if no foreground colour specified.
      /// &lt;/summary&gt;
      ILD_BLEND25 = 0x2,
      /// &lt;summary&gt;
      /// Draw item blended with 50% of the specified foreground colour
      /// or the Highlight colour if no foreground colour specified.
      /// &lt;/summary&gt;
      ILD_SELECTED = 0x4,
      /// &lt;summary&gt;
      /// Draw the icon's mask
      /// &lt;/summary&gt;
      ILD_MASK = 0x10,
      /// &lt;summary&gt;
      /// Draw the icon image without using the mask
      /// &lt;/summary&gt;
      ILD_IMAGE = 0x20,
      /// &lt;summary&gt;
      /// Draw the icon using the ROP specified.
      /// &lt;/summary&gt;
      ILD_ROP = 0x40,
      /// &lt;summary&gt;
      /// ?
      /// &lt;/summary&gt;
      ILD_OVERLAYMASK = 0xF00,
      /// &lt;summary&gt;
      /// Preserves the alpha channel in dest. XP only.
      /// &lt;/summary&gt;
      ILD_PRESERVEALPHA = 0x1000, // 
      /// &lt;summary&gt;
      /// Scale the image to cx, cy instead of clipping it.  XP only.
      /// &lt;/summary&gt;
      ILD_SCALE = 0x2000,
      /// &lt;summary&gt;
      /// Scale the image to the current DPI of the display. XP only.
      /// &lt;/summary&gt;
      ILD_DPISCALE = 0x4000
   }
   #endregion

   #region SysImageList
   /// &lt;summary&gt;
   /// Summary description for SysImageList.
   /// &lt;/summary&gt;
   public class SysImageList : IDisposable
   {
      #region UnmanagedCode
      private const int MAX_PATH = 260;
      
      [DllImport("shell32")]
      private static extern IntPtr SHGetFileInfo (
         string pszPath, 
         int dwFileAttributes,
         ref SHFILEINFO psfi, 
         uint cbFileInfo, 
         uint uFlags);

      [DllImport("user32.dll")]
      private static extern int DestroyIcon(IntPtr hIcon);

      private const int FILE_ATTRIBUTE_NORMAL = 0x80;
      private const int FILE_ATTRIBUTE_DIRECTORY = 0x10;

      private const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x100; 
      private const int FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x2000;
      private const int FORMAT_MESSAGE_FROM_HMODULE = 0x800;
      private const int FORMAT_MESSAGE_FROM_STRING = 0x400;
      private const int FORMAT_MESSAGE_FROM_SYSTEM = 0x1000;
      private const int FORMAT_MESSAGE_IGNORE_INSERTS = 0x200;
      private const int FORMAT_MESSAGE_MAX_WIDTH_MASK = 0xFF;
      [DllImport("kernel32")]
      private extern static int FormatMessage (
         int dwFlags, 
         IntPtr lpSource, 
         int dwMessageId, 
         int dwLanguageId, 
         string lpBuffer,
         uint nSize, 
         int argumentsLong);

      [DllImport("kernel32")]
      private extern static int GetLastError();

      [DllImport("comctl32")]
      private extern static int ImageList_Draw(
         IntPtr hIml,
         int i,
         IntPtr hdcDst,
         int x,
         int y,
         int fStyle);

      [DllImport("comctl32")]
      private extern static int ImageList_DrawIndirect(
         ref IMAGELISTDRAWPARAMS pimldp);

      [DllImport("comctl32")]
      private extern static int ImageList_GetIconSize(
         IntPtr himl, 
         ref int cx, 
         ref int cy);

      [DllImport("comctl32")]
      private extern static IntPtr ImageList_GetIcon(
         IntPtr himl, 
         int i, 
         int flags);

      /// &lt;summary&gt;
      /// SHGetImageList is not exported correctly in XP.  See KB316931
      /// http://support.microsoft.com/default.aspx?scid=kb;EN-US;Q316931
      /// Apparently (and hopefully) ordinal 727 isn't going to change.
      /// &lt;/summary&gt;
      [DllImport("shell32.dll", EntryPoint = "#727")]
      private extern static int SHGetImageList(
         int iImageList,
         ref Guid riid,
         ref IImageList ppv
         );


      #endregion
      
      #region Private Enumerations
      [Flags]      
         private enum SHGetFileInfoConstants : int
      {
         SHGFI_ICON = 0x100,                // get icon 
         SHGFI_DISPLAYNAME = 0x200,         // get display name 
         SHGFI_TYPENAME = 0x400,            // get type name 
         SHGFI_ATTRIBUTES = 0x800,          // get attributes 
         SHGFI_ICONLOCATION = 0x1000,       // get icon location 
         SHGFI_EXETYPE = 0x2000,            // return exe type 
         SHGFI_SYSICONINDEX = 0x4000,       // get system icon index 
         SHGFI_LINKOVERLAY = 0x8000,        // put a link overlay on icon 
         SHGFI_SELECTED = 0x10000,          // show icon in selected state 
         SHGFI_ATTR_SPECIFIED = 0x20000,    // get only specified attributes 
         SHGFI_LARGEICON = 0x0,             // get large icon 
         SHGFI_SMALLICON = 0x1,             // get small icon 
         SHGFI_OPENICON = 0x2,              // get open icon 
         SHGFI_SHELLICONSIZE = 0x4,         // get shell size icon 
         //SHGFI_PIDL = 0x8,                  // pszPath is a pidl 
         SHGFI_USEFILEATTRIBUTES = 0x10,     // use passed dwFileAttribute 
         SHGFI_ADDOVERLAYS = 0x000000020,     // apply the appropriate overlays
         SHGFI_OVERLAYINDEX = 0x000000040     // Get the index of the overlay
      }
      #endregion

      #region Private ImageList structures
      [StructLayout(LayoutKind.Sequential)]
         private struct RECT
      {
         int left;
         int top;
         int right;
         int bottom;
      }

      [StructLayout(LayoutKind.Sequential)]
         private struct POINT
      {
         int x;
         int y;
      }

      [StructLayout(LayoutKind.Sequential)]
         private struct IMAGELISTDRAWPARAMS            
      {
         public int cbSize;
         public IntPtr himl;
         public int i;
         public IntPtr hdcDst;
         public int x;
         public int y;
         public int cx;
         public int cy;
         public int xBitmap;        // x offest from the upperleft of bitmap
         public int yBitmap;        // y offset from the upperleft of bitmap
         public int rgbBk;
         public int rgbFg;
         public int fStyle;
         public int dwRop;
         public int fState;
         public int Frame;
         public int crEffect;
      }

      [StructLayout(LayoutKind.Sequential)]
         private struct IMAGEINFO
      {
         public IntPtr hbmImage;
         public IntPtr hbmMask;
         public int Unused1;
         public int Unused2;
         public RECT rcImage;
      }
      [StructLayout(LayoutKind.Sequential)]
         private struct SHFILEINFO
      {
         public IntPtr hIcon;
         public int iIcon;
         public int dwAttributes;
         [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_PATH)]
         public string szDisplayName;
         [MarshalAs(UnmanagedType.ByValTStr, SizeConst=80)]
         public string szTypeName;
      }
      #endregion

      #region Private ImageList COM Interop (XP)
      [ComImportAttribute()]
         [GuidAttribute("46EB5926-582E-4017-9FDF-E8998DAA0950")]
         [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
         //helpstring("Image List"),
         interface IImageList
      {
         [PreserveSig]
         int Add(
            IntPtr hbmImage, 
            IntPtr hbmMask, 
            ref int pi);

         [PreserveSig]
         int ReplaceIcon(
            int i, 
            IntPtr hicon, 
            ref int pi);

         [PreserveSig]
         int SetOverlayImage(
            int iImage, 
            int iOverlay);

         [PreserveSig]
         int Replace(
            int i,
            IntPtr hbmImage, 
            IntPtr hbmMask);

         [PreserveSig]
         int AddMasked(
            IntPtr hbmImage, 
            int crMask, 
            ref int pi);

         [PreserveSig]
         int Draw(
            ref IMAGELISTDRAWPARAMS pimldp);

         [PreserveSig]
         int Remove(
            int i);

         [PreserveSig]
         int GetIcon(
            int i, 
            int flags, 
            ref IntPtr picon);

         [PreserveSig]
         int GetImageInfo(
            int i, 
            ref IMAGEINFO pImageInfo);

         [PreserveSig]
         int Copy(
            int iDst, 
            IImageList punkSrc, 
            int iSrc, 
            int uFlags);

         [PreserveSig]
         int Merge(
            int i1, 
            IImageList punk2, 
            int i2, 
            int dx, 
            int dy, 
            ref Guid riid, 
            ref IntPtr ppv);

         [PreserveSig]
         int Clone(
            ref Guid riid, 
            ref IntPtr ppv);

         [PreserveSig]
         int GetImageRect(
            int i, 
            ref RECT prc);

         [PreserveSig]
         int GetIconSize(
            ref int cx, 
            ref int cy);

         [PreserveSig]
         int SetIconSize(
            int cx, 
            int cy);

         [PreserveSig]
         int GetImageCount(
            ref int pi);

         [PreserveSig]
         int SetImageCount(
            int uNewCount);

         [PreserveSig]
         int SetBkColor(
            int clrBk, 
            ref int pclr);

         [PreserveSig]
         int GetBkColor(
            ref int pclr);

         [PreserveSig]
         int BeginDrag(
            int iTrack, 
            int dxHotspot, 
            int dyHotspot);

         [PreserveSig]
         int EndDrag();

         [PreserveSig]
         int DragEnter(
            IntPtr hwndLock, 
            int x, 
            int y);

         [PreserveSig]
         int DragLeave(
            IntPtr hwndLock);

         [PreserveSig]
         int DragMove(
            int x, 
            int y);

         [PreserveSig]
         int SetDragCursorImage(
            ref IImageList punk, 
            int iDrag, 
            int dxHotspot, 
            int dyHotspot);

         [PreserveSig]
         int DragShowNolock(
            int fShow);

         [PreserveSig]
         int GetDragImage(
            ref POINT ppt, 
            ref POINT pptHotspot, 
            ref Guid riid, 
            ref IntPtr ppv);
         
         [PreserveSig]
         int GetItemFlags(
            int i, 
            ref int dwFlags);

         [PreserveSig]
         int GetOverlayImage(
            int iOverlay, 
            ref int piIndex);
      };
      #endregion

      #region Member Variables
      private IntPtr hIml = IntPtr.Zero;
      private IImageList iImageList = null;
      private SysImageListSize size = SysImageListSize.smallIcons;
      private bool disposed = false;
      #endregion

      #region Implementation

      #region Properties
      /// &lt;summary&gt;
      /// Gets/sets the size of System Image List to retrieve.
      /// &lt;/summary&gt;
      public SysImageListSize ImageListSize
      {
         get
         {
            return size;
         }
         set
         {
            size = value;
            create();
         }

      }

      /// &lt;summary&gt;
      /// Returns the size of the Image List Icons.
      /// &lt;/summary&gt;
      public System.Drawing.Size Size
      {
         get
         {
            int cx = 0; 
            int cy = 0;
            if (iImageList == null)
            {
               ImageList_GetIconSize(
                  hIml,
                  ref cx, 
                  ref cy);
            }
            else
            {
               iImageList.GetIconSize(ref cx, ref cy);
            }
            System.Drawing.Size sz = new System.Drawing.Size(
               cx, cy);
            return sz;
         }      
      }
      #endregion

      #region Methods
      /// &lt;summary&gt;
      /// Returns a GDI+ copy of the icon from the ImageList
      /// at the specified index.
      /// &lt;/summary&gt;
      /// &lt;param name="index"&gt;&lt;/param&gt;
      /// &lt;returns&gt;&lt;/returns&gt;
      public Icon Icon(int index)
      {
         Icon icon = null;

         IntPtr hIcon = IntPtr.Zero;
         if (iImageList == null)
         {
            hIcon = ImageList_GetIcon(
               hIml,
               index,
               (int)ImageListDrawItemConstants.ILD_TRANSPARENT);

         }
         else
         {
            iImageList.GetIcon(
               index,
               (int)ImageListDrawItemConstants.ILD_TRANSPARENT,
               ref hIcon);
         }

         if (hIcon != IntPtr.Zero)
         {
            icon = System.Drawing.Icon.FromHandle(hIcon);
         }            
         return icon;
      }

      /// &lt;summary&gt;
      /// Return the index of the icon for the specified file, always using 
      /// the cached version where possible.
      /// &lt;/summary&gt;
      /// &lt;param name="fileName"&gt;Filename to get icon for&lt;/param&gt;
      /// &lt;returns&gt;&lt;/returns&gt;
      public int IconIndex(string fileName)
      {
         return IconIndex(fileName, false);
      }

      /// &lt;summary&gt;
      /// Returns the index of the icon for the specified file
      /// &lt;/summary&gt;
      /// &lt;param name="fileName"&gt;Filename to get icon for&lt;/param&gt;
      /// &lt;param name="forceLoadFromDisk"&gt;If True, then hit the disk to get the
       icon,
      /// otherwise only hit the disk if no cached icon is available.&lt;/param&gt;
      /// &lt;returns&gt;&lt;/returns&gt;
      public int IconIndex(string fileName, bool forceLoadFromDisk)
      {
         SHGetFileInfoConstants dwFlags =
          SHGetFileInfoConstants.SHGFI_SYSICONINDEX;
         int dwAttr = 0;
         if (size == SysImageListSize.smallIcons)
         {
            dwFlags |= SHGetFileInfoConstants.SHGFI_SMALLICON;
         }

         // We can choose whether to access the disk or not. If you don't
         // hit the disk, you may get the wrong icon if the icon is
         // not cached. But the speed is very good!
         if (!forceLoadFromDisk)
         {
            dwFlags |= SHGetFileInfoConstants.SHGFI_USEFILEATTRIBUTES;
            dwAttr = FILE_ATTRIBUTE_NORMAL;
         }
         else
         {            
            dwAttr = 0;
         }

         // sFileSpec can be any file. You can specify a
         // file that does not exist and still get the
         // icon, for example sFileSpec = "C:\PANTS.DOC"
         SHFILEINFO shfi = new SHFILEINFO();
         uint shfiSize = (uint)Marshal.SizeOf(shfi.GetType());
         IntPtr retVal = SHGetFileInfo( 
            fileName, dwAttr, ref shfi, shfiSize, 
            (uint)dwFlags);           

         if (retVal.Equals(IntPtr.Zero))
         {
            System.Diagnostics.Debug.Assert((!retVal.Equals(IntPtr.Zero)),"Faile
            d to get icon index");
            return 0;
         }
         else
         {
            return shfi.iIcon;
         }
      }

      /// &lt;summary&gt;
      /// Draws an image
      /// &lt;/summary&gt;
      /// &lt;param name="hdc"&gt;Device context to draw to&lt;/param&gt;
      /// &lt;param name="index"&gt;Index of image to draw&lt;/param&gt;
      /// &lt;param name="x"&gt;X Position to draw at&lt;/param&gt;
      /// &lt;param name="y"&gt;Y Position to draw at&lt;/param&gt;
      public void DrawImage( 
         IntPtr hdc,
         int index, 
         int x,
         int y
         )
      {
         DrawImage(hdc, index, x, y,
          ImageListDrawItemConstants.ILD_TRANSPARENT);
      }

      /// &lt;summary&gt;
      /// Draws an image using the specified flags
      /// &lt;/summary&gt;
      /// &lt;param name="hdc"&gt;Device context to draw to&lt;/param&gt;
      /// &lt;param name="index"&gt;Index of image to draw&lt;/param&gt;
      /// &lt;param name="x"&gt;X Position to draw at&lt;/param&gt;
      /// &lt;param name="y"&gt;Y Position to draw at&lt;/param&gt;
      /// &lt;param name="flags"&gt;Drawing flags&lt;/param&gt;
      public void DrawImage(
         IntPtr hdc,
         int index,
         int x,
         int y,
         ImageListDrawItemConstants flags
         )
      {
         if (iImageList == null)
         {
            int ret = ImageList_Draw(
               hIml, 
               index, 
               hdc, 
               x, 
               y, 
               (int)flags);
         }
         else
         {
            IMAGELISTDRAWPARAMS pimldp = new IMAGELISTDRAWPARAMS();
            pimldp.hdcDst = hdc;
            pimldp.cbSize = Marshal.SizeOf(pimldp.GetType());
            pimldp.i = index;
            pimldp.x = x;
            pimldp.y = y;
            pimldp.fStyle = (int)flags;
            iImageList.Draw(ref pimldp);
         }
         
      }

      /// &lt;summary&gt;
      /// Draws an image using the specified flags
      /// &lt;/summary&gt;
      /// &lt;param name="hdc"&gt;Device context to draw to&lt;/param&gt;
      /// &lt;param name="index"&gt;Index of image to draw&lt;/param&gt;
      /// &lt;param name="x"&gt;X Position to draw at&lt;/param&gt;
      /// &lt;param name="y"&gt;Y Position to draw at&lt;/param&gt;
      /// &lt;param name="flags"&gt;Drawing flags&lt;/param&gt;
      /// &lt;param name="cx"&gt;Width to draw&lt;/param&gt;
      /// &lt;param name="cy"&gt;Height to draw&lt;/param&gt;
      public void DrawImage(
         IntPtr hdc,
         int index,
         int x,
         int y,
         ImageListDrawItemConstants flags,
         int cx,
         int cy
         )
      {
         IMAGELISTDRAWPARAMS pimldp = new IMAGELISTDRAWPARAMS();
         pimldp.hdcDst = hdc;
         pimldp.cbSize = Marshal.SizeOf(pimldp.GetType());
         pimldp.i = index;
         pimldp.x = x;
         pimldp.y = y;
         pimldp.cx = cx;
         pimldp.cy = cy;
         pimldp.fStyle = (int)flags;
         if (iImageList == null)
         {
            int ret = ImageList_DrawIndirect(ref pimldp);
         }
         else
         {

            iImageList.Draw(ref pimldp);
         }
      }

      /// &lt;summary&gt;
      /// Determines if the system is running Windows XP
      /// or above
      /// &lt;/summary&gt;
      /// &lt;returns&gt;True if system is running XP or above, False
       otherwise&lt;/returns&gt;
      private bool isXpOrAbove()
      {
         bool ret = false;
         if (Environment.OSVersion.Version.Major &gt; 5)
         {
            ret = true;
         }
         else if ((Environment.OSVersion.Version.Major == 5) &amp;&amp;
            (Environment.OSVersion.Version.Minor &gt;= 1))
         {
            ret = true;
         }
         return ret;
      }

      /// &lt;summary&gt;
      /// Creates the SystemImageList
      /// &lt;/summary&gt;
      private void create()
      {
         // forget last image list if any:
         hIml = IntPtr.Zero;

         if (isXpOrAbove())
         {
            Guid iidImageList = new
             Guid("46EB5926-582E-4017-9FDF-E8998DAA0950");
            int ret = SHGetImageList(
               (int)size,
               ref iidImageList,
               ref iImageList
               );
         }
         else
         {
            // Prepare flags:
            SHGetFileInfoConstants dwFlags =
             SHGetFileInfoConstants.SHGFI_USEFILEATTRIBUTES |
             SHGetFileInfoConstants.SHGFI_SYSICONINDEX ;
            if (size == SysImageListSize.smallIcons)
            {
               dwFlags |= SHGetFileInfoConstants.SHGFI_SMALLICON;
            }
            // Get image list
            SHFILEINFO shfi = new SHFILEINFO();
            uint shfiSize = (uint)Marshal.SizeOf(shfi.GetType());

            hIml = SHGetFileInfo(".txt", FILE_ATTRIBUTE_NORMAL, ref shfi,
             shfiSize, (uint)dwFlags);
            System.Diagnostics.Debug.Assert ((hIml != IntPtr.Zero),"Failed to
             create Image List");
         }
      }

      /// &lt;summary&gt;
      /// Gets the hImageList handle
      /// &lt;/summary&gt;
      public IntPtr Handle
      {
         get
         {
            if (iImageList == null)
            {
               return this.hIml;
            }
            else
            {
               return Marshal.GetIUnknownForObject(
                  iImageList);                  
            }
         }
      }
      #endregion

      #region Constructor, Dispose, Destructor
      /// &lt;summary&gt;
      /// Creates a Small Icons SystemImageList 
      /// &lt;/summary&gt;
      public SysImageList()
      {
         create();
      }
      /// &lt;summary&gt;
      /// Creates a SystemImageList with the specified size
      /// &lt;/summary&gt;
      /// &lt;param name="size"&gt;Size of System ImageList&lt;/param&gt;
      public SysImageList(SysImageListSize size)
      {
         this.size = size;
         create();
      }
      public void Dispose()
      {
         Dispose(true);
         GC.SuppressFinalize(this);
      }
      public virtual void Dispose(bool disposing)
      {
         if (!disposed)
         {
            if (disposing) 
            {
               if (iImageList != null)
               {
                  Marshal.ReleaseComObject(iImageList);
               }
               iImageList = null;
            }
         }
         disposed = true;
      }
      ~SysImageList()
      {
         Dispose(false);
      }

   }
   #endregion

      #endregion

   #endregion
}
</pre><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<noscript>
<A HREF="..\..\..\vb\code\libraries\compression\index.html" ><IMG SRC="..\..\..\res\compress.png" ALT="Create and read Zip files and compress your data using Zlib" WIDTH=468 HEIGHT=60 BORDER=0></A>
</noscript>

</p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="..\..\..\index.html"><img width="125" height="25" src="..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\index.html">NET</a>&#160;.&#160;<a href="..\index.html">Utilities</a>&#160;.&#160;<a href="article.html">NetProjectZip</a>&#160;.&#160;<a href="netproject_zip.html">NetProject Zip</a>&#160;.&#160;SysImageList.cs</p><br /><p class="nav"><a href="..\..\..\the_site\copyright\article.html">Copyright</a> &#169; 2003 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 12 April 2003</p></td><td></td></tr></table>
</body></html>