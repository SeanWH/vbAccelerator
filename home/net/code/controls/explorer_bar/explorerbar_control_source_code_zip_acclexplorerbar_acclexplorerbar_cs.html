<html lang="en" >
<head>
<title>vbAccelerator - Contents of code file: acclExplorerBar_acclExplorerBar.cs</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="vbAccelerator - Contents of code file: acclExplorerBar_acclExplorerBar.cs" /><link rel="stylesheet" href="..\..\..\..\res\screen.css" media="SCREEN" /><link rel="stylesheet" href="..\..\..\..\res\print.css" media="PRINT" /><link rel="SHORTCUT ICON" href="/home/res/vbaccel.ico" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><td colspan="3">
<!-- TF 468x60 JScript HORIZ NoPop code -->
<script language=javascript><!--
document.write('<scr'+'ipt language=javascript src="http://a.tribalfusion.com/j.ad?site=VBAcceleratorcom&adSpace=ROS&size=468x60&type=horiz&pop=0&requestID='+((new Date()).getTime() % 2147483648) + Math.random()+'"></scr'+'ipt>');
//-->
</script>
<noscript>
   <a href="javascript:window.alert(&quot;http://a.tribalfusion.com/i.click?site=VBAcceleratorcom&adSpace=ROS&size=468x60&requestID=1423477941\nThis link was not retrieved.&quot;)" target=_blank>
   <img src="http://cdn5.tribalfusion.com/media/493786.gif" 
                  width=468 height=60 border=0 alt="Click Here"></a>
</noscript>
<!-- TF 468x60 JScript HORIZ NoPop code -->
</td></tr><tr class="navbar"><td><a href="..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\index.html">Code</a>&#160;.&#160;<a href="..\index.html">Controls</a>&#160;.&#160;<a href="article.html">.NET ExplorerBar Control</a>&#160;.&#160;<a href="explorerbar_control_source_code.html">ExplorerBar Control Source Code</a>&#160;.&#160;acclExplorerBar_acclExplorerBar.cs</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="..\..\..\..\res\download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="explorerbar_control_binary.html"><img src="..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />ExplorerBar Control Binary</a> (40K)</p><p class="nav"><a href="explorerbar_control_demonstration.html"><img src="..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />ExplorerBar Control Demonstration</a> (47K)</p><p class="nav"><a href="explorerbar_control_documentation.html"><img src="..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />ExplorerBar Control Documentation</a> (265K)</p><p class="nav"><a href="explorerbar_control_source_code.html"><img src="..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />ExplorerBar Control Source Code</a> (201K)</p><br /><br /><img src="..\..\..\..\res\information.png" width="125" height="21" alt="Information" /><p class="nav">Zip:14471</p><p class="nav">&#160;&#160;<a href="..\..\..\..\..\linkto_asp\id=14471&type=zip&title=explorerbar_20control_20source_20code_2ezip_5facclexplorerbar_5facclexplorer.html">Link to code Zip</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;C#</p><p class="nav">&#160;&#160;VB.NET</p><p class="nav">&#160;&#160;.NET</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="..\..\..\..\res\bugtrak.png" width="125" height="21" alt="BugTrak System" /><p class="nav">No logged bugs.</p><br /><br /><img src="..\..\..\..\res\updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="..\..\..\..\res\update.png" width="8" height="8" alt="Update" />17 Apr 2004<br />First Posted</p><br /><br /><img src="..\..\..\..\res\related.png" width="125" height="21" alt="Related Items" /><p class="nav"><img src="..\..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\..\..\..\vb\code\controls\explorer_bar_control\article.html">vbAccelerator Explorer Bar Control</a></p><p class="nav"><img src="..\..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\..\libraries\graphics\reading_exif_tags_from_jpg_files\article.html">Reading EXIF Tags From JPEG Files</a></p><br /><br /><img src="..\..\..\..\res\search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="javascript:window.alert(&quot;http://www.google.com/search\nThis link was not retrieved.&quot;)"><img src="..\..\..\..\..\..\www_google_com\logos\logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="..\..\..\..\the_site\newsite\article.html"><img src="..\..\..\..\res\newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>vbAccelerator - Contents of code file: acclExplorerBar_acclExplorerBar.cs</h1><pre>using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Resources;
using System.Windows.Forms;
using vbAccelerator.Components.Controls.ExplorerBarUtility;
using vbAccelerator.Components.Controls.ExplorerBarFramework;

namespace vbAccelerator.Components.Controls
{

   #region Delegates
   /// &lt;summary&gt;
   /// Represents the method that handles the &lt;see
    cref="acclExplorerBar.BarClick" /&gt; event.
   /// &lt;/summary&gt;
   public delegate void ExplorerBarClickEventHandler(object sender,
    ExplorerBarClickEventArgs args);
   /// &lt;summary&gt;
   /// Represents the method that handles the &lt;see
    cref="acclExplorerBar.ItemClick" /&gt; event.
   /// &lt;/summary&gt;
   public delegate void ExplorerBarItemClickEventHandler(object sender,
    ExplorerBarItemClickEventArgs args);
   /// &lt;summary&gt;
   /// Represnets the method that handles the &lt;see
    cref="acclExplorerBar.NonBarClick"/&gt; event.
   /// &lt;/summary&gt;
   public delegate void ExplorerBarClickBaseEventHandler (object sender,
    ExplorerBarClickBaseEventArgs args); 
   #endregion

   #region Enums
   /// &lt;summary&gt;
   /// Drawing Style options for the Explorer Bar control.  These options
   /// configure which type of drawing is performed depending on the 
   /// underlying OS.
   /// &lt;/summary&gt;
   public enum ExplorerBarDrawingStyle : int
   {
      /// &lt;summary&gt;
      /// Use the current system's style to draw the 
      /// ExplorerBar (will be either classic or XP)
      /// &lt;/summary&gt;
      System,
      /// &lt;summary&gt;
      /// Always use XP style (emulated if no XP styles available)
      /// &lt;/summary&gt;
      XP,
      /// &lt;summary&gt;
      /// Always draw in Windows Classic style.
      /// &lt;/summary&gt;
      Classic,
      /// &lt;summary&gt;
      /// Use XP style but customise colours to suit
      /// &lt;/summary&gt;
      Custom
   }

   /// &lt;summary&gt;
   /// Explorer Bar modes.
   /// &lt;/summary&gt;
   public enum ExplorerBarMode : int
   {
      /// &lt;summary&gt;
      /// The default Explorer Bar mode.  In this mode the Explorer
      /// bar renders a series of disconnected bars each of which
      /// have their own title.
      /// &lt;/summary&gt;
      Default,
      /// &lt;summary&gt;
      /// Search Explorer Bar mode.  In this mode, bars are joined
      /// together within a single frame.
      /// &lt;/summary&gt;
      Search
   }
   
   /// &lt;summary&gt;
   /// The state of a bar.
   /// &lt;/summary&gt;
   public enum ExplorerBarState : int
   {
      /// &lt;summary&gt;
      /// Bar is collapsed.
      /// &lt;/summary&gt;
      Collapsed,
      /// &lt;summary&gt;
      /// Bar is expanded.
      /// &lt;/summary&gt;
      Expanded
   }

   /// &lt;summary&gt;
   /// Processing performed on the Watermark bitmap before
   /// it is displayed in an Explorer Bar background
   /// &lt;/summary&gt;
   public enum ExplorerBarWatermarkMode : int
   {
      /// &lt;summary&gt;
      /// The Watermark is colourised to match the background
      /// colour of the bar.
      /// &lt;/summary&gt;
      Colourise,
      /// &lt;summary&gt;
      /// The Watermark is rendered directly without any processing.
      /// &lt;/summary&gt;
      Direct
   }

   /// &lt;summary&gt;
   /// Alignment of a Watermark within the Explorer Bar control.
   /// &lt;/summary&gt;
   public enum ExplorerBarWatermarkAlignment : int
   {
      /// &lt;summary&gt;
      /// The Watermark is aligned to the near margin of the bar.
      /// &lt;/summary&gt;
      Near,
      /// &lt;summary&gt;
      /// The Watermark is centred in the bar.
      /// &lt;/summary&gt;
      Center,
      /// &lt;summary&gt;
      /// The Watermark is aligned to the far margin of the bar.
      /// &lt;/summary&gt;
      Far
   }

   /// &lt;summary&gt;
   /// Types of ExplorerBar items
   /// &lt;/summary&gt;
   public enum ExplorerBarItemType : int
   {
      /// &lt;summary&gt;
      /// A clickable textual link with an optional icon
      /// &lt;/summary&gt;
      Link,
      /// &lt;summary&gt;
      /// Non-clickable text only.
      /// &lt;/summary&gt;
      Text,
      /// &lt;summary&gt;
      /// Non-clickable image.
      /// &lt;/summary&gt;
      Image,
      /// &lt;summary&gt;
      /// A place where a control can be added.
      /// &lt;/summary&gt;
      ControlPlaceHolder
   }
   #endregion

   /// &lt;summary&gt;
   /// An implementation of an XP Windows Explorer style side bar 
   /// control.  An Explorer Bar can be used in two ways:
   /// &lt;list type="number"&gt;
   /// &lt;item&gt;
   /// &lt;description&gt;To show contextual task information for the currently
    selected 
   /// item in the UI.  Each bar can be expanded and collapsed to allow the user
   /// to customise which information is shown.
   ///  &lt;/description&gt;
   /// &lt;/item&gt;
   /// &lt;item&gt;
   /// &lt;description&gt;To contain groupings of controls, some of which (for
    example, 
   /// representing advanced options) can be hidden by collapsing the bar that
   /// the item belongs to.
   /// &lt;/description&gt;
   /// &lt;/item&gt;
   /// &lt;/list&gt;
   /// The control can operate either drawing the Explorer style, using
    underlying
   /// XP theme information if available, or it can draw using an emulated style
   /// which is customisable.  The implementation of the control opens the 
   /// internal API for extension for bars with customised graphics.
   /// &lt;/summary&gt;
   public class acclExplorerBar : ControllableScrollableControl
   {
      #region Events
      /// &lt;summary&gt;
      /// Event raised when a bar's title is clicked.
      /// &lt;/summary&gt;
      public event ExplorerBarClickEventHandler BarClick;
      /// &lt;summary&gt;
      /// Event raised when an item is clicked.
      /// &lt;/summary&gt;
      public event ExplorerBarItemClickEventHandler ItemClick;
      /// &lt;summary&gt;
      /// Event raised when a non-bar area of the control is clicked.
      /// &lt;/summary&gt;
      public event ExplorerBarClickBaseEventHandler NonBarClick;
      #endregion

      #region Enums
      private enum ExplorerBarFocusReason
      {
         FocusByKey,
         FocusByMouse
      }
      #endregion

      #region Member Variables
      private ExplorerBarDrawingStyle drawingStyle =
       ExplorerBarDrawingStyle.System;
      private ExplorerBarMode drawingMode = ExplorerBarMode.Default;
      private bool showFocusRect = true;
      private XpThemeAPI xpTheme;
      private BarBitmaps barBitmaps;
      private Color backColorStart = Color.Empty;
      private Color backColorEnd = Color.Empty;
      private ImageList itemImageList = null;
      private ImageList titleImageList = null;
      private bool redraw = true;
      private ExplorerBarCollection bars = null;
      private ToolTip toolTip = null;
      private int lastWidth = 0;
      private int lastHeight = 0;
      private int internalBorder = 12;
      private IExplorerBarControlItem mouseOverItem = null;
      private IExplorerBarControlItem mouseDownItem = null;
      private Hashtable focusFakers = new Hashtable();
      private Hashtable focusFakerItems = new Hashtable();
      private ExplorerBarFocusReason focusReason =
       ExplorerBarFocusReason.FocusByMouse;
      private IExplorerBarControlItem focusItem = null;
      private bool barAnimations = true;
      private Bitmap animBitmap = null;
      private Point lastCursorPosition;

      /// &lt;summary&gt; 
      /// Required designer variable.
      /// &lt;/summary&gt;
      private System.ComponentModel.Container components = null;
      #endregion

      /// &lt;summary&gt;
      /// Constructs a new instance of the Explorer Bar control.
      /// &lt;/summary&gt;
      public acclExplorerBar()
      {
         // This call is required by the Windows.Forms Form Designer.
         InitializeComponent();

         FocusFaker faker = new FocusFaker(this);
         faker.Left = -faker.Width * 2;
         faker.Top = -faker.Height * 2;
         focusFakers.Add(this, faker);
         focusFakerItems.Add(faker, this);
         Controls.Add(faker);

         // I am a tab stop in the form:
         base.TabStop = true;
         // Set the styles to make things draw properly:
         base.SetStyle(
            ControlStyles.AllPaintingInWmPaint |
            ControlStyles.DoubleBuffer |
            ControlStyles.ResizeRedraw |
            ControlStyles.ContainerControl, 
            true);
         xpTheme = new XpThemeAPI();
         barBitmaps = new BarBitmaps();

         bars = new ExplorerBarCollection(this);
      }

      /// &lt;summary&gt; 
      /// Clean up any resources being used.
      /// &lt;/summary&gt;
      protected override void Dispose( bool disposing )
      {
         if( disposing )
         {
            if(components != null)
            {
               components.Dispose();
            }
         }
         base.Dispose( disposing );
      }

      #region Component Designer generated code
      /// &lt;summary&gt; 
      /// Required method for Designer support - do not modify 
      /// the contents of this method with the code editor.
      /// &lt;/summary&gt;
      private void InitializeComponent()
      {
         // 
         // acclExplorerBar
         // 
         this.Name = "acclExplorerBar";

      }
      #endregion


      #region Public Properties
      /// &lt;summary&gt;
      /// Gets whether the control is currently showing the focus rectangle or
       not.
      /// &lt;/summary&gt;
      public bool ShowingFocusRectangle
      {
         get
         {
            return (focusReason == ExplorerBarFocusReason.FocusByKey);
         }
      }

      /// &lt;summary&gt;
      /// Gets or sets a &lt;see cref="ToolTip"/&gt; to associate 
      /// with the control.
      /// &lt;/summary&gt;
      public System.Windows.Forms.ToolTip ToolTip
      {
         get
         {
            return toolTip;
         }
         set
         {
            toolTip = value;
         }
      }
      /// &lt;summary&gt;
      /// Gets the collection of bars associated with this
      /// control.
      /// &lt;/summary&gt;
      public ExplorerBarCollection Bars
      {
         get
         {
            return bars;
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets whether the control is redrawing or not.
      /// &lt;/summary&gt;
      public bool Redraw
      {
         get
         {
            return redraw;
         }
         set
         {
            if (redraw != value)
            {
               redraw = value;
               if (value)
               {
                  Invalidate();
               }
            }
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets the drawing style that will be used by the
      /// ExplorerBar control.
      /// &lt;/summary&gt;
      public ExplorerBarDrawingStyle DrawingStyle
      {
         get
         {
            return drawingStyle;
         }
         set
         {
            drawingStyle = value;
            DrawingStyleChanged(new EventArgs());
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the Explorer Bar mode.
      /// &lt;/summary&gt;
      public ExplorerBarMode Mode
      {
         get
         {
            return drawingMode;
         }
         set
         {
            drawingMode = value;
            DrawingStyleChanged(new EventArgs());
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets whether the focus rectangle should be shown for bars
      /// and items in the control.
      /// &lt;/summary&gt;
      public bool ShowFocusRect
      {
         get
         {
            return showFocusRect;
         }
         set
         {
            showFocusRect = value;
            Invalidate();
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the start colour of the background
      /// gradient when drawing using XPEmulated mode.
      /// Set to &lt;c&gt;Color.Empty&lt;/c&gt; for default colours.
      /// &lt;/summary&gt;
      public Color BackColorStart
      {
         get
         {
            return backColorStart;
         }
         set
         {
            backColorStart = value;
            Invalidate();
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets the end colour of the background
      /// gradient when drawing using XPEmulated mode.
      /// Set to &lt;c&gt;Color.Empty&lt;/c&gt; for default colours.
      /// &lt;/summary&gt;
      public Color BackColorEnd
      {
         get
         {
            return backColorEnd;
         }
         set
         {
            backColorEnd = value;
            Invalidate();
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the ImageList used to draw icons for
      /// items within bars.
      /// &lt;/summary&gt;
      public System.Windows.Forms.ImageList ImageList
      {
         get
         {
            return itemImageList;
         }
         set
         {
            itemImageList = value;
            Invalidate();
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the ImageList used to draw icons in
      /// the bar titles.
      /// &lt;/summary&gt;
      public System.Windows.Forms.ImageList TitleImageList
      {
         get
         {
            return titleImageList;
         }
         set
         {
            titleImageList = value;
            Invalidate();
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets whether bar state changes are animated or not.
      /// &lt;/summary&gt;
      public bool AnimateStateChanges
      {
         get
         {
            return barAnimations;
         }
         set
         {
            barAnimations = value;
         }
      }

      #endregion

      #region Overrides
      /// &lt;summary&gt;
      /// Processes a mnemonic key press.
      /// &lt;/summary&gt;
      /// &lt;param name="charCode"&gt;Character code for the key press&lt;/param&gt;
      /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if processed, &lt;c&gt;false&lt;/c&gt; otherwise.&lt;/returns&gt;
      protected override bool ProcessMnemonic(
         Char charCode )
      {
         bool processed = false;
         foreach (ExplorerBar bar in bars)
         {
            if (bar.ContainsMnemonic(charCode))
            {
               bar.Focused = true;
               OnBarClick(new ExplorerBarClickEventArgs(bar, MouseButtons.None,
                PointToClient(Cursor.Position)));
               processed = true;
               break;
            }
            else
            {
               foreach (ExplorerBarItem item in bar.Items)
               {
                  if (item.ContainsMnemonic(charCode))
                  {
                     item.Focused = true;
                     OnItemClick(new ExplorerBarItemClickEventArgs(item,
                      MouseButtons.None, PointToClient(Cursor.Position)));
                     processed = true;
                     break;
                  }
               }
            }
         }
         if (processed)
         {
            return true;
         }
         else
         {
            return base.ProcessMnemonic(charCode);
         }
      }

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="System.Windows.Forms.Control.GotFocus"/&gt; event
       and ensures that
      /// the focus rectangle is displayed when necessary.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Not used.&lt;/param&gt;
      protected override void OnGotFocus(
         EventArgs e
         )
      {
         base.OnGotFocus(e);

         if (ExplorerBarHelper.KeyIsPressed(Keys.Tab))
         {
            focusReason = ExplorerBarFocusReason.FocusByKey;
         }
         else
         {
            focusReason = ExplorerBarFocusReason.FocusByMouse;
         }

         // Find first bar and set the focus to it:
         if (bars.Count &gt; 0)
         {
            if (ExplorerBarHelper.KeyIsPressed(Keys.ShiftKey))
            {
               bars[bars.Count-1].Focused = true;
            }
            else
            {
               bars[0].Focused = true;
            }
         }

      }

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="System.Windows.Forms.Control.MouseMove"/&gt; event
      /// and performs internal mouse move processing.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;&lt;see cref="MouseEventArgs"/&gt; describing
      /// the MouseMove event&lt;/param&gt;
      protected override void OnMouseMove(
         MouseEventArgs e
         )
      {
         base.OnMouseMove(e);         
         
         if (e.Button == MouseButtons.None)
         {
            // Check whether the mouse actually moved
            if (Cursor.Position != lastCursorPosition)
            {
               Point location = new Point(e.X, e.Y);

               ExplorerBar bar = HitTestBar(location);
               if (bar != null)
               {
                  bar.MouseOver = true;
                  setToolTip(bar.ToolTipText);
               }
               else
               {
                  ExplorerBarItem item = HitTestItem(location);
                  if (item != null)
                  {
                     item.MouseOver = true;
                     setToolTip(item.ToolTipText);
                  }
                  else
                  {
                     InternalOnItemMouseOver(null);
                     setToolTip("");
                  }
               }
            }
            if ((mouseOverItem != null) &amp;&amp; (mouseOverItem.Clickable))
            {               
               ResourceManager resources = new
                ResourceManager(typeof(acclExplorerBar));               
               Cursor = (Cursor) (resources.GetObject("Hand"));
            }
            else
            {
               Cursor = Cursors.Default;
            }
            lastCursorPosition = Cursor.Position;
         }
      }

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="System.Windows.Forms.Control.MouseDown"/&gt; event
      /// and performs internal mouse down processing.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;&lt;see cref="MouseEventArgs"/&gt; describing
      /// the MouseDown event&lt;/param&gt;
      protected override void OnMouseDown(
         MouseEventArgs e
         )
      {
         base.OnMouseDown(e);
         
         Point location = new Point(e.X, e.Y);

         ExplorerBar bar = HitTestBar(location);
         if (bar != null)
         {
            bar.MouseOver = true;
            bar.MouseDown = true;
         }
         else
         {
            ExplorerBarItem item = HitTestItem(location);
            if (item != null)
            {
               item.MouseOver = true;
               item.MouseDown = true;
            }
            else
            {
               if (mouseOverItem != null)
               {
                  mouseOverItem.MouseOver = false;
               }
            }
         }


      }

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="System.Windows.Forms.Control.MouseUp"/&gt; event
      /// and performs internal mouse up processing.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;&lt;see cref="MouseEventArgs"/&gt; describing
      /// the MouseUp event&lt;/param&gt;
      protected override void OnMouseUp(
         MouseEventArgs e
         )
      {
         base.OnMouseUp(e);

         Point location = new Point(e.X, e.Y);
         bool actionned = false;
         
         if (mouseDownItem != null)
         {
            if (mouseDownItem.HitTest(location, ClientRectangle.Width,
             VerticalScrollBar.Visible))
            {
               mouseDownItem.Focused = true;
               ActionFocusItem(e.Button, location);
               actionned = true;
            }
         }
         
         if (!actionned)
         {
            // general click somewhere
            OnNonBarClick(new ExplorerBarClickBaseEventArgs(e.Button,
             location));
         }
         
         if (mouseDownItem != null)
         {
            mouseDownItem.MouseDown = false;
            mouseDownItem = null;
         }

      }

      private void ActionFocusItem()
      {
         ActionFocusItem(MouseButtons.None, PointToClient(Cursor.Position));
      }

      private void ActionFocusItem(MouseButtons button, Point location)
      {
         if (focusItem != null)
         {            
            if (focusItem.Clickable)
            {
               if (typeof(ExplorerBar).IsAssignableFrom(focusItem.GetType()))
               {
                  if (
                     ((button == MouseButtons.None) || (button ==
                      MouseButtons.Left))
                     &amp;&amp; (focusItem.Clickable))
                  {
                     InternalChangeBarState((ExplorerBar) focusItem);
                  }
                  OnBarClick(new ExplorerBarClickEventArgs((ExplorerBar)
                   focusItem, button, location));
               }
               else
               {
                  OnItemClick(new
                   ExplorerBarItemClickEventArgs((ExplorerBarItem) focusItem,
                   button, location));
               }
            }
         }
      }         

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="System.Windows.Forms.Control.MouseLeave"/&gt; event
      /// and performs internal mouse leave processing.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Not used&lt;/param&gt;
      protected override void OnMouseLeave(
         EventArgs e
         )
      {
         base.OnMouseLeave(e);
         if (mouseOverItem != null)
         {
            mouseOverItem.MouseOver = false;
            mouseOverItem = null;
         }
      }

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="Control.SizeChanged"/&gt; event and re-evaluates
      /// the items in the control if necessary.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;&lt;/param&gt;
      protected override void OnSizeChanged(
         EventArgs e
         )
      {
         if (bars.Count &gt; 0)
         {
            if (Width != lastWidth)
            {         
               Graphics graphics = Graphics.FromHwnd(Handle);
               ExplorerBarMeasureItemParams measureItemParams =
                MeasureItemParams(graphics);
               foreach (ExplorerBar bar in bars)
               {
                  bar.InternalMeasureItem(measureItemParams);
               }
               graphics.Dispose();
            
               lastWidth = Width;
               
               Invalidate();
            }

            if (Height != lastHeight)
            {               
               SetScroll();
               lastHeight = Height;
            }
         }

         base.OnSizeChanged(e);
      }

      /// &lt;summary&gt;
      /// Determines whether the specified key should be
      /// processed by the control.
      /// &lt;/summary&gt;
      /// &lt;param name="keyData"&gt;Information about the key.&lt;/param&gt;
      /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if th control processes the key,
      /// otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
      protected override bool IsInputKey(
         System.Windows.Forms.Keys keyData)
      {
         bool ret = false;
         switch (keyData)
         {
            case Keys.Up:
            case Keys.Down:
            case Keys.Right:
            case Keys.Left:
            case Keys.Enter:
            case Keys.Tab:
               ret = true;
               break;
            default:
               ret = base.IsInputKey(keyData);
               break;
         }         
         return ret;
      }   

      /// &lt;summary&gt;
      /// Handles system colour changes and raises the
       &lt;c&gt;SystemColorsChanged&lt;/c&gt;
      /// event.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Not used&lt;/param&gt;
      protected override void OnSystemColorsChanged ( EventArgs e )
      {
         base.OnSystemColorsChanged(e);

         DrawingStyleChanged(e);
         Invalidate();
      }

      /// &lt;summary&gt;
      /// Raises the &lt;c&gt;Scroll&lt;/c&gt; event for the control and updates
      /// the display.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Scroll event information.&lt;/param&gt;
      protected override void OnScroll(ControllableScrollEventArgs e)
      {
         base.OnScroll(e);
         Invalidate();
      }

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="System.Windows.Forms.Control.HandleCreated"/&gt;
       event and 
      /// performs activities related to building the control's
      /// style.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Not used.&lt;/param&gt;
      protected override void OnHandleCreated(EventArgs e)
      {
         base.OnHandleCreated(e);

         DrawingStyleChanged(e);
      }

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="System.Windows.Forms.Control.Paint"/&gt; event and
       paints the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Information about the painting event to
       perform&lt;/param&gt;
      protected override void OnPaint(PaintEventArgs e)
      {
         if (redraw)
         {

            // Draw the background of the control:         
            xpTheme.DrawBackground(e.Graphics, 
               base.ClientRectangle, 
               drawingStyle,
               backColorStart,
               backColorEnd);

            ExplorerBarDrawItemParams drawItemParams =
             DrawItemParams(e.Graphics);

            int top = drawItemParams.Top;
            int height = 0;
            if (drawingMode == ExplorerBarMode.Search)
            {
               foreach (ExplorerBar bar in bars)
               {
                  height += drawItemParams.ScrollShowing ? bar.HeightWithScroll
                   : bar.HeightWithoutScroll;
                  height += internalBorder;               
               }
               ExplorerBarHelper.DrawSearchContainer(
                  e.Graphics, base.ClientRectangle, drawItemParams.Top, height,
                   internalBorder,
                  barBitmaps.NormalPanelColor);
            }

            // Now paint the bars:
            top = drawItemParams.Top;
            foreach (ExplorerBar bar in bars)
            {               
               // Change top for next item
               height = drawItemParams.ScrollShowing ? bar.HeightWithScroll :
                bar.HeightWithoutScroll;
               if ((top &lt; ClientRectangle.Height) &amp;&amp; (top + height &gt;= 0))
               {
                  bar.InternalDrawItem(drawItemParams);
               }
               else
               {
                  bar.InternalMakeControlsVisible(false);
               }
               top += height;
               top += internalBorder;
               drawItemParams.SetTop(top);
            }
         }
      }
      #endregion

      #region Overridable subs
      /// &lt;summary&gt;
      /// Raises the &lt;see cref="BarClick"/&gt; event.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Event arguments relating to the bar that was
       clicked&lt;/param&gt;
      protected virtual void OnBarClick(ExplorerBarClickEventArgs e)
      {
         if (BarClick != null)
         {
            BarClick(this, e);
         }
      }

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="ItemClick"/&gt; event.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Event arguments relating to the item that was
       clicked&lt;/param&gt;
      protected virtual void OnItemClick(ExplorerBarItemClickEventArgs e)
      {
         e.Item.Click();
         if (ItemClick != null)
         {
            ItemClick(this, e);
         }
      }

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="NonBarClick"/&gt; event.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Event arguments relating to the click&lt;/param&gt;
      protected virtual void OnNonBarClick(ExplorerBarClickBaseEventArgs e)
      {
         if (NonBarClick != null)
         {
            NonBarClick(this, e);
         }
      }

      private void DrawingStyleChanged(EventArgs e)
      {
         // Get the right XP Theme:
         xpTheme.Handle = base.Handle;
         xpTheme.ClassList = "ExplorerBar";

         // Get the appropriate bitmaps:
         barBitmaps.Load(base.Handle, drawingStyle);

         // Colourise any watermarks that we need to
         foreach (ExplorerBar bar in bars)
         {
            if (bar.Watermark != null)
            {
               if (bar.WatermarkMode == ExplorerBarWatermarkMode.Colourise)
               {
                  InternalOnBarWatermarkChanged(bar);
               }
            }
         }

         // Redraw the control with the new changes in place
         Invalidate();

      }
      #endregion

      #region Internal implementation
      internal void InternalOnItemMouseOver(IExplorerBarControlItem item)
      {
         if (mouseOverItem != null)
         {
            if (mouseOverItem != item)
            {
               mouseOverItem.MouseOver = false;
            }
         }
         mouseOverItem = item;
      }

      internal void InternalOnItemMouseDown(IExplorerBarControlItem item)
      {
         if (mouseDownItem != null)
         {
            if (mouseDownItem != item)
            {
               mouseDownItem.MouseDown = false;
            }
         }
         mouseDownItem = item;
      }

      internal void InternalOnItemFocus(IExplorerBarControlItem item)
      {
         if (focusItem != null)
         {
            if (focusItem != item)
            {
               focusItem.Focused = false;               
            }
         }
         focusItem = item;
      }

      /// &lt;summary&gt;
      /// Measures an item which has been added to a bar and resizes the 
      /// control to fit.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;Item which has just been added.&lt;/param&gt;
      internal void InternalOnItemAdd(ExplorerBarItem item)
      {
         ExplorerBar bar = bars.BarForItem(item);         
         Debug.Assert(bar != null, "InternalOnItemAdd called for item which
          does not belong to a bar");

         // Note; currently remeasuring all items in the bar.
         // could be more efficient by just measuring the added
         if (bar != null)
         {
            Graphics graphics = Graphics.FromHwnd(Handle);
            ExplorerBarMeasureItemParams measureItemParams =
             MeasureItemParams(graphics);
            bar.InternalMeasureItem(measureItemParams);
            graphics.Dispose();

            // Check size ok
            SetScroll();

            // Only need to invalidate the bar and any subsequent bars
            Invalidate();
         }
         
      }

      /// &lt;summary&gt;
      /// When an item has a control, the bar loads an internal control to
       follow it
      /// to ensure that focus is passed on in the correct order.  This routine 
      /// corrects the internal state of the control whenever an item's control
       is
      /// changed.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;Item who's control is changed&lt;/param&gt;
      /// &lt;param name="oldControl"&gt;Previous control associated with the item, or
      /// &lt;c&gt;null&lt;/c&gt; if no control.&lt;/param&gt;
      /// &lt;param name="newControl"&gt;New control associated with the item, or
      /// &lt;c&gt;null&lt;/c&gt; if no control.&lt;/param&gt;
      public void OnItemControlChanged(ExplorerBarItem item, Control
       oldControl, Control newControl)
      {
         FocusFaker faker = null;
         if (oldControl != null)
         {
            if (focusFakers.ContainsKey(oldControl))
            {
               focusFakerItems.Remove(item);
               faker = (FocusFaker) focusFakers[oldControl];
               Controls.Remove(faker);
               focusFakers.Remove(oldControl);
               faker.Dispose();
               faker = null;
            }
            oldControl.Visible = false;
         }
         if (newControl != null)
         {
            Controls.Add(newControl);
            faker = new FocusFaker(this);
            faker.Left = -faker.Width * 2;
            faker.Top = -faker.Height * 2;
            focusFakers.Add(newControl, faker);
            focusFakerItems.Add(faker, item);
            Controls.Add(faker);
         }
      }

      /// &lt;summary&gt;
      /// Remeasures the control in response to the size of an
      /// item changing and redraws.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;Item which has changed size.&lt;/param&gt;
      internal void InternalOnItemSizeChanged(ExplorerBarItem item)
      {
         //Console.WriteLine("OnItemSizeChanged");
      }

      /// &lt;summary&gt;
      /// Redraws an item.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;Item to redraw.&lt;/param&gt;
      internal void InternalOnItemRedraw(ExplorerBarItem item)
      {
         // Only actually need to invalidate the item:
         Invalidate();
      }

      /// &lt;summary&gt;
      /// Remeasures the control in response to the size of a 
      /// bar changing and redraws.
      /// &lt;/summary&gt;
      /// &lt;param name="bar"&gt;Bar which has changed size.&lt;/param&gt;
      internal void InternalOnBarResized(ExplorerBar bar)
      {
         // Make sure the control is remeasured:
         Graphics graphics = Graphics.FromHwnd(Handle);
         ExplorerBarMeasureItemParams measureItemParams =
          MeasureItemParams(graphics);
         foreach (ExplorerBar otherBar in bars)
         {
            otherBar.InternalMeasureItem(measureItemParams);
         }
         graphics.Dispose();
         SetScroll();
         Invalidate();
      }

      internal void InternalEnsureVisible(ExplorerBar bar)
      {
         if (VerticalScrollBar.Visible)
         {
            int top = 0;
            int height = 0;
            foreach (ExplorerBar testBar in bars)
            {
               height =  testBar.HeightWithScroll + internalBorder;
               if (bar == testBar)
               {
                  if (top &lt; VerticalScrollBar.Value)
                  {
                     VerticalScrollBar.Value = top;
                     Invalidate();
                  }
                  else if (top + height + 6 &gt; ClientRectangle.Height +
                   VerticalScrollBar.Value)
                  {
                     // Can we fit the entire bar in 
                     if ((height + 6) &lt; ClientRectangle.Height)
                     {
                        // Yes
                        VerticalScrollBar.Value = (top + height + 6) -
                         ClientRectangle.Height;
                        Invalidate();
                     }
                     else
                     {
                        // No 
                        VerticalScrollBar.Value = top;
                        Invalidate();
                     }
                  }
                  break;
               }
               top += height;
            }

         }
      }


      internal void InternalEnsureVisible(ExplorerBarItem item)
      {
         if (VerticalScrollBar.Visible)
         {
            int top = -VerticalScrollBar.Value;
            int height = 0;
            foreach (ExplorerBar testBar in bars)
            {
               height =  testBar.HeightWithScroll;
               if (testBar.Items.Contains(item))
               {
                  // locate the top of the item:
                  if (top &lt; 0)
                  {
                     VerticalScrollBar.Value += top + 12;
                  }
                  else if (top + height &gt; ClientRectangle.Height)
                  {
                     VerticalScrollBar.Value = top + height + 12;
                  }
                  break;
               }
               top += height;
               top += internalBorder;
            }
         }
      }

      internal void InternalKeyDown(FocusFaker faker, KeyEventArgs e)
      {
         IExplorerBarControlItem candidate = null;
         switch (e.KeyCode)
         {
            case Keys.Up:
               candidate = FindNextCandidate(focusItem, true);   
               break;
            case Keys.Down:
               candidate = FindNextCandidate(focusItem, false);
               break;
         }
         if (candidate != null)
         {
            candidate.Focused = true;
         }

      }

      private IExplorerBarControlItem FindNextCandidate(
         IExplorerBarControlItem currentItem,
         bool upwards
         )
      {
         IExplorerBarControlItem candidate = null;
         if (focusItem == null)
         {
            candidate = FindCandidateTabItem(false);
         }
         else
         {
            ExplorerBar bar;
            if (typeof(ExplorerBarItem).IsAssignableFrom(currentItem.GetType()))
            {
               // Item is currently focused
               ExplorerBarItem item = (ExplorerBarItem) currentItem;
               bar = item.Bar;
               if (upwards)
               {
                  if (bar.State == ExplorerBarState.Expanded)
                  {
                     candidate = bar.Items.PreviousFocusableItem(item);
                  }
                  if (candidate == null)
                  {
                     candidate = bar;
                  }
               }
               else
               {
                  if (bar.State == ExplorerBarState.Expanded)
                  {
                     candidate = item.Bar.Items.NextFocusableItem(item);
                  }
                  if (candidate == null)
                  {
                     candidate = bars.Next(bar);
                  }
               }
            }
            else
            {
               // Bar is current focused
               candidate = FindCandidateTabItem(currentItem, upwards);
            }
         }
         return candidate;
      }

      /// &lt;summary&gt;
      /// Determine what to do if a focus faker gets the input key
      /// &lt;/summary&gt;
      /// &lt;param name="focusFrom"&gt;Control with focus&lt;/param&gt;
      internal void InternalGotFocus(FocusFaker focusFrom)
      {         
         IExplorerBarControlItem candidate = null;

         Object item = focusFakerItems[focusFrom];
         if (item == null)
         {
            return;
         }
         if (typeof(acclExplorerBar).IsAssignableFrom(item.GetType()))
         {
            // The control has received input focus
            if (focusItem != null)
            {
               focusItem.Focused = false;
               focusItem = null;
            }
            candidate =
             FindCandidateTabItem(ExplorerBarHelper.KeyIsPressed(Keys.ShiftKey))
            ;
         }
         else
         {
            // A control inside this control has just lost input focus
            IExplorerBarControlItem lastItem = (IExplorerBarControlItem) item;
            candidate = FindNextCandidate(lastItem,
             ExplorerBarHelper.KeyIsPressed(Keys.ShiftKey));
         }

         if (candidate != null)
         {
            focusItem = candidate;
            focusItem.Focused = true;   
         }

      }

      /// &lt;summary&gt;
      /// Determine if the key is an input key.
      /// &lt;/summary&gt;
      /// &lt;param name="focusFrom"&gt;Control with focus&lt;/param&gt;
      /// &lt;param name="keyData"&gt;Keys to parse&lt;/param&gt;
      /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the key is an input key, &lt;c&gt;false&lt;/c&gt;
       otherwise.&lt;/returns&gt;
      internal bool InternalIsInputKey(FocusFaker focusFrom,
       System.Windows.Forms.Keys keyData)
      {   
         focusReason = ExplorerBarFocusReason.FocusByKey;
         bool isInputKey = false;
         
         if ((keyData == Keys.Tab) || (keyData == (Keys.Tab | Keys.Shift)))
         {
            IExplorerBarControlItem candidate = FindCandidateTabItem(focusFrom, 
               (keyData &amp; Keys.Shift) == Keys.Shift);
            if (candidate != null)
            {
               candidate.Focused = true;
               isInputKey = true;
            }
            else
            {
               if (focusItem != null)
               {
                  focusItem.Focused = false;
               }
            }
            if (focusReason != ExplorerBarFocusReason.FocusByKey)
            {
               focusReason = ExplorerBarFocusReason.FocusByKey;
               Invalidate();
            }
         }
         else
         {
            if (focusItem != null)
            {
               if (focusItem.Clickable)
               {
                  ActionFocusItem();
                  isInputKey = true;
               }
            }
         }

         return isInputKey;
      }

      /// &lt;summary&gt;
      /// Finds the the next item to tab to given a tab event in
      /// the specified focus control.
      /// &lt;/summary&gt;
      /// &lt;param name="focusFrom"&gt;Focus control in which tab event
       occurred&lt;/param&gt;
      /// &lt;param name="upwards"&gt;Whether to search upwards or not&lt;/param&gt;
      /// &lt;returns&gt;Item if found, null otherwise&lt;/returns&gt;
      private IExplorerBarControlItem FindCandidateTabItem(
         FocusFaker focusFrom,
         bool upwards
         )
      {
         IExplorerBarControlItem candidate = null;
         
         // Find next focus candidate:
         
         // Firstly, is anything focused:
         if (focusItem == null)
         {
            Object focused = focusFakerItems[focusFrom];
            if (typeof(ExplorerBarItem).IsAssignableFrom(focused.GetType()))
            {
               // focus item is for an item
               IExplorerBarControlItem startItem = (IExplorerBarControlItem)
                focused;
               candidate = FindCandidateTabItem(startItem, upwards);
            }
            else
            {
               // focus item represents the control
               candidate = FindCandidateTabItem(upwards);
            }
         }
         else
         {
            // something previously focused in the control
            candidate = FindCandidateTabItem(focusItem, upwards);
         }

         return candidate;
      }

      /// &lt;summary&gt;
      /// Finds the next candidate tab item when nothing has been focused
      /// &lt;/summary&gt;
      /// &lt;param name="upwards"&gt;Whether to search upwards or downwards&lt;/param&gt;
      /// &lt;returns&gt;Item if found, null otherwise &lt;/returns&gt;
      private IExplorerBarControlItem FindCandidateTabItem(
         bool upwards
         )
      {
         IExplorerBarControlItem candidate = null;
         // Nothing currently in focus, find first bar or last item
         if (upwards)
         {
            // last item
            int index = bars.Count - 1;
            while ((candidate == null) &amp;&amp; (index &gt;= 0))
            {
               if (bars[index].State == ExplorerBarState.Expanded)
               {
                  candidate = bars[index].Items.FindLastFocusableItem();
               }
               if (candidate == null)
               {
                  if (bars[index].Clickable)
                  {
                     candidate = bars[index];
                  }
               }
               index--;
            }
         }
         else
         {
            int index = 0;
            while ((candidate == null) &amp;&amp; (index &lt; bars.Count))
            {
               if (bars[index].Clickable)
               {
                  candidate = bars[index];
               }
               else
               {
                  if (bars[index].State == ExplorerBarState.Expanded)
                  {
                     candidate = bars[index].Items.FindFirstFocusableItem();
                  }
               }
               index++;
            }
         }
         return candidate;
      }

      private IExplorerBarControlItem FindCandidateTabItem(
         IExplorerBarControlItem firstItem,
         bool upwards
         )
      {
         IExplorerBarControlItem candidate = null;

         if (typeof(ExplorerBarItem).IsAssignableFrom(firstItem.GetType()))
         {
            // item focused, find next or previous bar
            ExplorerBarItem item = (ExplorerBarItem) firstItem;
            ExplorerBar bar = item.Bar;
            bool found = false;
            if (upwards)
            {
               while (!found)
               {
                  candidate = bar;
                  if (!candidate.Clickable)
                  {
                     candidate = bar.Items.FindLastFocusableItem();
                     if (candidate == null)
                     {
                        bar = bars.Previous(bar);
                        found = (bar == null);
                     }
                     else
                     {
                        found = true;
                     }
                  }
                  else
                  {
                     found = true;
                  }
               }               
            }
            else
            {            
               while (!found)
               {
                  candidate = bars.Next(bar);
                  if (candidate != null)
                  {
                     if (!candidate.Clickable)
                     {
                        bar = (ExplorerBar) candidate;
                        candidate = null;
                        candidate = bar.Items.FindFirstFocusableItem();
                        if (candidate == null)
                        {
                           bar = bars.Next(bar);
                           found = (bar == null);
                        }
                        else
                        {
                           found = true;
                        }
                     }
                     else
                     {
                        found = true;
                     }
                  }
                  else
                  {
                     found = true;
                  }
               }
            }
         }
         else
         {
            // bar focused, find first item in bar or last item in previous bar
            ExplorerBar bar = (ExplorerBar) firstItem;
            if (upwards)
            {
               bar = bars.Previous(bar);
               if (bar != null)
               {
                  if (bar.State == ExplorerBarState.Expanded)
                  {
                     candidate = bar.Items.FindLastFocusableItem();
                  }
                  if (candidate == null)
                  {
                     candidate = bar;
                  }
               }
            }
            else
            {
               if (bar.State == ExplorerBarState.Expanded)
               {
                  candidate = bar.Items.FindFirstFocusableItem();
               }
               if (candidate == null)
               {
                  candidate = bars.Next(bar);
               }
            }
         }
         
         return candidate;
      }

      /// &lt;summary&gt;
      /// Finds the focus item which the specified focus fake control
      /// has been added for.
      /// &lt;/summary&gt;
      /// &lt;param name="focusFrom"&gt;Focus Fake control&lt;/param&gt;
      /// &lt;returns&gt;Item which the control was added for.&lt;/returns&gt;
      private IExplorerBarControlItem FindItemForFocusFaker(FocusFaker
       focusFrom)
      {
         IExplorerBarControlItem theItem = null;
         Object item = focusFakers[focusFrom];
         if (typeof(IExplorerBarControlItem).IsAssignableFrom(item.GetType()))
         {
            theItem = (IExplorerBarControlItem) item;
         }
         return theItem;
      }

      /// &lt;summary&gt;
      /// Clears up any internal variables which refer to an
      /// Bar being removed from the ExplorerBar.
      /// &lt;/summary&gt;
      /// &lt;param name="bar"&gt;Bar to remove&lt;/param&gt;
      internal void InternalOnBarRemoved(ExplorerBar bar)
      {
         if (mouseOverItem == bar)
         {
            mouseOverItem = null;
         }
         if (mouseDownItem == bar)
         {
            mouseDownItem = null;
         }
         if (focusItem == bar)
         {
            focusItem = null;
         }
         InternalOnBarResized(bar);
      }

      /// &lt;summary&gt;
      /// Clears up any internal variables which refer to an
      /// Item being removed from the ExplorerBar.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;Item to remove&lt;/param&gt;
      internal void InternalOnItemRemoved(ExplorerBarItem item)
      {
         if (mouseOverItem == item)
         {
            mouseOverItem = null;
         }
         if (mouseDownItem == item)
         {
            mouseDownItem = null;
         }
         if (focusItem == item)
         {
            focusItem = null;
         }
         // Make sure the control is remeasured:
         InternalOnBarResized(item.Bar);
      }

      internal ExplorerBar InternalBarForItem(ExplorerBarItem item)
      {
         return bars.BarForItem(item);
      }

      /// &lt;summary&gt;
      /// Ensures a bar has the correct title colours and 
      /// redraws it.
      /// &lt;/summary&gt;
      /// &lt;param name="bar"&gt;Bar to redraw&lt;/param&gt;
      internal void InternalOnBarRedraw(ExplorerBar bar)
      {
         // Ensure the bar bitmaps have the right colours:
         if (bar.IsSpecial)
         {
            barBitmaps.SpecialTitleColorDark = bar.TitleBackColorEnd;
            barBitmaps.SpecialTitleColorLight = bar.TitleBackColorStart;
         }
         else
         {
            barBitmaps.NormalTitleColorDark = bar.TitleBackColorEnd;
            barBitmaps.NormalTitleColorLight = bar.TitleBackColorStart;
         }
         // Only actually need to invalidate the bar in question
         Invalidate();
      }

      /// &lt;summary&gt;
      /// Ensures the watermark bitmap for a bar is colourised according
      /// to the current display settings.
      /// &lt;/summary&gt;
      /// &lt;param name="bar"&gt;Bar to colourise watermark for&lt;/param&gt;
      internal void InternalOnBarWatermarkChanged(ExplorerBar bar)
      {
         Debug.Assert(bar != null, "InternalOnBarWatermarkChanged called with
          null bar parameter");
         Debug.Assert(bar.Watermark != null, "InternalOnBarWatermarkChanged
          called for bar without watermark");
         bar.ProcessedWatermark = (Bitmap) bar.Watermark.Clone();      
         Color backColor = ExplorerBarHelper.BarBackColor(
            bar.BackColor, drawingStyle, barBitmaps, xpTheme, bar.IsSpecial);
         ImageUtility.ColouriseWatermark(bar.ProcessedWatermark, backColor);
         Invalidate();
      }

      /// &lt;summary&gt;
      /// Gets the object which manages the currently selected XP theme.
      /// &lt;/summary&gt;
      internal XpThemeAPI XpTheme
      {
         get
         {
            return xpTheme;
         }
      }

      /// &lt;summary&gt;
      /// Gets the object which manages the bitmaps to display for
      /// bar titles and buttons.
      /// &lt;/summary&gt;
      internal BarBitmaps Bitmaps
      {
         get
         {
            return barBitmaps;
         }
      }
      #endregion

      #region Private implementation
      /// &lt;summary&gt;
      /// Sets the mouse down flag for the specified item,
      /// clearing any existing focus or mouse over items
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;Item to set MouseDown flag on&lt;/param&gt;
      private void SetMouseDown(ExplorerBarItem item)
      {
         item.MouseDown = true;
         item.Focused = true;
      }


      /// &lt;summary&gt;
      /// Changes the state of a Bar from expanded to collapsed or
      /// vice-versa, animating the bar if configured to do so.
      /// &lt;/summary&gt;
      /// &lt;param name="bar"&gt;Bar to change state&lt;/param&gt;
      internal void InternalChangeBarState(ExplorerBar bar)
      {
         // Determine from &amp; to for the bar change operation
         bool scroll = VerticalScrollBar.Visible;
         int currentHeight = 0;
         int targetHeight = 0;
         if (bar.State == ExplorerBarState.Expanded)
         {
            currentHeight = (scroll ? bar.HeightWithScroll :
             bar.HeightWithoutScroll);
            targetHeight = (scroll ? bar.TitleHeightWithScroll :
             bar.TitleHeightWithoutScroll);
            bar.InternalSetState(ExplorerBarState.Collapsed);
         }
         else
         {
            currentHeight = (scroll ? bar.TitleHeightWithScroll :
             bar.TitleHeightWithoutScroll);
            bar.InternalSetState(ExplorerBarState.Expanded);
            targetHeight = (scroll ? bar.HeightWithScroll :
             bar.HeightWithoutScroll);
         }
         double direction = Math.Sign(targetHeight - currentHeight);
         SetScroll();

         if ((bar.AnimateStateChanges) &amp;&amp; (barAnimations))
         {
            // Create a memory bitmap to draw onto:
            Bitmap bm = new Bitmap(ClientRectangle.Width, (currentHeight &gt;
             targetHeight ? currentHeight : targetHeight));
            // Clone it so it actually is 32bpp Argb
            animBitmap = bm.Clone(new Rectangle(0, 0, bm.Width, bm.Height),
               PixelFormat.Format32bppArgb);
            bm.Dispose();

            bar.SetAnimationInformation((direction &gt; 0), (direction &lt; 0));
            int nowHeight = currentHeight;
            int step = (int) direction;
            step *= Math.Max(1, bar.Items.Count / 2);
            int alpha = 255;
            while (nowHeight != targetHeight)
            {
               nowHeight += step;
               if (direction &gt; 0)
               {
                  alpha = (255 * (nowHeight - currentHeight)) / (targetHeight -
                   currentHeight);
                  bar.SetAnimationOffset((nowHeight - targetHeight), alpha);
               }
               else
               {
                  alpha = (255 * (nowHeight - targetHeight)) / (currentHeight -
                   targetHeight);
                  bar.SetAnimationOffset((nowHeight - currentHeight), alpha);
               }

               // Show new version
               Invalidate();
               Update();

               step = (int) (step + direction);
               direction *= 1.25;
               if (direction &gt; 0)
               {
                  if (nowHeight + step &gt; targetHeight)
                  {
                     step = targetHeight - nowHeight;
                  }
               }
               else
               {
                  if (nowHeight + step &lt; targetHeight)
                  {
                     step = targetHeight - nowHeight;
                  }
               }
            }            
            
            bar.SetAnimationInformation(false, false);
            animBitmap.Dispose();
            animBitmap = null;
         }

         bar.EnsureVisible();
         Invalidate();

      }

      /// &lt;summary&gt;
      /// Sets the scroll bar visibility and range for the current
      /// contents.
      /// &lt;/summary&gt;
      private void SetScroll()
      {
         int totalHeightWithScroll = internalBorder + bars.Count *
          internalBorder;
         if (drawingMode == ExplorerBarMode.Search)
         {
            totalHeightWithScroll += internalBorder;
         }
         int totalHeightWithoutScroll = totalHeightWithScroll;
         foreach (ExplorerBar bar in bars)
         {
            if (bar.State == ExplorerBarState.Expanded)
            {
               totalHeightWithScroll += bar.HeightWithScroll;
               totalHeightWithoutScroll += bar.HeightWithoutScroll;
            }
            else
            {
               totalHeightWithScroll += bar.TitleHeightWithScroll;
               totalHeightWithoutScroll += bar.TitleHeightWithoutScroll;
            }
         }
         if (totalHeightWithoutScroll &gt; ClientRectangle.Height)
         {
            // we need a scroll bar:
            int max = totalHeightWithScroll - ClientRectangle.Height;
            VerticalScrollBar.Visible = true;
            VerticalScrollBar.LargeChange = ClientRectangle.Height;
            VerticalScrollBar.Max = max;
            VerticalScrollBar.SmallChange = 24;
         }
         else
         {
            // no scroll bar is required:
            VerticalScrollBar.Value = 0;
            VerticalScrollBar.Visible = false;
         }
      }

      /// &lt;summary&gt;
      /// Gets an initialised &lt;see cref="ExplorerBarDrawItemParams"/&gt; object
      /// for the current bar state.
      /// &lt;/summary&gt;
      /// &lt;param name="graphics"&gt;Graphics object to render to&lt;/param&gt;
      /// &lt;returns&gt;Initialised object&lt;/returns&gt;
      private ExplorerBarDrawItemParams DrawItemParams(Graphics graphics)
      {
         int widthWithoutScroll = ClientRectangle.Width;
         int widthWithScroll = 0;
         bool scrollShowing = false;
         if (VerticalScrollBar.Visible)
         {
            widthWithScroll = widthWithoutScroll;
            widthWithoutScroll += SystemInformation.VerticalScrollBarWidth;
            scrollShowing = true;
         }
         else
         {
            widthWithScroll = widthWithoutScroll -
             SystemInformation.VerticalScrollBarWidth;
         }
         
         int top = internalBorder - VerticalScrollBar.Value;
         
         ExplorerBarDrawItemParams drawItemParams = new
          ExplorerBarDrawItemParams(
            graphics, 
            titleImageList, 
            itemImageList,
            Font, 
            widthWithoutScroll,
            widthWithScroll,
            scrollShowing,
            drawingStyle,
            drawingMode,
            (RightToLeft == RightToLeft.Yes),
            top,
            animBitmap,
            ShowFocusCues,
            ShowKeyboardCues
            );
         return drawItemParams;
      }

      /// &lt;summary&gt;
      /// Gets a preinitialised &lt;see cref="ExplorerBarMeasureItemParams"/&gt;
       object
      /// for the current bar state
      /// &lt;/summary&gt;
      /// &lt;param name="graphics"&gt;Graphics object to measure in&lt;/param&gt;
      /// &lt;returns&gt;Initialised object&lt;/returns&gt;
      private ExplorerBarMeasureItemParams MeasureItemParams(Graphics graphics)
      {
         int widthWithoutScroll = Size.Width;
         int widthWithScroll = Size.Width -
          SystemInformation.VerticalScrollBarWidth;

         ExplorerBarMeasureItemParams measureItemParams = new
          ExplorerBarMeasureItemParams(
            graphics, titleImageList, itemImageList,
            Font, widthWithoutScroll, widthWithScroll,
            drawingStyle, drawingMode);
         
         return measureItemParams;
      }

      /// &lt;summary&gt;
      /// Sets the tooltip to the specified text
      /// &lt;/summary&gt;
      /// &lt;param name="text"&gt;Tooltip text to display&lt;/param&gt;
      private void setToolTip(
         string text
         )
      {
         if (toolTip != null) 
         {
            toolTip.SetToolTip(this, text);
         }
      }

      /// &lt;summary&gt;
      /// Returns the &lt;see cref="ExplorerBar"/&gt; at the specified location, if
       any,
      /// otherwise &lt;c&gt;null&lt;/c&gt;.
      /// &lt;/summary&gt;
      /// &lt;param name="location"&gt;Location in the control to test.&lt;/param&gt;
      /// &lt;returns&gt;Bar if found, otherwise null.&lt;/returns&gt;
      private ExplorerBar HitTestBar(Point location)
      {
         ExplorerBar hitBar = null;
         foreach (ExplorerBar bar in bars)
         {
            if (bar.HitTest(location, ClientRectangle.Width,
             VerticalScrollBar.Visible))
            {
               hitBar = bar;
               break;
            }
         }
         return hitBar;
      }

      /// &lt;summary&gt;
      /// Returns the &lt;see cref="ExplorerBarItem"/&gt; at the specified location,
       if any,
      /// otherwise &lt;c&gt;null&lt;/c&gt;.
      /// &lt;/summary&gt;
      /// &lt;param name="location"&gt;Location in the control to test.&lt;/param&gt;
      /// &lt;returns&gt;Item if found, otherwise null.&lt;/returns&gt;
      private ExplorerBarItem HitTestItem(Point location)
      {
         ExplorerBarItem hitItem = null;
         foreach (ExplorerBar bar in bars)
         {
            foreach (ExplorerBarItem item in bar.Items)
            {
               if (bar.State == ExplorerBarState.Expanded)
               {
                  if (item.HitTest(location, ClientRectangle.Width,
                   VerticalScrollBar.Visible))
                  {
                     hitItem = item;
                     break;
                  }
               }
            }
            if (hitItem != null)
            {
               break;
            }
         }
         return hitItem;
      }
      #endregion
   }
}
</pre><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<noscript>
<A HREF="..\..\..\..\vb\code\vbmedia\using_gdi_plus\index.html" ><IMG SRC="..\..\..\..\res\gdiplus.png" ALT="A GDI+ Library for VB - read and write PNG, JPG, TIF and GIF files, and manipulate bitmaps quickly" WIDTH=468 HEIGHT=60 BORDER=0></A>
</noscript>

</p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\index.html">Code</a>&#160;.&#160;<a href="..\index.html">Controls</a>&#160;.&#160;<a href="article.html">.NET ExplorerBar Control</a>&#160;.&#160;<a href="explorerbar_control_source_code.html">ExplorerBar Control Source Code</a>&#160;.&#160;acclExplorerBar_acclExplorerBar.cs</p><br /><p class="nav"><a href="..\..\..\..\the_site\copyright\article.html">Copyright</a> &#169; 2004 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 18 April 2004</p></td><td></td></tr></table>
</body></html>