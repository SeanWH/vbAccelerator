<html lang="en" >
<head>
<title>vbAccelerator - Contents of code file: ListBar.cs</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="vbAccelerator - Contents of code file: ListBar.cs" /><link rel="stylesheet" href="..\..\..\..\..\res\screen.css" media="SCREEN" /><link rel="stylesheet" href="..\..\..\..\..\res\print.css" media="PRINT" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><td colspan="3">
<!-- TF 468x60 JScript HORIZ NoPop code -->
<script language=javascript><!--
document.write('<scr'+'ipt language=javascript src="http://a.tribalfusion.com/j.ad?site=VBAcceleratorcom&adSpace=ROS&size=468x60&type=horiz&pop=0&requestID='+((new Date()).getTime() % 2147483648) + Math.random()+'"></scr'+'ipt>');
//-->
</script>
<noscript>
   <a href="javascript:window.alert(&quot;http://a.tribalfusion.com/i.click?site=VBAcceleratorcom&adSpace=ROS&size=468x60&requestID=1423477941\nThis link was not retrieved.&quot;)" target=_blank>
   <img src="http://cdn5.tribalfusion.com/media/493786.gif" 
                  width=468 height=60 border=0 alt="Click Here"></a>
</noscript>
<!-- TF 468x60 JScript HORIZ NoPop code -->
</td></tr><tr class="navbar"><td><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">Controls</a>&#160;.&#160;<a href="..\index.html">ListBar</a>&#160;.&#160;<a href="article.html">.NET Outlook Style ListBar Control</a>&#160;.&#160;<a href="listbar_control_source.html">ListBar Control Source</a>&#160;.&#160;ListBar.cs</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="..\..\..\..\..\res\download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="listbar_control_binary.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />ListBar Control Binary</a> (48K)</p><p class="nav"><a href="listbar_control_demonstration.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />ListBar Control Demonstration</a> (84K)</p><p class="nav"><a href="listbar_control_documentation.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />ListBar Control Documentation</a> (168K)</p><p class="nav"><a href="listbar_control_source.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />ListBar Control Source</a> (94K)</p><br /><br /><img src="..\..\..\..\..\res\information.png" width="125" height="21" alt="Information" /><p class="nav">Zip:12934</p><p class="nav">&#160;&#160;<a href="..\..\..\..\..\..\linkto_asp\id=12934&type=zip&title=listbar_20control_20source_2ezip_5flistbar.html">Link to code Zip</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;.NET</p><p class="nav">&#160;&#160;VB.NET</p><p class="nav">&#160;&#160;C#</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="..\..\..\..\..\res\bugtrak.png" width="125" height="21" alt="BugTrak System" /><p class="nav"><a href="bugtrak.html">BugTrak</a></p><p class="nav"><a href="bugtrak.html#bugs"><img src="..\..\..\..\..\res\btbug.png" width="16" height="16" alt="Bug" />&#160;Bugs:</a> 1 / 1</p><p class="nav"><a href="bugtrak.html#issues"><img src="..\..\..\..\..\res\btissue.png" width="16" height="16" alt="Issue" />&#160;Issues:</a> 0 / 0</p><p class="nav"><a href="bugtrak.html#questions"><img src="..\..\..\..\..\res\btquestion.png" width="16" height="16" alt="Question" />&#160;Questions:</a> 0 / 1</a></p><p class="nav">Updated:22 November 2003</p>
<br /><br /><img src="..\..\..\..\..\res\updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="..\..\..\..\..\res\update.png" width="8" height="8" alt="Update" />7 Sep 2003<br />First Posted</p><br /><br /><img src="..\..\..\..\..\res\related.png" width="125" height="21" alt="Related Items" /><p class="nav"><img src="..\..\..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\..\..\..\..\vb\code\controls\listbar\outlook_listbar\article.html">vbAccelerator ListBar Control</a></p><p class="nav"><img src="..\..\..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\..\..\libraries\graphics\hls_to_rgb\article.html">Hue, Luminance and Saturation in .NET</a></p><br /><br /><img src="..\..\..\..\..\res\search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="javascript:window.alert(&quot;http://www.google.com/search\nThis link was not retrieved.&quot;)"><img src="..\..\..\..\..\..\..\www_google_com\logos\logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="..\..\..\..\..\the_site\newsite\article.html"><img src="..\..\..\..\..\res\newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>vbAccelerator - Contents of code file: ListBar.cs</h1><pre>using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
using System.Runtime.Serialization;
using System.Diagnostics;

using vbAccelerator.Components.Drawing;

namespace vbAccelerator.Components.ListBarControl
{

   #region Enumerations
   /// &lt;summary&gt;
   /// Enumeration specifying the view to use for the items within
   /// a &lt;see cref="ListBarGroup"/&gt;.
   /// &lt;/summary&gt;
   [Description("Enumeration specifying the view to use for the items within a
    group.")]
   public enum ListBarGroupView
   {
      /// &lt;summary&gt;
      /// The ListBar will display using large icons, with the text underneath.
      /// &lt;/summary&gt;
      [Description("The ListBar will display using large icons, with the text
       underneath.")]
      LargeIcons,
      /// &lt;summary&gt;
      /// The ListBar will display using small icons, with text to the left.
      /// &lt;/summary&gt;
      [Description("The ListBar will display using small icons, with text to
       the left.")]
      SmallIcons,
      /// &lt;summary&gt;
      /// The ListBar will display using large icons with no text.
      /// &lt;/summary&gt;
      [Description("The ListBar will display large icons with no text.")]
      LargeIconsOnly,
      /// &lt;summary&gt;
      /// The ListBar will display using small icons with no text.
      /// &lt;/summary&gt;
      [Description("The ListBar will display small icons with no text.")]
      SmallIconsOnly
   }

   /// &lt;summary&gt;
   /// Enumeration specifying how the &lt;see cref="ListBar"/&gt; control will draw.
   /// &lt;/summary&gt;
   [Description("Enumeration specifying the ListBar control drawing style.")]
   public enum ListBarDrawStyle
   {
      /// &lt;summary&gt;
      /// The ListBar will draw using the style of the original Office
      /// releases.
      /// &lt;/summary&gt;
      [Description("The ListBar will draw using the style of the original
       Office releases.")]
      ListBarDrawStyleNormal,
      /// &lt;summary&gt;
      /// The ListBar will draw using the Office XP style.
      /// &lt;/summary&gt;
      [Description("The ListBar will draw using the Office XP style.")]
      ListBarDrawStyleOfficeXP,
      /// &lt;summary&gt;
      /// The ListBar will draw using the Office 2003 style
      /// (not implemented yet).
      /// &lt;/summary&gt;
      [Description("The ListBar will draw using the Office 2003 style (not
       implemented yet).")]
      ListBarDrawStyleOffice2003
   }
   #endregion

   #region Event argument classes
   /// &lt;summary&gt;
   /// Provides details about an item which will undergo
   /// an edit operation.
   /// &lt;/summary&gt;
   public class ListBarLabelEditEventArgs : LabelEditEventArgs
   {
      private object labelEditObject = null;

      /// &lt;summary&gt;
      /// Returns the object for which label editing has
      /// been requested.  Can either be a &lt;see cref="ListBarItem"/&gt; or
      /// a &lt;see cref="ListBarGroup"/&gt; (or a subclass of either).
      /// &lt;/summary&gt;
      [Description("Gets the object for which label editing has been requested.
        Either a ListBarItem or a ListBarGroup (or a subclass)")]
      public object LabelEditObject
      {
         get
         {
            return this.labelEditObject;
         }
      }

      /// &lt;summary&gt;
      /// Constructs a new instance of this object
      /// given the item, label and object.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;The index of the item being edited.&lt;/param&gt;
      /// &lt;param name="label"&gt;The label of the item being edited.&lt;/param&gt;
      /// &lt;param name="labelEditObject"&gt;The object being edited.&lt;/param&gt;
      [Description("Constructs a new instance of this object.")]
      public ListBarLabelEditEventArgs(
         int item,
         string label,
         object labelEditObject
         ) : base(item, label)
      {
         this.labelEditObject = labelEditObject;
      }      
   }

   /// &lt;summary&gt;
   /// Provides event arguments for the BeforeSelectedGroupChanged event
   /// raised by the control.  This object contains the group that
   /// would be selected and provides the opportunity to cancel the 
   /// group selection.
   /// &lt;/summary&gt;
   public class BeforeGroupChangedEventArgs : EventArgs
   {
      /// &lt;summary&gt;
      /// The ListBarGroup that would be selected.
      /// &lt;/summary&gt;
      private ListBarGroup group;
      /// &lt;summary&gt;
      /// Whether to cancel the operation or not.
      /// &lt;/summary&gt;
      private bool cancel = false;

      /// &lt;summary&gt;
      /// Gets the group that will be selected.
      /// &lt;/summary&gt;
      [Description("Gets the group that will be selected.")]
      public ListBarGroup Group
      {
         get
         {
            return this.group;
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets whether the group selection should be cancelled
      /// or not. By default the group selection is not cancelled.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether the group selection should be
       cancelled.")]
      public bool Cancel
      {
         get
         {
            return this.cancel;
         }
         set
         {
            this.cancel = value;
         }
      }

      /// &lt;summary&gt;
      /// Constructs a new instance of this object.
      /// Called
      /// by the &lt;see cref="ListBar"/&gt; control before firing a 
      /// &lt;c&gt;BeforeSelectedGroupChanged&lt;/c&gt; event.
      /// &lt;/summary&gt;
      /// &lt;param name="group"&gt;The group that will be selected&lt;/param&gt;
      [Description("Constructs a new instance of this object.")]
      public BeforeGroupChangedEventArgs(
         ListBarGroup group
         )
      {
         this.group = group;
      }
   }

   /// &lt;summary&gt;
   /// This class is used with the BeforeItemClicked event and provides
   /// the item which is about to be clicked and the option to prevent
   /// the item being clicked by setting the Cancel property.
   /// &lt;/summary&gt;
   public class BeforeItemClickedEventArgs : EventArgs
   {
      /// &lt;summary&gt;
      /// The ListBarItem which is about to be clicked.
      /// &lt;/summary&gt;
      private ListBarItem item = null;
      /// &lt;summary&gt;
      /// Whether the click should be cancelled or not.
      /// &lt;/summary&gt;
      private bool cancel = false;

      /// &lt;summary&gt;
      /// Gets/sets whether the click should be cancelled or not.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether the click should be cancelled or not.")]
      public bool Cancel
      {
         get
         {
            return this.cancel;
         }
         set
         {
            this.cancel = value;
         }
      }

      /// &lt;summary&gt;
      /// Gets the ListBarItem that is about to be clicked.
      /// &lt;/summary&gt;
      [Description("Gets the ListBarItem that is about to be clicked.")]
      public ListBarItem Item
      {
         get
         {
            return this.item;
         }

      }

      /// &lt;summary&gt;
      /// Constructor for this object. Called
      /// by the &lt;see cref="ListBar"/&gt; control before firing a 
      /// &lt;see cref="BeforeItemClickedEventHandler"/&gt; event.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;The item that's about to be clicked.&lt;/param&gt;
      [Description("Constructs a new instance of this object.")]
      public BeforeItemClickedEventArgs(
         ListBarItem item
         )
      {
         this.item = item;
      }

   }

   /// &lt;summary&gt;
   /// This class is provides details of which item has been clicked
   /// and the mouse details of the click when the &lt;c&gt;ItemClicked&lt;/c&gt; event
   /// is raised from a &lt;c&gt;ListBar&lt;/c&gt;.
   /// &lt;seealso cref="ListBar.ItemClicked"/&gt;
   /// &lt;/summary&gt;
   public class ItemClickedEventArgs : ObjectClickedEventArgs
   {
      /// &lt;summary&gt;
      /// The ListBarIem that has been clicked.
      /// &lt;/summary&gt;
      private ListBarItem item = null;

      /// &lt;summary&gt;
      /// Gets the &lt;see cref="ListBarItem"/&gt; that has been clicked.
      /// &lt;/summary&gt;
      [Description("Gets the ListBarItem that has been clicked.")]
      public ListBarItem Item
      {
         get
         {
            return this.item;
         }

      }

      /// &lt;summary&gt;
      /// Constructs a new instance of this object.  Called by the &lt;see
       cref="ListBar"/&gt;
      /// control when firing an &lt;c&gt;ItemClicked&lt;/c&gt; event.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;The item that has been clicked&lt;/param&gt;
      /// &lt;param name="location"&gt;The mouse location relative to the 
      /// control for the click.&lt;/param&gt;
      /// &lt;param name="mouseButton"&gt;The mouse button used to click
      /// the item.&lt;/param&gt;
      [Description("Constructs a new instance of this object")]
      public ItemClickedEventArgs(
         ListBarItem item,
         Point location,
         MouseButtons mouseButton
         ) : base(location, mouseButton)
      {
         this.item = item;
      }

   }

   /// &lt;summary&gt;
   /// This class is provides details of which item has been clicked
   /// and the mouse details of the click when the &lt;c&gt;GroupClicked&lt;/c&gt; event
   /// is raised from a &lt;see cref="ListBar" /&gt; control.
   /// &lt;/summary&gt;
   public class GroupClickedEventArgs : ObjectClickedEventArgs
   {
      /// &lt;summary&gt;
      /// The ListBarGroup that has been clicked.
      /// &lt;/summary&gt;
      private ListBarGroup group = null;

      /// &lt;summary&gt;
      /// Gets the &lt;see cref="ListBarGroup"/&gt; that has been clicked.
      /// &lt;/summary&gt;
      [Description("Gets the ListBarGroup that has been clicked.")]
      public ListBarGroup Group
      {
         get
         {
            return this.group;
         }

      }

      /// &lt;summary&gt;
      /// Constructs a new instance of this object.  Called by the &lt;see
       cref="ListBar"/&gt;
      /// control when firing a &lt;c&gt;GroupClicked&lt;/c&gt; event.
      /// &lt;/summary&gt;
      /// &lt;param name="group"&gt;The &lt;see cref="ListBarGroup"/&gt; that has been
       clicked&lt;/param&gt;
      /// &lt;param name="location"&gt;The mouse location relative to the 
      /// control for the click.&lt;/param&gt;
      /// &lt;param name="mouseButton"&gt;The mouse button used to click
      /// the item.&lt;/param&gt;
      [Description("Constructs a new instance of this object.")]
      public GroupClickedEventArgs(
         ListBarGroup group,
         Point location,
         MouseButtons mouseButton
         ) : base(location, mouseButton)
      {
         this.group = group;
      }

   }

   /// &lt;summary&gt;
   /// An abstract class used as the bases for the &lt;c&gt;ItemClicked&lt;/c&gt;
   /// and &lt;c&gt;GroupClicked&lt;/c&gt; events of the &lt;see cref="ListBar"/&gt; control.
   /// This class stores details of the mouse location and button.
   /// &lt;/summary&gt;
   public abstract class ObjectClickedEventArgs : EventArgs
   {
      /// &lt;summary&gt;
      /// The location of the mouse when the item was clicked.
      /// &lt;/summary&gt;
      private Point location;
      /// &lt;summary&gt;
      /// The mouse button that was used.
      /// &lt;/summary&gt;
      private MouseButtons mouseButton = MouseButtons.Left;

      /// &lt;summary&gt;
      /// The Location of the mouse, relative to the control,
      /// when the item was clicked.
      /// &lt;/summary&gt;
      [Description("The location of the mouse relative to the control when the
       item was clicked.")]
      public Point Location
      {
         get
         {
            return location;
         }
      }

      
      /// &lt;summary&gt;
      /// The MouseButton used to click the item.
      /// &lt;/summary&gt;
      [Description("The mouse button used to click this item.")]
      public MouseButtons MouseButton
      {
         get
         {
            return this.mouseButton;
         }
      }

      /// &lt;summary&gt;
      /// When used in a subclass, constructs a new instance of the class with
       the specified
      /// mouse location and button.
      /// &lt;/summary&gt;
      /// &lt;param name="location"&gt;The location of the mouse.&lt;/param&gt;
      /// &lt;param name="mouseButton"&gt;The button which was pressed.&lt;/param&gt;
      [Description("When used in a subclass, constructs a new instance of this
       class.")]
      public ObjectClickedEventArgs(
         Point location,
         MouseButtons mouseButton
         )
      {
         this.location = location;
         this.mouseButton = mouseButton;
      }

   }
   #endregion 

   #region Event delegates
   /// &lt;summary&gt;
   /// Represents the method that handles the BeforeSelectedGroupChanged event
   /// of a ListBar control.
   /// &lt;/summary&gt;
   public delegate void BeforeGroupChangedEventHandler(
      object sender, 
      BeforeGroupChangedEventArgs e);
   /// &lt;summary&gt;
   /// Represents the method that handles the BeforeItemClicked event
   /// of a ListBar control.
   /// &lt;/summary&gt;
   public delegate void BeforeItemClickedEventHandler(
      object sender, 
      BeforeItemClickedEventArgs e);
   /// &lt;summary&gt;
   /// Represents the method that handles the ItemClicked event of a
   /// ListBar control.
   /// &lt;/summary&gt;
   public delegate void ItemClickedEventHandler(
      object sender,
      ItemClickedEventArgs e);
   /// &lt;summary&gt;
   /// Represents the method that handles the GroupClicked event of a
   /// ListBar control.
   /// &lt;/summary&gt;
   public delegate void GroupClickedEventHandler(
      object sender,
      GroupClickedEventArgs e);
   
   /// &lt;summary&gt;
   /// Represents the method that handles the BeforeLabelEdit and AfterLabelEdit
   /// events of a ListBar control.
   /// &lt;/summary&gt;
   public delegate void ListBarLabelEditEventHandler(
      object sender,
      ListBarLabelEditEventArgs e);   
   #endregion
   
   #region ListBar Control class
   /// &lt;summary&gt;
   /// An implementation of a Microsoft Outlook Style ListBar control.
   /// The control provides all the features needed to implement a replica
   /// of the Outlook style control and is also designed to allow the same
   /// functionality to be used in overriden controls in which the
   /// individual sizing and appearance of each of the UI components can be
   /// customised.
   /// 
   /// The &lt;c&gt;ListBar&lt;/c&gt; control is modelled as an extension to
   /// the &lt;c&gt;System.Windows.Forms.UserControl&lt;/c&gt; class.  Bars
   /// are configured using &lt;see cref="ListBarGroup" /&gt; objects which are
   /// collected in the &lt;see cref="ListBarGroupCollection" /&gt; object
   /// accessible through the control's &lt;see cref="Groups" /&gt; accessor.
   /// Each &lt;see cref="ListBarGroup" /&gt; in turn contains a 
   /// &lt;see cref="ListBarItemCollection" /&gt; of &lt;see cref="ListBarItem" /&gt;
    objects 
   /// which represent the buttons within a group.
   /// &lt;/summary&gt;   
   ///
   /// &lt;remarks&gt;
   /// Copyright &amp;#169; 2003 Steve McMahon for vbAccelerator.com.
   /// vbAccelerator is a Trade Mark of vbAccelerator Ltd.  All Rights
   /// Reserved.  Please visit http://vbaccelerator.com/ for more
   /// on this and other VB and .NET Framework code.  Comments to
   /// mailto:steve@vbaccelerator.com.
   /// &lt;/remarks&gt;
   /// 
   public class ListBar : System.Windows.Forms.UserControl
   {
   
      #region Member Variables
      /// &lt;summary&gt;
      /// Reference to the collection of groups contained within the ListBar
       control.
      /// &lt;/summary&gt;
      private ListBarGroupCollection groups = null;
      /// &lt;summary&gt;
      /// Reference to an external ToolTip object.
      /// &lt;/summary&gt;
      private ToolTip toolTip = null;
      /// &lt;summary&gt;
      /// Reference to an external Image List for drawing the large icon view.
      /// &lt;/summary&gt;
      private ImageList largeImageList = null;
      /// &lt;summary&gt;
      /// Reference to an external Image List for drawing the small icon view.
      /// &lt;/summary&gt;
      private ImageList smallImageList = null;
      /// &lt;summary&gt;
      /// A timer for controlling scrolling when the scroll buttons are held
      /// down.
      /// &lt;/summary&gt;
      private Timer buttonPressed = new Timer();
      /// &lt;summary&gt;
      /// Contains a reference to the active scroll button when one is pressed
      /// and the mouse is over it.
      /// &lt;/summary&gt;
      private ListBarScrollButton activeButton = null;
      /// &lt;summary&gt;
      /// The last time a scroll occurred during a drag-drop operation.  Used
      /// to control the speed of scrolling during drag-drop.
      /// &lt;/summary&gt;
      private DateTime lastScrollTime = DateTime.Now;
      /// &lt;summary&gt;
      /// Drawing style fo the control.
      /// &lt;/summary&gt;
      private ListBarDrawStyle drawStyle =
       ListBarDrawStyle.ListBarDrawStyleOfficeXP;
      /// &lt;summary&gt;
      /// Last width the control was drawn at.  Used to control resizing.
      /// &lt;/summary&gt;
      private int lastWidth = 0;
      /// &lt;summary&gt;
      /// Last height the control was drawn at.  Used to control resizing.
      /// &lt;/summary&gt;
      private int lastHeight = 0;
      /// &lt;summary&gt;
      /// Flag to control whether redrawing occurs or not
      /// during updating:
      /// &lt;/summary&gt;
      private bool redraw = true;
      /// &lt;summary&gt;
      /// Up scroll button reference.
      /// &lt;/summary&gt;
      protected ListBarScrollButton btnUp;
      /// &lt;summary&gt;
      /// Down scroll buttons reference.
      /// &lt;/summary&gt;
      protected ListBarScrollButton btnDown;
      /// &lt;summary&gt;
      /// The rectangle containing the "ListView" portion of the control.
      /// &lt;/summary&gt;
      private Rectangle rcListView;
      /// &lt;summary&gt;
      /// The object that the mouse is currently over, if any.
      /// &lt;/summary&gt;
      private IMouseObject mouseTrack = null;
      /// &lt;summary&gt;
      /// The object that the mouse is currently down on, if any.
      /// &lt;/summary&gt;
      private IMouseObject mouseDown = null;
      /// &lt;summary&gt;
      /// Whether items are selected on MouseDown or
      /// MouseUp.
      /// &lt;/summary&gt;
      private bool selectOnMouseDown = false;
      /// &lt;summary&gt;
      /// Whether items can be dragged or not
      /// &lt;/summary&gt;
      private bool allowDragItems = true;
      /// &lt;summary&gt;
      /// Whether groups can be dragged or not
      /// &lt;/summary&gt;
      private bool allowDragGroups = true;
      /// &lt;summary&gt;
      /// During drag-drop, the insert point, if any.
      /// &lt;/summary&gt;
      private ListBarDragDropInsertPoint dragInsertPoint = null;
      /// &lt;summary&gt;
      /// The object that was last hovered over during
      /// drag-drop, if any:
      /// &lt;/summary&gt;
      private IMouseObject dragHoverOver = null;
      /// &lt;summary&gt;
      /// The time at which hovering started over the object
      /// which is currently being hovered over:
      /// &lt;/summary&gt;
      private DateTime dragHoverOverStartTime = DateTime.Now;
      /// &lt;summary&gt;
      /// The ListBarItem currently being edited, if any
      /// &lt;/summary&gt;
      private ListBarItem editItem = null;
      /// &lt;summary&gt;
      /// The ListBarGroup currently being edited, if any
      /// &lt;/summary&gt;
      private ListBarGroup editGroup = null;
      /// &lt;summary&gt;
      /// Are we scrolling a new group into view or not?
      /// &lt;/summary&gt;
      private bool scrollingGroup = false;
      /// &lt;summary&gt;
      /// The index of the group which is currently selected
      /// when scrolling a new group into view:
      /// &lt;/summary&gt;
      protected int indexCurrent = -1;
      /// &lt;summary&gt;
      /// The index of the newly selected group which will replace
      /// the selected index when scrolling a new group into view:
      /// &lt;/summary&gt;
      protected int indexNew = -1;
      /// &lt;summary&gt;
      /// The Text Box used for editing an item's caption.
      /// &lt;/summary&gt;
      private System.Windows.Forms.TextBox txtEdit;
      /// &lt;summary&gt;
      /// A class to determine when the TextBox used for
      /// editing should be cancelled:
      /// &lt;/summary&gt;
      private PopupCancelNotifier popupCancel;

      /// &lt;summary&gt; 
      /// Required designer variable.
      /// &lt;/summary&gt;
      private System.ComponentModel.Container components = null;

      #endregion

      #region Events
      /// &lt;summary&gt;
      /// Raised before the selected group in the ListBar control is changed.
       Allows
      /// the group selection to be cancelled.
      /// &lt;/summary&gt;
      [Description("Raised before the selected group in the ListBar control is
       changed.")]
      public event BeforeGroupChangedEventHandler BeforeSelectedGroupChanged;
      /// &lt;summary&gt;
      /// Raised when the selected group in a ListBar control has been
      /// changed.
      /// &lt;/summary&gt;
      [Description("Raised once the selected group in the ListBar control has
       been changed.")]
      public event System.EventHandler SelectedGroupChanged;
      /// &lt;summary&gt;
      /// Raised before an item in a ListBar control is clicked.  Allows
      /// the item selection to be cancelled.
      /// &lt;/summary&gt;
      [Description("Raised before an item in the ListBar control is clicked.")]
      public event BeforeItemClickedEventHandler BeforeItemClicked;
      /// &lt;summary&gt;
      /// Raised when an item has been clicked in the ListBar control.
      /// &lt;/summary&gt;
      [Description("Raised once an item in the ListBar control has been
       clicked.")]
      public event ItemClickedEventHandler ItemClicked;
      /// &lt;summary&gt;
      /// Raised when an item has been double clicked in the ListBar control.
      /// &lt;/summary&gt;
      [Description("Raised when an item has been double clicked in the ListBar
       control.")]
      public event ItemClickedEventHandler ItemDoubleClicked;
      /// &lt;summary&gt;
      /// Raised when a group has been clicked in the ListBar control.
      /// &lt;/summary&gt;
      [Description("Raised when a group has been clicked in the ListBar
       control.")]
      public event GroupClickedEventHandler GroupClicked;
      /// &lt;summary&gt;
      /// Raised before an item's label is about to be edited in the ListBar
      /// control.  Allows the label edit to be cancelled.
      /// &lt;/summary&gt;
      [Description("Raised before an item's label is about to be edited in the
       ListBar control.")]
      public event ListBarLabelEditEventHandler BeforeLabelEdit;
      /// &lt;summary&gt;
      /// Raised after an item's label has been edited in the ListBar control.
      /// Allows the new caption to be checked and the edit cancelled.
      /// &lt;/summary&gt;
      [Description("Raised after an item's label has been edited but before the
       change is committed.")]
      public event ListBarLabelEditEventHandler AfterLabelEdit;
      #endregion

      #region Constructor and Dispose/Finalise
      /// &lt;summary&gt;
      /// Creates a new instance of a ListBar control.
      /// &lt;/summary&gt;
      public ListBar()
      {
         // This call is required by the Windows.Forms Form Designer.
         InitializeComponent();

         // Set up the control:
         this.SetStyle(
            ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint |
             ControlStyles.DoubleBuffer |
            ControlStyles.SupportsTransparentBackColor, 
            true);

         // Initialisation:
         groups = CreateListBarGroupCollection();
         btnUp =
          CreateListBarScrollButton(ListBarScrollButton.ListBarScrollButtonType.
         Up);
         btnDown =
          CreateListBarScrollButton(ListBarScrollButton.ListBarScrollButtonType.
         Down);
         
         // Scroll timer:
         buttonPressed.Interval = 350;
         buttonPressed.Enabled = false;
         buttonPressed.Tick += new EventHandler(buttonPressed_Tick);

         // Text box:
         txtEdit.KeyDown += new KeyEventHandler(txtEdit_KeyDown);
         
         popupCancel = new PopupCancelNotifier();
         popupCancel.PopupCancel += new
          PopupCancelEventHandler(popupCancel_PopupCancel);

      }

      /// &lt;summary&gt; 
      /// Clean up any resources being used.
      /// &lt;/summary&gt;
      protected override void Dispose( bool disposing )
      {
         if( disposing )
         {
            if(components != null)
            {
               components.Dispose();
            }
         }
         base.Dispose( disposing );
      }
      #endregion

      #region Responding to events
      /// &lt;summary&gt;
      /// Controls scrolling when the mouse is over and down on a scroll
      /// bar button.
      /// &lt;/summary&gt;
      /// &lt;param name="sender"&gt;The object which raised this event.&lt;/param&gt;
      /// &lt;param name="e"&gt;Arguments associated with this event.&lt;/param&gt;
      private void buttonPressed_Tick(object sender, System.EventArgs e)
      {
         // check if the mouse is still over a scroll button
         // that's been pressed:
         if (activeButton != null)
         {
            // shorten the interval for the next scroll down
            // to 75ms:
            buttonPressed.Interval = 75;
            // Check if mouse in button:
            Point pos = Cursor.Position;
            pos = this.PointToClient(pos);
            if (activeButton.HitTest(pos))
            {
               // perform the scrolling:
               Scroll(activeButton, true);
            }            
         }
      }

      /// &lt;summary&gt;
      /// Scroll the control for the selected button.
      /// &lt;/summary&gt;
      /// &lt;param name="button"&gt;Button to scroll for.&lt;/param&gt;
      /// &lt;param name="fromTimer"&gt;Whether request to scroll from a 
      /// scroll button timer event.&lt;/param&gt;
      private void Scroll(ListBarScrollButton button, bool fromTimer)
      {
         int direction = 
            (button.ButtonType ==
             ListBarScrollButton.ListBarScrollButtonType.Up ? 1 : -1);
         Scroll(direction, fromTimer);
      }

      /// &lt;summary&gt;
      /// Scroll the control for the selected button.
      /// &lt;/summary&gt;
      /// &lt;param name="button"&gt;Button to scroll for.&lt;/param&gt;
      private void Scroll(ListBarScrollButton button)
      {
         Scroll(button, false);
      }

      
      /// &lt;summary&gt;
      /// Scroll the control in the specified direction.
      /// &lt;/summary&gt;
      /// &lt;param name="direction"&gt;The direction to move in.  Note that this
       follows
      /// the direction of movement of an item: +1 scrolls up, -1 scrolls
       down.&lt;/param&gt;
      private void Scroll(int direction)
      {
         Scroll(direction, false);
      }

      /// &lt;summary&gt;
      /// Scroll the control in the specified direction.
      /// &lt;/summary&gt;
      /// &lt;param name="direction"&gt;The direction to move in.  Note that this
       follows
      /// the direction of movement of an item: +1 scrolls up, -1 scrolls
       down.&lt;/param&gt;
      /// &lt;param name="fromTimer"&gt;Whether request to scroll from a 
      /// scroll button timer event.&lt;/param&gt;
      private void Scroll(int direction, bool fromTimer)
      {
         // get the distance we must scroll to move one entire
         // item:
         ListBarGroup selGroup = SelectedGroup;
         int endScrollOffset = selGroup.ScrollOffset + 
            (direction * selGroup.Items[0].Height);
         if (endScrollOffset &gt; 0)
         {
            endScrollOffset = 0;
         }

         // Get the invalidation rectangle:
         Rectangle rcInvalid = new Rectangle(
            new Point(1, selGroup.ButtonLocation.X + selGroup.ButtonHeight),
            new Size(this.Width - 2, 
               ((groups.IndexOf(selGroup) == groups.Count - 1) ? 
                  this.Height - (selGroup.ButtonLocation.Y +
                   selGroup.ButtonHeight) :
                  groups[groups.IndexOf(selGroup) + 1].ButtonLocation.Y)));    
                       

         // Starting from the current point, scroll the selected
         // bar to the new point in ever increasing steps:
         int step = direction;
         if (fromTimer)
         {
            step *= selGroup.Items[0].Height / 4;
         }
         while (selGroup.ScrollOffset != endScrollOffset)
         {
            // determine the new scroll offset:
            int newOffset = selGroup.ScrollOffset + step;
            if (direction &lt; 0)
            {
               if (newOffset &lt; endScrollOffset)
               {
                  newOffset = endScrollOffset;
               }
            }
            else
            {
               if (newOffset &gt; endScrollOffset)
               {
                  newOffset = endScrollOffset;
               }
            }
            selGroup.ScrollOffset = newOffset;
            
            // refresh the display:
            Invalidate();            
            this.Update();
            
            // Make the next step larger.
            step *= 2;
         }

         // Ensure that everything is shown in the right place
         DoResize();         
      }

      /// &lt;summary&gt;
      /// Raises the Resize event and performs internal
      /// sizing of the objects in the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;&lt;/param&gt;
      protected override void OnResize(EventArgs e)
      {
         DoResize();
         base.OnResize(e);
      }

      /// &lt;summary&gt;
      /// Raises the SizeChanged event for this control
      /// and internally sizes the display.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Event arguments associated with this
      /// event.&lt;/param&gt;
      protected override void OnSizeChanged(EventArgs e)
      {         
         DoResize();
         this.Invalidate();

         base.OnSizeChanged(e);
      }

      private ListBarGroup ensureSelection()
      {
         ListBarGroup selectedGroup = SelectedGroup;         
         
         if ((selectedGroup == null)  || (!selectedGroup.Visible))
         {
            selectedGroup = null;
            if (groups.Count &gt; 0)
            {
               for (int i = 0; i &lt; groups.Count; i++)
               {
                  if ((groups[i].Visible) &amp;&amp; (selectedGroup == null))
                  {
                     groups[i].Selected = true;
                     selectedGroup = groups[i];
                  }
                  else
                  {
                     if (groups[i].Selected)
                     {
                        groups[i].Selected = false;
                     }
                  }
               }
            }
         }
         return selectedGroup;
      }

      /// &lt;summary&gt;
      /// Called by the control's internal sizing mechanism.
      /// Returns the client size excluding the border of the
      /// control.
      /// &lt;/summary&gt;
      /// &lt;returns&gt;A &lt;c&gt;Rectangle&lt;/c&gt; providing the area to 
      /// draw the control into.&lt;/returns&gt;
      protected virtual Rectangle GetClientRectangleExcludingBorder()
      {
         Rectangle rcClient = new Rectangle(
            this.ClientRectangle.Left + 1,
            this.ClientRectangle.Top + 1,
            this.ClientRectangle.Width - 2,
            this.ClientRectangle.Height - 2);
         return rcClient;
      }

      /// &lt;summary&gt;
      /// Called by the control's internal sizing mechanism.
      /// Returns the rectangle for a scroll button.
      /// &lt;/summary&gt;
      /// &lt;param name="buttonType"&gt;The scroll button to
      /// get the rectangle for.&lt;/param&gt;
      /// &lt;param name="selectedGroup"&gt;The Selected Group in the control.&lt;/param&gt;
      /// &lt;param name="internalGroupHeight"&gt;The internal height of the
      /// selected group&lt;/param&gt;
      /// &lt;returns&gt;The Rectangle for the scroll button.&lt;/returns&gt;
      protected virtual Rectangle GetScrollButtonRectangle(
         ListBarScrollButton.ListBarScrollButtonType buttonType,
         ListBarGroup selectedGroup,
         int internalGroupHeight
         )
      {
         Rectangle buttonRect;
         if (buttonType == ListBarScrollButton.ListBarScrollButtonType.Up)
         {
            buttonRect = new Rectangle(
               new Point(
                  ((this.RightToLeft == RightToLeft.Yes) ? 
                  2 : 
                  this.Width - 2 - btnUp.Rectangle.Width),
               selectedGroup.ButtonLocation.Y + selectedGroup.ButtonHeight + 2),
               btnUp.Rectangle.Size);
         }
         else
         {            
            buttonRect = new Rectangle(
               new Point(
                  ((this.RightToLeft == RightToLeft.Yes) ? 
                  2 : 
               this.Width - 2 - btnUp.Rectangle.Width),
               selectedGroup.ButtonLocation.Y + selectedGroup.ButtonHeight + 
               internalGroupHeight - 2 - btnDown.Rectangle.Height),
               btnDown.Rectangle.Size);
         }
         return buttonRect;

      }
      

      private void DoResize()
      {
         if (this.redraw)
         {
            if (this.groups.Count &gt; 0)
            {
               ListBarGroup selectedGroup = ensureSelection();
               if (selectedGroup != null)
               {                  
                  Rectangle rcClient = GetClientRectangleExcludingBorder();
                  rcListView = new Rectangle(rcClient.Location, rcClient.Size);

                  int lastVisibleGroup = 0;
                  int firstVisibleGroup = groups.Count - 1;
                  int nextVisibleGroup = firstVisibleGroup;

                  for (int i = 0; i &lt;= groups.IndexOf(selectedGroup); i++)
                  {
                     ListBarGroup group = groups[i];
                  
                     if (group.Visible)
                     {
                        int buttonWidth = GetGroupButtonWidth(group);
                        group.SetLocationAndWidth(
                           new Point(rcClient.Left, rcListView.Top), 
                           buttonWidth);
                        rcListView.Y += group.ButtonHeight;
                        rcListView.Height -= group.ButtonHeight;

                        if (i &gt; lastVisibleGroup)
                        {
                           lastVisibleGroup = i;
                        }
                        if (i &lt; firstVisibleGroup)
                        {
                           firstVisibleGroup = i;
                        }
                     }
                  }

                  int bottom = rcClient.Bottom;
                  for (int i = groups.Count - 1; i &gt;
                   groups.IndexOf(selectedGroup); i--)
                  {
                     ListBarGroup group = groups[i];               
                     if (group.Visible)
                     {
                        int buttonWidth = GetGroupButtonWidth(group);
                        bottom -= group.ButtonHeight;
                        rcListView.Height -= group.ButtonHeight;
                        group.SetLocationAndWidth(
                           new Point(rcClient.Left, bottom), 
                           buttonWidth);

                        if (i &gt; lastVisibleGroup)
                        {
                           lastVisibleGroup = i;
                        }
                        if (i &lt; nextVisibleGroup)
                        {
                           nextVisibleGroup = i;
                        }
                     }
                  }            

                  int size = selectedGroup.Items.Height;            
                  int height = selectedGroup.ButtonLocation.Y +
                   selectedGroup.ButtonHeight;
                  if (groups.IndexOf(selectedGroup) == lastVisibleGroup)
                  {
                     height = this.ClientRectangle.Height - height;
                  }
                  else
                  {
                     height = groups[nextVisibleGroup].ButtonLocation.Y - 
                        height;
                  }

                  bool needUp = false;
                  bool needDown = false;

                  needUp = (selectedGroup.ScrollOffset &lt; 0);
                  needDown = ((size + selectedGroup.ScrollOffset) &gt; height);

                  Rectangle btnUpRect = GetScrollButtonRectangle(
                     ListBarScrollButton.ListBarScrollButtonType.Up,
                     selectedGroup,
                     height);
                  btnUp.SetRectangle(btnUpRect);
                  btnUp.Visible = needUp;
                  if (!needUp)
                  {
                     if (this.activeButton != null)
                     {
                        if (this.activeButton.Equals(btnUp))
                        {
                           buttonPressed.Enabled = false;
                        }
                     }
                  }

                  Rectangle btnDownRect = GetScrollButtonRectangle(
                     ListBarScrollButton.ListBarScrollButtonType.Down,
                     selectedGroup, height);                     
                  btnDown.SetRectangle(btnDownRect);
                  btnDown.Visible = needDown;
                  if (!needDown)
                  {
                     if (this.activeButton != null)
                     {
                        if (this.activeButton.Equals(btnDown))
                        {
                           buttonPressed.Enabled = false;
                        }
                     }
                  }
               }
               else
               {
                  btnUp.Visible = false;
                  btnDown.Visible = false;
               }
                        
               if (this.Width != lastWidth)
               {
                  lastWidth = this.Width;
               }

               if (this.Height != lastHeight)
               {
                  lastHeight = this.Height;
               }

            }
         }
      }

      /// &lt;summary&gt;
      /// Raises the Paint event and performs internal drawing of the
      /// control.   
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;A PaintEventArgs object with details about the 
      /// paint event that must be performed.&lt;/param&gt;
      protected override void OnPaint ( System.Windows.Forms.PaintEventArgs e )
      {
         if (scrollingGroup)
         {
            RenderScrollNewGroup(e);
         }
         else
         {
            Render(e);
         }
         base.OnPaint(e);
      }

      /// &lt;summary&gt;
      /// Raises the double click event and performs internal double-click
      /// processing for the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;&lt;see cref="EventArgs"/&gt; associated with this
      /// double-click event.&lt;/param&gt;
      protected override void OnDoubleClick( EventArgs e)
      {
         base.OnDoubleClick(e);
         Point pt = this.PointToClient(Cursor.Position);
         
         IMouseObject obj = HitTest(pt, false);
         if (obj != null)
         {
            if (typeof(ListBarItem).IsAssignableFrom(obj.GetType()))
            {
               ListBarItem item = (ListBarItem)obj;
               MouseButtons button = MouseButtons.Left; // TODO should use
                GetAsyncKeyState or whatever the Framework equivalent is
               ItemClickedEventArgs ice = new ItemClickedEventArgs(
                  item, pt, button);
               OnItemDoubleClicked(ice);
            }
         }
      }

      /// &lt;summary&gt;
      /// Raises the &lt;see cref="ItemDoubleClicked"/&gt; event for an item.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;The &lt;see cref="ItemClickedEventArgs"/&gt; details
      /// associated with the double click event.&lt;/param&gt;
      protected virtual void OnItemDoubleClicked(ItemClickedEventArgs e)
      {
         if (this.ItemDoubleClicked != null)
         {
            this.ItemDoubleClicked(this, e);
         }
      }

      /// &lt;summary&gt;
      /// Raises the MouseDown event and performs internal mouse-down
      /// processing for the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;A MouseEventArgs object with details about the
      /// mouse event that has occurred.&lt;/param&gt;
      protected override void OnMouseDown( System.Windows.Forms.MouseEventArgs
       e)
      {
         base.OnMouseDown(e);
         
         if (e.Button == MouseButtons.Left)
         {
            if (mouseTrack != null)
            {
               mouseDown = mouseTrack;
               mouseDown.MouseDown = true;
               mouseDown.MouseDownPoint = new Point(e.X, e.Y);

               // Check whether a scroll button has been pressed.
               // If it has, then start a timer to auto-scroll
               // more.
               if
                (typeof(ListBarScrollButton).IsAssignableFrom(mouseTrack.GetType
               ()))
               {
                  // Set the active scrolling button:
                  activeButton = (ListBarScrollButton)mouseTrack;
                  // perform the initial scroll:
                  Scroll(activeButton);
                  // initialise the timer:
                  buttonPressed.Interval = 350;
                  buttonPressed.Enabled = true;
               }
               else if
                (typeof(ListBarItem).IsAssignableFrom(mouseTrack.GetType()))
               {
                  if (this.selectOnMouseDown)
                  {
                     MouseSelectItem((ListBarItem)mouseTrack, e);
                  }
               }

               // Redraw the control:
               Invalidate();
            }
         }
         
      }

      /// &lt;summary&gt;
      /// Raises the MouseMove event and performs mouse move processing
      /// for the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;A MouseEventArgs object describing the mouse
      /// move event that has occurred.&lt;/param&gt;
      protected override void OnMouseMove( System.Windows.Forms.MouseEventArgs
       e)
      {
         base.OnMouseMove(e);

         // no motion during item editing
         if (editItem != null)
         {
            return;
         }
      
         // detect if the mouse is over anything:
         IMouseObject newMouseOver = HitTest(new Point(e.X, e.Y));

         if (newMouseOver == null) 
         {
            if (mouseTrack != null)
            {
               mouseTrack.MouseOver = false;
               mouseTrack = null;
               this.Cursor = Cursors.Default;
               Invalidate();
            }
            if (this.toolTip != null)
            {
               this.toolTip.SetToolTip(this, "");
            }
         }
         else
         {
            bool noChange = false;
            if (mouseTrack != null)
            {
               if (mouseTrack == newMouseOver)
               {
                  // We're not tracking a new item.
                  noChange = true;

                  // However, if we mouse-downed on an item, then we 
                  // should check if the new mouse position is sufficiently
                  // far from the original position that a drag operation
                  // is in order:
                  if (this.allowDragItems)
                  {
                     if
                      (typeof(ListBarItem).IsAssignableFrom(mouseTrack.GetType()
                     ))
                     {
                        if (mouseTrack.MouseDown)
                        {
                           int hysteresis = (SelectedGroup.View ==
                            ListBarGroupView.LargeIcons ? 4 : 2);
                           if ((Math.Abs(mouseTrack.MouseDownPoint.X - e.X) &gt;
                            hysteresis) ||
                              (Math.Abs(mouseTrack.MouseDownPoint.Y - e.Y) &gt;
                               hysteresis))
                           {
                              // time to start dragging:
                              ListBarItem dragItem = (ListBarItem)mouseTrack;
                              this.DoDragDrop(dragItem, DragDropEffects.Move);
                              InternalDragDropComplete(dragItem, true);
                              EnsureItemVisible(dragItem);
                              return;
                           }
                        }
                     }
                  }
                  if (this.allowDragGroups)
                  {
                     if
                      (typeof(ListBarGroup).IsAssignableFrom(mouseTrack.GetType(
                     )))
                     {
                        if (mouseTrack.MouseDown)
                        {
                           if ((Math.Abs(mouseTrack.MouseDownPoint.X - e.X) &gt;
                            4) ||
                              (Math.Abs(mouseTrack.MouseDownPoint.Y - e.Y) &gt; 4))
                           {
                              // time to start dragging:
                              ListBarGroup dragGroup = (ListBarGroup)mouseTrack;
                              this.DoDragDrop(dragGroup, DragDropEffects.Move);
                              //InternalDragDropComplete(dragGroup);
                              dragGroup.MouseOver = false;
                              dragGroup.MouseDown = false;
                              return;
                           }
                           
                        }
                     }
                  }
               }
               else
               {
                  mouseTrack.MouseOver = false;
               }
            }
            if (!noChange)
            {
               mouseTrack = newMouseOver;
               if (this.toolTip != null)
               {
                  this.toolTip.SetToolTip(this, mouseTrack.ToolTipText);
               }
               mouseTrack.MouseOver = true;
               if (typeof(ListBarGroup).IsAssignableFrom(mouseTrack.GetType()))
               {
                  this.Cursor = Cursors.Hand;
               }
               else
               {
                  this.Cursor = Cursors.Default;
               }
               Invalidate();
            }
         }
      }

      
      /// &lt;summary&gt;
      /// Raises the MouseUp event and performs mouse up processing
      /// for the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;A MouseEventArgs object describing the mouse
      /// move event that has occurred.&lt;/param&gt;
      protected override void OnMouseUp( System.Windows.Forms.MouseEventArgs e)
      {
         base.OnMouseUp(e);
         
         if (e.Button == MouseButtons.Left)
         {
            if (mouseTrack != null)
            {
               if (mouseTrack.Equals(mouseDown))
               {

                  if
                   (typeof(ListBarGroup).IsAssignableFrom(mouseTrack.GetType()))
                  {
                     BeforeGroupChangedEventArgs bgc = new
                      BeforeGroupChangedEventArgs(
                        (ListBarGroup)mouseTrack);
                     OnBeforeGroupChanged(ref bgc);
                     if (!bgc.Cancel)
                     {
                        // group clicked.  Select the new group:
                        SelectGroup((ListBarGroup)mouseTrack);
                        OnSelectedGroupChanged(new System.EventArgs());
                        GroupClickedEventArgs gce = new GroupClickedEventArgs(
                           (ListBarGroup)mouseTrack,
                           new Point(e.X, e.Y),
                           e.Button);
                        OnGroupClicked(gce);
                     }
                  }
                  else if
                   (typeof(ListBarScrollButton).IsAssignableFrom(mouseTrack.GetT
                  ype()))
                  {
                     // don't need to do anything here, except be sure
                     // we reset the active scroll button &amp; timer later
                  }
                  else
                  {
                     if (activeButton == null)
                     {
                        if (!this.selectOnMouseDown)
                        {
                           MouseSelectItem((ListBarItem)mouseTrack, e);
                        }
                     }
                  }
               }
            }
            
            // no more scrolling
            activeButton = null;
            buttonPressed.Enabled = false;
   
            if (mouseDown != null)
            {
               mouseDown.MouseDown = false;
               mouseDown.MouseOver = false;
            }
            if (mouseTrack != null)
            {
               mouseTrack.MouseOver = false;
            }
            Invalidate();
         }
      
         else if (e.Button == MouseButtons.Right)
         {
            if (mouseTrack != null)
            {
               // Right click?
               if (typeof(ListBarGroup).IsAssignableFrom(mouseTrack.GetType()))
               {
                  GroupClickedEventArgs gce = new GroupClickedEventArgs(
                     (ListBarGroup)mouseTrack,
                     new Point(e.X, e.Y),
                     e.Button);
                  OnGroupClicked(gce);
               }
               else if
                (typeof(ListBarItem).IsAssignableFrom(mouseTrack.GetType()))
               {
                  ItemClickedEventArgs ic = new ItemClickedEventArgs(
                     (ListBarItem)mouseTrack,
                     new Point(e.X, e.Y),
                     e.Button );
                  OnItemClicked(ic);
               }
               else
               {
                  // no action currently
               }
            }
            else
            {
               // group right click:
               GroupClickedEventArgs gce = new GroupClickedEventArgs(
                  SelectedGroup,
                  new Point(e.X, e.Y),
                  e.Button);
               OnGroupClicked(gce);
            }
         }
      }

      /// &lt;summary&gt;
      /// Raises the MouseLeave event and performs internal mouse
      /// track processing for the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;Event arguments associated with this event.&lt;/param&gt;
      protected override void OnMouseLeave( System.EventArgs e)
      {
         base.OnMouseLeave(e);
         if (mouseTrack != null)
         {
            mouseTrack.MouseOver = false;
            mouseTrack = null;
            this.Cursor = Cursors.Default;
            Invalidate();
         }
      }

      /// &lt;summary&gt;
      /// Raises the MouseWheel event and performs mouse wheel 
      /// processing for the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;A MouseEventArgs object describing the mouse
      /// move event that has occurred.&lt;/param&gt;
      protected override void OnMouseWheel (
       System.Windows.Forms.MouseEventArgs e )
      {
         base.OnMouseWheel(e);

         if ((e.Delta &gt; 0) &amp;&amp; (btnUp.Visible))
         {
            Scroll(1);   
         }         
         else if ((e.Delta &lt; 0) &amp;&amp; (btnDown.Visible))
         {
            Scroll(-1);
         }
         
      }

      private object GetBestDragDropFormat(DragEventArgs e)
      {
         object ret = null;
         object defaultFormat = null;
         foreach (string format in e.Data.GetFormats() )
         {
            object thisFormatData = e.Data.GetData(format);
            if (defaultFormat == null)
            {
               defaultFormat = thisFormatData;
            }

            if (typeof(ListBarItem).IsAssignableFrom(thisFormatData.GetType()))
            {
               ret  = thisFormatData;
               break;
            }
            else if
             (typeof(ListBarItem).IsAssignableFrom(thisFormatData.GetType()))
            {
               ret = thisFormatData;
               break;
            }
         }

         if (ret == null)
         {
            ret = defaultFormat;
         }

         return ret;
      }

      private object GetTypeOrSubClassFromData(DragEventArgs e, Type dataType)
      {
         object ret = null;
         foreach (string format in e.Data.GetFormats() )
         {
            if (dataType.IsAssignableFrom(e.Data.GetData(format).GetType()))
            {
               ret = e.Data.GetData(format);
               break;
            }
         }
         return ret;
      }

      private bool PerformAutoDrag(DragEventArgs e)
      {
         bool ret = false;
         if ((this.allowDragItems) || (this.allowDragGroups))
         {
            foreach (string format in e.Data.GetFormats() )
            {
               Type dataType = e.Data.GetData(format).GetType();
               if (typeof(ListBarItem).IsAssignableFrom(dataType))
               {
                  ret = true;
                  break;
               }
               else if (typeof(ListBarGroup).IsAssignableFrom(dataType))
               {
                  ret = true;
                  break;
               }
            }
         }
         return ret;
      }

      /// &lt;summary&gt;
      /// Raises the DragOver event and performs internal processing of 
      /// drag-drop to show the insertion point and navigate through
      /// the items in the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;A DragEventArgs object describing the drag
      /// over being performed.&lt;/param&gt;
      protected override void OnDragOver(DragEventArgs e)
      {
         // perform the base operation:
         base.OnDragOver(e);   
         
         if (groups.Count &gt; 0)
         {
            if (e.Effect != DragDropEffects.None) 
            {
               this.InternalDragOverProcess(e, true);
            }
            else if (this.PerformAutoDrag(e)) 
            {               
               this.InternalDragOverProcess(e, false);
            }
         }

      }

      /// &lt;summary&gt;
      /// 
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;&lt;/param&gt;
      protected override void OnDragDrop(DragEventArgs e)
      {
         // perform the base operation:
         base.OnDragDrop(e);   

         if (groups.Count &gt; 0)
         {
            object obj = GetBestDragDropFormat(e);
            
            if (e.Effect != DragDropEffects.None) 
            {
               bool move = (e.Effect == DragDropEffects.Move);
               this.InternalDragDropComplete(obj, move);
            }
            else if (this.PerformAutoDrag(e)) 
            {               
               this.InternalDragDropComplete(obj, true);
            }
         }

      }
      
      /// &lt;summary&gt;
      /// Raises the BeforeSelectedGroupChanged event.  This event enables
      /// the user to prevent a group selection.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;The BeforeGroupChangedEventArgs object associated
      /// with this event.&lt;/param&gt;
      protected virtual void OnBeforeGroupChanged(ref
       BeforeGroupChangedEventArgs e)
      {
         if (this.BeforeSelectedGroupChanged != null)
         {
            this.BeforeSelectedGroupChanged(this, e);            
         }
      }
      /// &lt;summary&gt;
      /// Raises the BeforeItemClicked event.  This event enables
      /// the user to prevent an item from being selected.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;The BeforeItemClickedEventArgs object associated
      /// with this event.&lt;/param&gt;
      protected virtual void OnBeforeItemClicked(ref BeforeItemClickedEventArgs
       e)
      {
         e.Cancel = (!e.Item.Enabled);
         if (this.BeforeItemClicked != null)
         {
            this.BeforeItemClicked(this, e);            
         }
      }

      /// &lt;summary&gt;
      /// Raises the &lt;c&gt;ItemClicked&lt;/c&gt; event. 
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;The &lt;c&gt;ItemClickedEventArgs&lt;/c&gt; object associated 
      /// with this event.&lt;/param&gt;
      protected virtual void OnItemClicked(ItemClickedEventArgs e)
      {
         if (this.ItemClicked != null)
         {
            this.ItemClicked(this, e);
         }
      }

      /// &lt;summary&gt;
      /// Raises the &lt;c&gt;GroupClicked&lt;/c&gt; event.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;The &lt;c&gt;GroupClickedEventArgs&lt;/c&gt; object
      /// associated with this event.&lt;/param&gt;
      protected virtual void OnGroupClicked(GroupClickedEventArgs e)
      {
         if (this.GroupClicked != null)
         {
            this.GroupClicked(this, e);
         }
      }

      /// &lt;summary&gt;
      /// Raises the BeforeLabelEdit event for an item in the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;The LabelEditEventArgs describing the item
      /// that is about to be edited and allowing the edit action
      /// to be cancelled.&lt;/param&gt;
      protected virtual void OnBeforeLabelEdit ( ListBarLabelEditEventArgs e )
      {
         if (BeforeLabelEdit != null)
         {
            this.BeforeLabelEdit(this, e);
         }
      }

      /// &lt;summary&gt;
      /// Raises the AfterLabelEdit event for an item in the control.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;The AfterEditEventArgs describing the item
      /// that has just been edited and allowing the edit action
      /// to be cancelled or the new caption to be changed.&lt;/param&gt;
      protected virtual void OnAfterLabelEdit ( ListBarLabelEditEventArgs e )
      {
         if (AfterLabelEdit != null)
         {
            this.AfterLabelEdit(this, e);
         }
      }

      /// &lt;summary&gt;
      /// Raises the &lt;c&gt;SelectedGroupChanged&lt;/c&gt; event.
      /// &lt;/summary&gt;
      /// &lt;param name="e"&gt;An EventArgs object associated with the event.&lt;/param&gt;
      protected virtual void OnSelectedGroupChanged ( System.EventArgs e )
      {
         if (SelectedGroupChanged != null)
         {
            SelectedGroupChanged(this, e);
         }
      }

      private void txtEdit_TextChanged(object sender, System.EventArgs e)
      {
         if (editItem != null)
         {
            setTextBoxSize(editItem);
         }
      }

      private void txtEdit_KeyDown(object sender, KeyEventArgs e)
      {
         switch (e.KeyData)         
         {
            case Keys.Return:
               // end editing:
               EndTextEdit(true);
               break;

            case Keys.Escape:
               // cancel editing:
               EndTextEdit(false);
               break;            
         }
      }

      private void popupCancel_PopupCancel(object sender, EventArgs e)
      {
         EndTextEdit(true);
      }

      #endregion

      #region Internal implementation
      private void EndTextEdit(bool commit)
      {
         if (this.editItem != null)
         {
            ListBarItem editedItem = this.editItem;
            this.editItem = null;
            
            if ((commit) &amp;&amp; (editedItem != null))
            {
               ListBarGroup selectedGroup = SelectedGroup;

               ListBarLabelEditEventArgs lea = new ListBarLabelEditEventArgs(
                  selectedGroup.Items.IndexOf(editItem), txtEdit.Text,
                   editedItem);
               OnAfterLabelEdit(lea);

               if (!lea.CancelEdit )
               {
                  if (editedItem != null) // may be shutting down...
                  {
                     editedItem.Caption = lea.Label;
                  }
               }
            }
         }
         else if (this.editGroup != null)
         {
            ListBarGroup editedGroup = this.editGroup;
            this.editGroup = null;

            if ((commit) &amp;&amp; (editedGroup != null))
            {
               ListBarLabelEditEventArgs lea = new ListBarLabelEditEventArgs(
                  this.Groups.IndexOf(editedGroup), txtEdit.Text, editedGroup);
               OnAfterLabelEdit(lea);

               if (!lea.CancelEdit)
               {
                  if (editedGroup != null)
                  {
                     editedGroup.Caption = lea.Label;
                  }
               }
            }
         }

         txtEdit.Visible = false;
         Invalidate();
      }

      private void InternalDragDropComplete(
            object dragItem,
            bool move
         )
      {
         ListBarItem listBarDragItem = null;

         if (typeof(ListBarItem).IsAssignableFrom(dragItem.GetType()))
         {
            listBarDragItem = (ListBarItem)dragItem;
            listBarDragItem.MouseOver = false;
            listBarDragItem.MouseDown = false;
         }
         
         if (dragInsertPoint != null)
         {
            ListBarGroup groupTo = SelectedGroup;
            if (groupTo != null) // cannot happen...
            {
               ListBarGroup groupFrom = null;

               if (listBarDragItem != null)
               {
                  // Check which bar we've come from
                  // (it may be none, we may have come
                  // from another control):
                  
                  foreach (ListBarGroup group in groups)
                  {
                     if (group.Items.Contains(listBarDragItem))
                     {
                        groupFrom = group;
                        break;
                     }
                  }
               }

               if (groupFrom != null) // Dragged from this control
               {
                  // moving to a new group: 
                  if (move)
                  {
                     if (dragInsertPoint.ItemAfter != null)
                     {
                        if (dragInsertPoint.ItemAfter.Equals(listBarDragItem))
                        {
                           listBarDragItem = null;
                        }
                     }
                     else if (dragInsertPoint.ItemBefore != null)
                     {
                        if (dragInsertPoint.ItemBefore.Equals(listBarDragItem))
                        {
                           listBarDragItem = null;
                        }
                     }
                     if (listBarDragItem != null)
                     {
                        groupFrom.Items.Remove(listBarDragItem);               
                              
                     }
                  }
                  else
                  {
                     // Clone a new item to add:
                     ListBarItem newItem = new ListBarItem(
                        listBarDragItem.Caption, listBarDragItem.IconIndex,
                         listBarDragItem.ToolTipText,
                        listBarDragItem.Tag);
                     listBarDragItem = newItem;
                  }
               }
               else
               {
                  // add a new item which represents what's been dragged
                  if (listBarDragItem != null)
                  {
                     // there's an issue with which image to pick here
                     listBarDragItem = new ListBarItem(
                        listBarDragItem.Caption, listBarDragItem.IconIndex, 
                        listBarDragItem.ToolTipText, listBarDragItem.Tag);
                  }
                  else
                  {
                     // Create a new item
                     listBarDragItem = new ListBarItem(
                        dragItem.ToString());
                     ((ListBarItem)dragItem).Tag = dragItem;
                  }
               }

               if (listBarDragItem != null)
               {
                  if (dragInsertPoint.ItemAfter != null)
                  {
                     groupTo.Items.InsertAfter(dragInsertPoint.ItemAfter,
                      listBarDragItem);
                  }
                  else
                  {
                     groupTo.Items.InsertAfter(dragInsertPoint.ItemAfter,
                      listBarDragItem);
                  }
               }
            }      
         }

         dragInsertPoint = null;
         Invalidate();
      }

      private void SelectGroup(ListBarGroup group)
      {
         // first work out the scrolling logic:
         
         ListBarGroup selGroup = SelectedGroup;
         if (selGroup != group)
         {
            // Which groups are we moving between?
            this.indexNew = this.groups.IndexOf(group);
            this.indexCurrent = this.groups.IndexOf(selGroup);

            // Scrolling the new group into view:
            if (this.redraw)
            {
               this.scrollingGroup = true;

               if (this.indexNew &gt; this.indexCurrent)
               {
                  // the new index is below the current one.               
                  // Scroll buttons from indexCurrent + 1 to indexNew
                  // upwards
                  int newIndexTargetPos = selGroup.ButtonLocation.Y +
                   selGroup.ButtonHeight;
                  for (int i = this.indexCurrent + 1; i &lt;= this.indexNew - 1;
                   i++)
                  {
                     if (this.groups[i].Visible)
                     {
                        newIndexTargetPos += this.groups[i].ButtonHeight;
                     }
                  }

                  bool finished = false;
                  int currentPos = group.ButtonLocation.Y;
                  int step = -1;
                  while (!finished)
                  {
                     currentPos += step;
                     if (currentPos &lt;= newIndexTargetPos)
                     {
                        step += (newIndexTargetPos - currentPos);
                        currentPos = newIndexTargetPos;
                        finished = true;
                     }

                     for (int i = this.indexCurrent + 1; i &lt;= this.indexNew;
                      i++)
                     {
                        ListBarGroup workGroup = this.groups[i];
                        if (workGroup.Visible)
                        {
                           Point newLocation = workGroup.ButtonLocation;
                           newLocation.Y += step;
                           workGroup.SetLocationAndWidth(
                              newLocation, workGroup.ButtonWidth);
                        }
                     }

                     this.Invalidate();
                     this.Update();

                     step *= 2;
                  }
                                       
               }
               else
               {
                  // the new index is above the current one.
                  // scroll buttons from indexNew + 1 to indexCurrent
                  // downwards
                  int lastIndex = indexCurrent;
                  int nextIndex = this.Groups.Count -1;
                  for (int i = indexCurrent + 1; i &lt; this.Groups.Count; i++)
                  {
                     if (i &gt; lastIndex)
                     {
                        lastIndex = i;
                     }
                     if (i &lt; nextIndex)
                     {
                        nextIndex = i;
                     }
                  }
                  int currentTargetPos = (indexCurrent == lastIndex ?
                     this.ClientRectangle.Height :
                     this.groups[nextIndex].ButtonLocation.Y);

                  bool finished = false;
                  int currentPos = selGroup.ButtonLocation.Y;
                  int step = 1;
                  while (!finished)
                  {
                     currentPos += step;
                     if (currentPos &gt;= currentTargetPos)
                     {
                        step -= (currentPos - currentTargetPos);
                        currentPos = currentTargetPos;
                        finished = true;
                     }

                     for (int i = indexNew + 1; i &lt;= indexCurrent; i++)
                     {
                        ListBarGroup workGroup = this.groups[i];
                        if (workGroup.Visible)
                        {
                           Point newLocation = workGroup.ButtonLocation;
                           newLocation.Y += step;
                           workGroup.SetLocationAndWidth(newLocation,
                            workGroup.ButtonWidth);
                        }
                     }

                     this.Invalidate();
                     this.Update();

                     step *= 2;

                  }
               
               }

               this.scrollingGroup = false;
            }

            selGroup.Selected = false;
            group.Selected = true;
            DoResize();
         }

      }

      /// &lt;summary&gt;
      /// Selects an item in response to a mouse event.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;Item to be selected.&lt;/param&gt;
      /// &lt;param name="e"&gt;&lt;see cref="System.Windows.Forms.MouseEventArgs"/&gt; 
      /// details associated with the mouse event.&lt;/param&gt;
      private void MouseSelectItem(ListBarItem item, MouseEventArgs e)
      {
         BeforeItemClickedEventArgs bic = new BeforeItemClickedEventArgs(
            (ListBarItem)mouseTrack);
         OnBeforeItemClicked(ref bic);
         if (!bic.Cancel)
         {
            // item clicked:
            SelectItem((ListBarItem)mouseTrack);
            ItemClickedEventArgs ic = new ItemClickedEventArgs(
               (ListBarItem)mouseTrack,
               new Point(e.X, e.Y),
               e.Button );
            OnItemClicked(ic);
         }
      }

      /// &lt;summary&gt;
      /// Selects an item in the selected bar and makes
      /// it visible.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;The item to select.&lt;/param&gt;
      private void SelectItem(ListBarItem item)
      {
         BeginUpdate();
         foreach (ListBarItem otherItem in SelectedGroup.Items)
         {
            otherItem.Selected = false;
         }
         item.Selected = true;
         EndUpdate();
         EnsureItemVisible(item);
         Invalidate();
      }

      /// &lt;summary&gt;
      /// Starts editing the specified ListBarGroup.  Note this
      /// method is called from the StartEdit method of a ListBarGroup.
      /// &lt;/summary&gt;
      /// &lt;param name="group"&gt;The group to start editing.&lt;/param&gt;
      protected internal void StartGroupEdit(ListBarGroup group)
      {
         // Fire the BeforeLabelEdit event:
         ListBarLabelEditEventArgs e = new ListBarLabelEditEventArgs(
            this.groups.IndexOf(group), group.Caption, group);
         OnBeforeLabelEdit(e);
         
         if (!e.CancelEdit)
         {
            editGroup = group;

            // Focus the control:
            this.Focus();

            // Set the edit text:
            txtEdit.Text = group.Caption;
            txtEdit.Font = (group.Font == null ? this.Font : group.Font);
            txtEdit.Location = group.ButtonLocation;
            txtEdit.Size = new Size(group.ButtonWidth, group.ButtonHeight);
            txtEdit.Visible = true;            
            txtEdit.BringToFront();
            txtEdit.Focus();

            popupCancel.StartTracking(txtEdit);
         }

      }

      /// &lt;summary&gt;
      /// Starts editing the specified &lt;c&gt;ListBarItem&lt;/c&gt;.  Note this
      /// method is called from the &lt;c&gt;StartEdit&lt;/c&gt; method of a 
      /// &lt;c&gt;ListBarItem&lt;/c&gt;.
      /// &lt;seealso cref="ListBarItem.StartEdit"/&gt;
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;The item to start editing.&lt;/param&gt;
      protected internal void StartItemEdit(ListBarItem item)
      {

         // Get rectangle of item relative to control:
         ListBarGroup selectedGroup = SelectedGroup;

         // Check whether item is part of the selected
         // control:
         if (selectedGroup.Items.Contains(item))
         {
            // Fire the BeforeLabelEdit event:
            ListBarLabelEditEventArgs e = new ListBarLabelEditEventArgs(
               selectedGroup.Items.IndexOf(item), item.Caption, item);
            OnBeforeLabelEdit(e);
            if (!e.CancelEdit)
            {
               editItem = item;

               // Make sure we can see it:
               EnsureItemVisible(item);

               // Focus the control:
               this.Focus();

               // Set the edit text:
               txtEdit.Text = item.Caption;
               txtEdit.Font = (item.Font == null ? this.Font : item.Font);
               setTextBoxSize(editItem);
               int top = item.TextRectangle.Top;                  
               txtEdit.Top = top;
               txtEdit.Visible = true;            
               txtEdit.BringToFront();
               txtEdit.Focus();

               popupCancel.StartTracking(txtEdit);
            }
         }
         else
         {
            throw new InvalidOperationException(
               "Editing is only possible on items belonging to the
                SelectedGroup in the control.");
         }


      }

      private void setTextBoxSize(ListBarItem editItem)
      {
         ListBarGroup selectedGroup = SelectedGroup;
         if (selectedGroup != null)
         {

            string text = txtEdit.Text;
            if (text.Length == 0)
            {
               text = "Xg";
            }
            
            int maxWidth = 0;
            if (selectedGroup.View == ListBarGroupView.SmallIcons)
            {
               maxWidth = this.ClientRectangle.Width -
                editItem.TextRectangle.Left - 1;
            }
            else
            {
               maxWidth = this.ClientRectangle.Width - 2;               
            }

            Graphics gfx = Graphics.FromHwnd(txtEdit.Handle);
            StringFormat fmt = new StringFormat(StringFormatFlags.LineLimit | 
               (txtEdit.RightToLeft == RightToLeft.Yes ?
                StringFormatFlags.DirectionRightToLeft : 0));
            fmt.Alignment = StringAlignment.Center;
            SizeF textSize = gfx.MeasureString(text, txtEdit.Font, maxWidth -
             6, fmt);
            fmt.Dispose();
            gfx.Dispose();                  
            
            if (textSize.Width &lt; 24)
            {
               textSize.Width = 24;
            }
            textSize.Height += 2.0F;
            
            txtEdit.Size = new Size((int)textSize.Width + 6,
             (int)textSize.Height + 4);                     
            if (selectedGroup.View == ListBarGroupView.SmallIcons)
            {
               txtEdit.Left = editItem.TextRectangle.Left + 1;
            }
            else
            {
               txtEdit.Left = 1 + (maxWidth - (int)textSize.Width) / 2;
            }
         }
      }

      /// &lt;summary&gt;
      /// Brings the specified &lt;c&gt;ListBarItem&lt;/c&gt; into view if it is not already
      /// visible.  The &lt;c&gt;ListBarItem&lt;/c&gt; must be in the selected group.
      /// &lt;seealso cref="ListBarItem"/&gt;
      /// &lt;seealso cref="ListBar.SelectedGroup"/&gt;
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;Item to bring into view.&lt;/param&gt;
      protected internal void EnsureItemVisible(ListBarItem item)
      {
         // Get rectangle of item relative to control:
         ListBarGroup selectedGroup = SelectedGroup;

         // Check whether item is part of the selected
         // group:
         if (selectedGroup.Items.Contains(item))
         {
            Rectangle rcVisible = new Rectangle(
               selectedGroup.ButtonLocation, 
               new Size(this.ClientRectangle.Width, 0)
               );
            
            ListBarGroup nextGroup = null;
            for (int i = this.groups.IndexOf(selectedGroup) + 1; i &lt;
             this.groups.Count; i++)
            {
               if (this.groups[i].Visible)
               {
                  nextGroup = this.groups[i];
                  break;
               }
            }

            if (nextGroup == null)
            {
               rcVisible.Height = this.ClientRectangle.Height - 
                  (selectedGroup.ButtonLocation.Y + selectedGroup.ButtonHeight);
            }
            else
            {               
               rcVisible.Height = nextGroup.ButtonLocation.Y - rcVisible.Top; 
            }

            bool invisible = true;
            bool notFirstTime = false;
            while (invisible)
            {
               Rectangle rcItem = new Rectangle(item.Location,
                  new Size(this.ClientRectangle.Width, item.Height));
               rcItem.Offset(0, 
                  selectedGroup.ButtonLocation.Y + selectedGroup.ButtonHeight + 
                  selectedGroup.ScrollOffset);

               // Check if the item is too low:
               if (rcItem.Bottom &gt; rcVisible.Bottom )
               {
                  // need to scroll down until it can be seen:
                  Scroll(-1, notFirstTime);
               }
               else if (rcItem.Top &lt; rcVisible.Top)
               {
                  // need to scroll up until it can be seen:
                  Scroll(1, notFirstTime);
               }
               else
               {
                  invisible = false;
               }
               notFirstTime = true;
            }
         }
      }

      /// &lt;summary&gt;
      /// Checks if there is an object which interacts with
      /// the mouse in the control under the specified point.
      /// &lt;/summary&gt;
      /// &lt;param name="pt"&gt;The point to test.&lt;/param&gt;
      /// &lt;returns&gt;If there is a mouse object under the point 
      /// then its IMouseObject interface, otherwise null.&lt;/returns&gt;
      private IMouseObject HitTest(Point pt)
      {
         return HitTest(pt, false);
      }

      /// &lt;summary&gt;
      /// Checks if there is an object which interacts with
      /// the mouse in the control under the specified point.
      /// &lt;/summary&gt;
      /// &lt;param name="pt"&gt;The point to test.&lt;/param&gt;
      /// &lt;returns&gt;If there is a mouse object under the point 
      /// then its IMouseObject interface, otherwise null.&lt;/returns&gt;
      /// &lt;param name="forDragDrop"&gt;Whether the hit testing is
      /// being performed for a drag-drop operation or not.  During
      /// drag-drop, the hittest rectangle is relaxed so it includes
      /// the entire rectangle and not just the icon and text.
      /// &lt;/param&gt;
      private IMouseObject HitTest(Point pt, bool forDragDrop)
      {
         // Default return value:
         IMouseObject mouseObject = null;
         ListBarGroup selectedGroup = SelectedGroup;

         // Over a scroll button?
         if (btnUp.HitTest(pt))
         {
            // over the scroll up button:
            mouseObject = btnUp;
         }
         else if (btnDown.HitTest(pt))
         {
            // over the scroll down button:
            mouseObject = btnDown;
         }
         else
         {
            if ((forDragDrop) &amp;&amp; (selectedGroup != null))
            {
               // we test for any point with 6 pixels of
               // the scroll bars if the scroll buttons are on:
               if (btnUp.Visible)
               {
                  Rectangle scrollTest = new Rectangle(
                     selectedGroup.ButtonLocation.X,
                      selectedGroup.ButtonLocation.Y +
                      selectedGroup.ButtonHeight,
                     this.ClientRectangle.Width, 6);
                  if (scrollTest.Contains(pt))
                  {
                     mouseObject = btnUp;
                  }
               }
               if (btnDown.Visible)
               {
                  ListBarGroup nextGroup = null;
                  for (int i = this.groups.IndexOf(selectedGroup) + 1; i &lt;
                   this.groups.Count; i++)
                  {
                     if (this.groups[i].Visible)
                     {
                        nextGroup = this.groups[i];
                        break;
                     }
                  }
                  if (nextGroup != null)
                  {
                     Rectangle scrollTest = new Rectangle(
                        nextGroup.ButtonLocation.X, nextGroup.ButtonLocation.Y
                         - 6,
                        this.ClientRectangle.Width, 6);
                     if (scrollTest.Contains(pt))
                     {
                        mouseObject = btnDown;
                     }                  
                  }
               }
            }
         }

         // Check whether we're over any group buttons:
         if (mouseObject == null)
         {
            foreach (ListBarGroup group in this.groups)
            {
               if (group.Visible)
               {
                  Rectangle buttonRectangle = new Rectangle(
                     group.ButtonLocation, new Size(group.ButtonWidth,
                      group.ButtonHeight));
                  if (buttonRectangle.Contains(pt))
                  {
                     // over a group:
                     mouseObject = group;
                     break;
                  }
               }
            }
         }

         // Otherwise check whether we're over any list bar buttons:
         if (mouseObject == null)
         {
            // Is there a selected ListBar Group?
            if (selectedGroup != null)
            {
               // Check each item in this group:
               foreach (ListBarItem item in selectedGroup.Items)
               {
                  Rectangle rcTest;
                  if (forDragDrop)
                  {
                     // For drag drop the entire rectangle of the item
                     // is taken into account:
                     rcTest = new Rectangle(item.Location,
                        new Size(item.Width, item.Height));
                     rcTest.Offset(0, selectedGroup.ScrollOffset +
                      selectedGroup.ButtonLocation.Y +
                      selectedGroup.ButtonHeight);
                     if (rcTest.Contains(pt))
                     {
                        mouseObject = item;
                        break;
                     }

                  }
                  else
                  {
                     // Get the icon rectangle of the item within the group:
                     rcTest = item.IconRectangle;
                     // Check if the point is there:
                     if (rcTest.Contains(pt))
                     {
                        // We're over an item:
                        mouseObject = item;
                        break;
                     }
                     // Otherwise try the text rectangle:
                     rcTest = item.TextRectangle;
                     if (rcTest.Contains(pt))
                     {
                        // We're over an item:
                        mouseObject = item;
                        break;
                     }
                  }
               }
            }
         }

         // Return the object the mouse is over if any
         return mouseObject;
      }

      
      /// &lt;summary&gt;
      /// Internal notification from a ListBarGroup that it has 
      /// been changed.
      /// &lt;/summary&gt;
      /// &lt;param name="group"&gt;The ListBarGroup which has been
      /// changed, or null the group has been removed.&lt;/param&gt;
      /// &lt;param name="addRemove"&gt;Whether the effect of the
      /// change will require the control to re-measured.&lt;/param&gt;
      protected internal void GroupChanged(ListBarGroup group, bool addRemove)
      {
         // if we have changed the number of groups,
         // we need to redraw the entire control,
         // otherwise we just redraw this group
         if (addRemove)
         {   
            if (group != null)
            {
               group.SetButtonHeight(this.Font);
            }
            DoResize();
            PostResizeBarChanged();
         }         
         Invalidate();   
      }

      /// &lt;summary&gt;
      /// Internal notification from a ListBarItem that it has been
      /// changed.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;The ListBarItem which has been changed, 
      /// or null if the item has been removed.&lt;/param&gt;
      /// &lt;param name="addRemove"&gt;Whether the effect of the control
      /// will require the bar's contents to be remeasured.&lt;/param&gt;
      protected internal void ItemChanged(ListBarItem item, bool addRemove)
      {
         ListBarGroup selGroup = SelectedGroup;
         ListBarGroup owningGroup = null;
         if (item != null)
         {
            // Which bar does it belong to
            foreach (ListBarGroup group in this.groups)
            {
               if (group.Items.Contains(item))
               {
                  owningGroup = group;
                  break;
               }
            }
            
            if (owningGroup != null)
            {
               Size imageSize = new Size(32, 32);
               if ((owningGroup.View == ListBarGroupView.LargeIcons) ||
                (owningGroup.View == ListBarGroupView.LargeIconsOnly))
               {
                  if (this.largeImageList != null)
                  {
                     imageSize = this.largeImageList.ImageSize;
                  }
               }
               else
               {
                  if (smallImageList != null)
                  {
                     imageSize = this.smallImageList.ImageSize;
                  }
                  else
                  {
                     imageSize = new Size(16, 16);
                  }
               }

               // Tell the item to size itself
               item.SetSize(owningGroup.View, base.Font, imageSize);           
                         
            }
            else
            {
               selGroup.SetLocationAndWidth(selGroup.ButtonLocation,
                selGroup.ButtonWidth);
            }
         }

         if (selGroup != null)
         {            
            if (item == null)
            {
               // need to assume it does
               if (addRemove)
               {
                  DoResize();
                  PostResizeBarChanged();
               }
               Invalidate();
            }
            else
            {
               if (selGroup.Items.Contains(item))
               {                  
                  // yes it does.  We need to modify the 
                  // display:
                  if (addRemove)
                  {
                     DoResize();
                     PostResizeBarChanged();
                  }
                  Invalidate();
               }
               else
               {
                  if (owningGroup == null)
                  {
                     if (addRemove)
                     {
                        DoResize();
                        PostResizeBarChanged();
                     }
                     Invalidate();
                  }
               }
            }
         }
      }

      /// &lt;summary&gt;
      /// Ensures the scroll bar isn't irrelevantly 
      /// begin displayed.
      /// &lt;/summary&gt;
      private void PostResizeBarChanged()
      {
         // if the selected bar is scrolled,then we need 
         // to check in the new arrangement that there isn't
         // an unused space below the last item in the bar.
         
         // if there is we should check if it is possible
         // to scroll up by one or more items whilst still
         // ensuring the last item currently visible in the
         // view does not become any less visible.

         ListBarGroup selectedGroup = SelectedGroup;

         if (selectedGroup != null) 
         {
            if (selectedGroup.Items.Count &gt; 0)
            {
               if (selectedGroup.ScrollOffset != 0)
               {
                  bool finished = false;
                  ListBarGroup nextGroup = null;
                  for (int i = this.groups.IndexOf(selectedGroup) + 1; i &lt;
                   this.groups.Count; i++)
                  {
                     if (this.groups[i].Visible)
                     {
                        nextGroup = this.groups[i];
                        break;
                     }
                  }
                  
                  while (!finished)
                  {      
                     ListBarItem lastItem =
                      selectedGroup.Items[selectedGroup.Items.Count - 1];
                     Rectangle rcItemLast = new Rectangle(lastItem.Location,
                        new Size(this.ClientRectangle.Width, lastItem.Height));
                     rcItemLast.Offset(0, selectedGroup.ScrollOffset +
                      selectedGroup.ButtonLocation.Y +
                      selectedGroup.ButtonHeight );

                     Rectangle rcView = new Rectangle(
                        selectedGroup.ButtonLocation.X,
                         selectedGroup.ButtonLocation.Y +
                         selectedGroup.ButtonHeight,
                        this.ClientRectangle.Width, 0);
                     if (nextGroup == null)
                     {
                        rcView.Height = this.ClientRectangle.Height -
                         rcView.Top;
                     }
                     else
                     {
                        rcView.Height = nextGroup.ButtonLocation.Y - rcView.Top;
                     }

                     if (rcItemLast.Bottom &lt; rcView.Bottom + rcItemLast.Height)
                     {
                        // we can scroll up:
                        Scroll(1);
                     }
                     else
                     {
                        finished = true;
                     }

                     if (selectedGroup.ScrollOffset == 0)
                     {
                        finished = true;
                     }
                  }
               }
            }
         }
      }

      private void InternalDragOverProcess(DragEventArgs e, bool assumeItem)
      {
         // TODO: this method requires refactoring
         
         ListBarItem itemBefore = null;
         ListBarItem itemAfter = null;
         bool overEmptyBar = false;
         IMouseObject newDragHoverOver = null;
         bool overGroup = false;

         // see if the drag drop data contains a ListBarItem:      
         if ((GetTypeOrSubClassFromData(e, typeof(ListBarItem)) != null) 
            || (assumeItem &amp;&amp; (GetTypeOrSubClassFromData(e,
             typeof(ListBarGroup)) == null)))
         {
            // check if we're over an item:
            Point pt = new Point(e.X, e.Y);
            pt = this.PointToClient(pt);
            IMouseObject obj = HitTest(pt, true);
            newDragHoverOver = obj;
                           
            if (obj != null)
            {
               // Do scrolling checks on this bar.  Scrolling
               // is rate limited to once per 250ms to assist
               // with usability
               System.TimeSpan diff = DateTime.Now.Subtract(lastScrollTime);
               if (diff.Milliseconds &gt; 250)
               {
               
                  // Firstly, check if we're over an actual scroll button:
                  if
                   (typeof(ListBarScrollButton).IsAssignableFrom(obj.GetType()))
                  {
                     // scroll in the appropriate direction:
                     ListBarScrollButton scrollButton =
                      (ListBarScrollButton)obj;
                     Scroll(scrollButton, true);
                     lastScrollTime = DateTime.Now;
                  }
                  else
                  {
                     // Otherwise, we may be within the boundary of the
                     // scroll buttons:
                     if (btnUp.Visible)
                     {
                        Rectangle rcBtnUp = btnUp.Rectangle;
                        rcBtnUp.X = 0;
                        rcBtnUp.Width = this.ClientRectangle.Width;
                        if (rcBtnUp.Contains(pt))
                        {
                           Scroll(1,true);
                           lastScrollTime = DateTime.Now;
                        }
                     }
                     if (btnDown.Visible)
                     {
                        Rectangle rcBtnDown = btnDown.Rectangle;
                        rcBtnDown.X = 0;
                        rcBtnDown.Width = this.ClientRectangle.Width;
                        if (rcBtnDown.Contains(pt))
                        {
                           Scroll(-1,true);
                           lastScrollTime = DateTime.Now;
                        }
                     }

                  }
               }


               // Now check for being over an item or an empty bar:
               if (typeof(ListBarItem).IsAssignableFrom(obj.GetType()))
               {
                  ListBarItem item = (ListBarItem)obj;
                  object objDragItem = GetTypeOrSubClassFromData(e,
                   typeof(ListBarItem));
                  bool itemEqualsDragItem = false;
                  ListBarItem dragItem = null;
                  if (objDragItem != null)
                  {
                     dragItem = (ListBarItem)objDragItem;
                     itemEqualsDragItem = item.Equals(dragItem);
                  }
               
                  if (!itemEqualsDragItem) 
                  {
                     // we're over an item.
               
                     // Get the rectangle relative to the bar:
                     Rectangle rc = new Rectangle(item.Location, new
                      Size(item.Width, item.Height));
                     // Adjust the rectangle so it's relative to the control:
                     ListBarGroup selectedGroup = SelectedGroup;
                     rc.Offset(0, selectedGroup.ButtonLocation.Y +
                      selectedGroup.ButtonHeight + selectedGroup.ScrollOffset);

                     // The commented section here is an 8 pixel
                     // margin from the top or bottom of an item,
                     // as per the Outlook bar.  I found the control
                     // more usable with a ListView style drag-drop
                     // approach, where the before/after decision
                     // is made depending on where you are relative
                     // to the centre of the item.
                        
                     /* 
                        ** BEGIN: Outlook style drag-drop logic
                     if (((pt.Y - rc.Top) &gt; -8) &amp;&amp; ((pt.Y - rc.Top) &lt; 8))
                     {
                        itemBefore = item;
                        // we can't go before the item which follows
                        // the one we're dragging:
                        if ((selectedGroup.Items.IndexOf(itemBefore) - 1) == 
                           selectedGroup.Items.IndexOf(dragItem))
                        {
                           itemBefore = null;
                        }

                     }

                     if (((rc.Bottom - pt.Y) &gt; -8) &amp;&amp; ((rc.Bottom - pt.Y) &lt; 16))
                     {
                        itemAfter = item;
                        // we can't go after the item which is before
                        // the one we're dragging:
                        if ((selectedGroup.Items.IndexOf(itemAfter) + 1) == 
                           selectedGroup.Items.IndexOf(dragItem))
                        {
                           itemAfter = null;
                        }
                     }
                        ** END: Outlook style drag drop logic
                        */

                     // ListView style drag insert point logic.
                     if ((selectedGroup.View ==
                      ListBarGroupView.SmallIconsOnly) || (selectedGroup.View
                      == ListBarGroupView.LargeIconsOnly))
                     {
                        int distRight = Math.Abs(rc.Right - pt.X);
                        int distLeft = Math.Abs(pt.X - rc.Left);
                        if (distRight &lt; distLeft)
                        {
                           itemAfter = item;
                        }
                        else
                        {
                           itemBefore = item;
                        }
                     }
                     else
                     {
                        int distBottom = Math.Abs(rc.Bottom - pt.Y);
                        int distTop = Math.Abs(pt.Y - rc.Top);
                        if (distBottom &lt; distTop)
                        {
                           itemAfter = item;
                        }
                        else
                        {
                           itemBefore = item;
                        }
                     }

                     if (itemAfter != null)
                     {
                        // we can't go after the item which is before
                        // the one we're dragging:
                        /*
                        if ((selectedGroup.Items.IndexOf(itemAfter) + 1) == 
                           selectedGroup.Items.IndexOf(dragItem))
                        {
                           itemAfter = null;
                        }
                        */                           
                        if (itemAfter != null)
                        {
                           // check there isn't an appropriate item before:
                           if (selectedGroup.Items.IndexOf(itemAfter) &lt;
                            selectedGroup.Items.Count - 1)
                           {
                              itemBefore =
                               selectedGroup.Items[selectedGroup.Items.IndexOf(i
                              temAfter) + 1];
                           }
                        }
                     }
                     else if (itemBefore != null)
                     {
                        // we can't go before the item which follows
                        // the one we're dragging:
                        /*
                        if ((selectedGroup.Items.IndexOf(itemBefore) - 1) == 
                           selectedGroup.Items.IndexOf(dragItem))
                        {
                           itemBefore = null;
                        }
                        */               
                        if (itemBefore != null)
                        {
                           // check there isn't an appropriate item after:
                           if (selectedGroup.Items.IndexOf(itemBefore) &gt; 0)
                           {
                              itemAfter =
                               selectedGroup.Items[selectedGroup.Items.IndexOf(i
                              temBefore) - 1];
                           }
                        }
                     }
                  }
               }
               else if (typeof(ListBarGroup).IsAssignableFrom(obj.GetType()))
               {
                  overGroup = true;

                  // over a group
                  if (dragHoverOver != null)
                  {
                     if (dragHoverOver.Equals(obj))
                     {
                        System.TimeSpan overTime =
                         DateTime.Now.Subtract(dragHoverOverStartTime);
                        if (overTime.Milliseconds &gt; 350)
                        {
                           // we should select this group:
                           dragHoverOver = null;
                           SelectGroup((ListBarGroup)obj);
                           // Prevent the control from scrolling for a little
                            bit.
                           // TODO
                           // Actually what we really want to do here is to say
                           // that unless the mouse moves &gt; 4 pixels from this
                           // spot scrolling will not occur in the new bar
                           lastScrollTime = DateTime.Now.AddMilliseconds(500);
                        }
                     }
                  }
               }
            }
            else
            {
               // we may be over the bar section:
               ListBarGroup selectedGroup = SelectedGroup;
               
               if (selectedGroup != null) 
               {
                  if (selectedGroup.Items.Count &gt; 0)                  
                  {
                     // we're not over an item.  Check if we're 
                     // within the bar:
                     if (obj == null)
                     {                     
                        // Check if the selected group is the last group in
                        // the control:
                        ListBarGroup nextGroup = null;
                        for (int i = this.groups.IndexOf(selectedGroup) + 1; i
                         &lt; this.groups.Count; i++)
                        {
                           if (this.groups[i].Visible)
                           {
                              nextGroup = this.groups[i];
                              break;
                           }
                        }

                        if (nextGroup == null)
                        {
                           // If so the bar area extends from the bottom
                           // of the button rectangle to the bottom of the 
                           // control:
                           if ((pt.Y &gt; (selectedGroup.ButtonLocation.Y +
                            selectedGroup.ButtonHeight)) &amp;&amp; 
                              (pt.Y &lt; this.ClientRectangle.Height))
                           {
                              itemAfter =
                               selectedGroup.Items[selectedGroup.Items.Count -
                               1];
                           }
                        }
                        else
                        {
                           // Otherwise the bar area extends from the bottom
                           // of the button rectangle of this control to the
                           // top of the button rectangle of the next control:
                           if ((pt.Y &gt; (selectedGroup.ButtonLocation.Y +
                            selectedGroup.ButtonHeight)) &amp;&amp; 
                              (pt.Y &lt; nextGroup.ButtonLocation.Y))
                           {
                              itemAfter =
                               selectedGroup.Items[selectedGroup.Items.Count -
                               1];
                           }
                        }

                     }
                  }
                  else
                  {
                     overEmptyBar = true;
                  }
               }
            }
         }
         else if (GetTypeOrSubClassFromData(e, typeof(ListBarGroup)) !=  null)
         {
            itemAfter = null;
            itemBefore = null;            

            // Here we check if we should drag the list bar
            // into a new position
            // check if we're over an item:
            Point pt = new Point(e.X, e.Y);
            pt = this.PointToClient(pt);
            IMouseObject obj = HitTest(pt, true);
            newDragHoverOver = obj;
                           
            if (obj != null)
            {
               if (typeof(ListBarGroup).IsAssignableFrom(obj.GetType()))
               {
                  overGroup = true;

                  ListBarGroup dragGroup =
                   (ListBarGroup)GetTypeOrSubClassFromData(e,
                   typeof(ListBarGroup));

                  ListBarGroup dragOverGroup = (ListBarGroup)obj;
                  if (!dragOverGroup.Equals(dragGroup))
                  {
                     bool reSelect = false;
                     if (dragGroup.Selected)
                     {
                        reSelect = true;
                     }
                     bool isLastGroup = true;
                     for (int i = groups.IndexOf(dragOverGroup) + 1; i &lt;
                      this.groups.Count; i++)
                     {
                        if (this.groups[i].Visible)
                        {
                           isLastGroup = false;
                        }
                     }
                     this.groups.Remove(dragGroup);
                     if (isLastGroup)
                     {
                        this.groups.Add(dragGroup);
                     }
                     else
                     {
                        this.groups.Insert(groups.IndexOf(dragOverGroup),
                         dragGroup);
                     }
                     if (reSelect)
                     {
                        for (int i = 0; i &lt; this.groups.Count; i++)
                        {
                           this.groups[i].Selected = false;
                        }
                        dragGroup.Selected = true;
                     }
                     DoResize();
                     Invalidate();
                  }
               }
            }
         
         }

         // Now check if we have any drag/drop insert position:
         if ((itemBefore != null) || (itemAfter != null) || (overEmptyBar))
         {
            e.Effect = DragDropEffects.Move;

            ListBarDragDropInsertPoint newInsertPoint = 
               new ListBarDragDropInsertPoint(itemBefore, itemAfter,
                overEmptyBar);
               
            // do we currently have an insert point?
            if (dragInsertPoint != null)
            {
               if (dragInsertPoint.CompareTo(newInsertPoint) == 0)
               {
                  // we have nothing to do
                  newInsertPoint = null;
               }
            }
               
            if (newInsertPoint != null)
            {
               Trace.WriteLine("Drag Insert Point has changed");
               dragInsertPoint = newInsertPoint;
               Invalidate();
            }
         }
         else
         {
            if (overGroup)
            {
               e.Effect = DragDropEffects.Move;
            }
            else
            {
               e.Effect = DragDropEffects.None;
            }

            // Clear the drag insert point if it's set:
            if (dragInsertPoint != null)
            {
               dragInsertPoint = null;
               // redraw the control:
               Invalidate();
            }
         }

         if ((newDragHoverOver != null) &amp;&amp; (dragHoverOver != null))
         {                        
            if (!newDragHoverOver.Equals(dragHoverOver))
            {
               dragHoverOver = newDragHoverOver;
               dragHoverOverStartTime = DateTime.Now;
            }
            // else we keep the drag hover over time.
         }
         else
         {
            dragHoverOver = newDragHoverOver;
            dragHoverOverStartTime = DateTime.Now;
         }

      }
      #endregion

      #region API
      /// &lt;summary&gt;
      /// Called by the control's internal sizing mechanism.
      /// Returns the size of a &lt;see cref="ListBarGroup"/&gt; button
      /// rectangle.
      /// &lt;/summary&gt;
      /// &lt;param name="group"&gt;The &lt;see cref="ListBarGroup"/&gt; to get the 
      /// button width for.&lt;/param&gt;
      /// &lt;returns&gt;The width of the button.&lt;/returns&gt;
      protected virtual int GetGroupButtonWidth(ListBarGroup group)
      {
         return this.ClientRectangle.Width - 2;
      }

      /// &lt;summary&gt;
      /// Gets/sets the default &lt;see cref="System.Drawing.Font"/&gt; used to 
      /// render text in the control.
      /// &lt;/summary&gt;
      [Description("Gets/sets the Font used to render the text in this
       control.")]
      public override System.Drawing.Font Font
      {
         get
         {
            return base.Font;
         }
         set
         {
            base.Font = value;
            
            // Force all of the ListBar items to be measured
            foreach (ListBarGroup group in groups)
            {
               GroupChanged(group, true);
            }
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets whether items are selected on MouseDown,
      /// rather than on MouseUp, which is the default.   
      /// &lt;/summary&gt;
      [Description("Gets/sets whether items are selected on MouseDown, rather
       than on MouseUp.")]
      public bool SelectOnMouseDown
      {
         get
         {
            return this.selectOnMouseDown;
         }
         set
         {
            this.selectOnMouseDown = value;
         }
      }
   
      /// &lt;summary&gt;
      /// Gets/sets whether items will be dragged 
      /// in the control automatically.  The default
      /// is &lt;c&gt;True&lt;/c&gt;.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether items will be dragged in the control
       automatically.  The default is True.")]
      public bool AllowDragItems
      {
         get
         {
            return this.allowDragItems;
         }
         set
         {
            this.allowDragItems = value;
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets whether groups will be dragged 
      /// in the control automatically.  The default
      /// is &lt;c&gt;True&lt;/c&gt;. (Note in MS Outlook
      /// Groups cannot be reordered by dragging, but
      /// they can in VS.NET).
      /// &lt;/summary&gt;
      [Description("Gets/sets whether groups can be dragged automatically in
       the control.  The default is True.")]
      public bool AllowDragGroups
      {
         get
         {
            return this.allowDragGroups;
         }
         set
         {
            this.allowDragGroups = value;
         }
      }

      /// &lt;summary&gt;
      /// Sets the groups object associated with this control
      /// to a new group collection.
      /// &lt;/summary&gt;
      /// &lt;param name="groups"&gt;The &lt;see cref="ListBarGroupCollection"/&gt; object
       holding
      /// the new collection of groups to associate with this control.&lt;/param&gt;
      [Description("Sets the internal collection holding the Groups associated
       with this control to a new object.")]
      public void SetGroups(ListBarGroupCollection groups)
      {
         this.BeginUpdate();
         groups.SetOwner(this);
         this.EndUpdate();
         this.groups = groups;         
         DoResize();
         this.Invalidate();
      }

      /// &lt;summary&gt;
      /// Gets the item which is currently being edited, if any,
      /// otherwise returns null.
      /// &lt;/summary&gt;
      [Description("Gets the item which is currently being edited, if any,
       otherwise returns null.")]
      public ListBarItem EditItem
      {
         get
         {
            return this.editItem;
         }
      }

      /// &lt;summary&gt;
      /// Prevents the control from drawing until the 
      /// &lt;see cref="EndUpdate"/&gt; method is called.
      /// &lt;/summary&gt;
      [Description("Prevents the control from drawing until the EndUpdate
       method is called.")]
      public void BeginUpdate()
      {
         this.redraw = false;
      }

      /// &lt;summary&gt;
      /// Resumes drawing of the control after drawing was suspended by the 
      /// &lt;see cref="BeginUpdate"/&gt; method.      
      /// &lt;/summary&gt;
      [Description("Resumes drawing of the control after drawing was suspended
       by the BeginUpdate method.")]
      public void EndUpdate()
      {
         this.redraw = true;
         DoResize();
         Invalidate();
      }
      
      /// &lt;summary&gt;
      /// Renders the control when a new group is being scrolled
      /// into view.
      /// &lt;/summary&gt;
      /// &lt;param name="pe"&gt;The arguments associated with the paint
      /// event.&lt;/param&gt;
      [Description("Renders the control as a new group is being scrolled into
       view")]
      protected virtual void RenderScrollNewGroup(PaintEventArgs pe)
      {
         int lastBar = 0;
         int currentNext = this.groups.Count -1;
         int newNext = this.groups.Count - 1;
         for (int i = 0; i &lt; this.groups.Count; i++)
         {
            if (this.groups[i].Visible)
            {
               if (i &gt; lastBar)
               {
                  lastBar = i;
               }
               if ((i &gt; this.indexCurrent) &amp;&amp; (i &lt; currentNext))
               {
                  currentNext = i;
               }
               if ((i &gt; this.indexNew) &amp;&amp; ( i &lt; newNext))
               {
                  newNext = i;
               }
            }
         }

         ListBarGroup currentBar = this.groups[this.indexCurrent];
         ListBarGroup newBar = this.groups[this.indexNew];

         // get the rectangle for currentBar:
         Rectangle currentBarBounds = new Rectangle(
            currentBar.ButtonLocation,
            new Size(currentBar.ButtonWidth, 0));
         // the height of the current bar rect is the height of the control
         // or the top of the rectangle of the next button along:
         if (this.indexCurrent == lastBar)
         {
            currentBarBounds.Height = this.ClientRectangle.Height -
               currentBarBounds.Top;
         }
         else
         {
            currentBarBounds.Height = this.groups[currentNext].ButtonLocation.Y
             - 
               currentBarBounds.Top;
         }

         // get the rectangle for newBar:
         Rectangle newBarBounds = new Rectangle(
            newBar.ButtonLocation,
            new Size(newBar.ButtonWidth, 0));
         // the height of the new bar is the height of the control or
         // the top of the rectangle of the next bar along:
         if (this.indexNew == lastBar)
         {
            newBarBounds.Height = this.ClientRectangle.Height - 
               newBarBounds.Top;
         }
         else
         {
            newBarBounds.Height = this.groups[newNext].ButtonLocation.Y -
               newBarBounds.Top;
         }
         
         // Draw the current bar contents:
         currentBar.DrawBar(
            pe.Graphics, currentBarBounds, 
            (currentBar.View == ListBarGroupView.LargeIcons ? largeImageList :
             smallImageList),
            this.Font,
            this.drawStyle, 
            this.Enabled);

         // Draw the new bar contents:
         newBar.DrawBar(
            pe.Graphics, newBarBounds, 
            (newBar.View == ListBarGroupView.LargeIcons ? largeImageList :
             smallImageList),
            this.Font,
            this.drawStyle,
            this.Enabled);

         // Draw the buttons:
         foreach (ListBarGroup group in this.groups)
         {
            group.DrawButton(pe.Graphics, this.Font, this.Enabled);
         }

         // Draw the border:
         RenderControlBorder(pe.Graphics);
      }

      /// &lt;summary&gt;
      /// Renders the control given the object passed to a Paint event.
      /// &lt;/summary&gt;
      /// &lt;param name="pe"&gt;The arguments associated with the paint
      /// event.&lt;/param&gt;
      protected virtual void Render(PaintEventArgs pe)
      {
         if (this.redraw)
         {

            // background - does not need to be painted
            // as the control does it itself

            // draw the control elements:
            if (groups.Count &gt; 0)
            {
               // First draw the items in the selected group,
               // if any:
               ListBarGroup selectedGroup = SelectedGroup;
               
               if ((selectedGroup != null) &amp;&amp; (selectedGroup.Visible))
               {
                  // Draw the items in the group:
                  selectedGroup.DrawBar(pe.Graphics, rcListView,
                     ((selectedGroup.View == ListBarGroupView.LargeIcons ||
                       selectedGroup.View == ListBarGroupView.LargeIconsOnly)
                        ? 
                        largeImageList : smallImageList),
                     this.Font,
                     this.drawStyle,
                     this.Enabled);
                  
                  // Render the drag-drop insertion point, if any:
                  RenderDragInsertPoint(pe.Graphics,
                     selectedGroup);               
               }

               // draw the scroll buttons:
               Color defaultBackColor =
                Color.FromKnownColor(KnownColor.Control);
               if (this.drawStyle == ListBarDrawStyle.ListBarDrawStyleNormal)
               {
                  if
                   (!this.BackColor.Equals(Color.FromKnownColor(KnownColor.Contr
                  olDark)))
                  {
                     defaultBackColor = this.BackColor;
                  }
               }
               else if (this.DrawStyle ==
                ListBarDrawStyle.ListBarDrawStyleOfficeXP)
               {
                  defaultBackColor = this.BackColor;
               }

               btnUp.DrawItem(pe.Graphics, defaultBackColor, this.Enabled );
               btnDown.DrawItem(pe.Graphics, defaultBackColor, this.Enabled);

               // Now draw the group buttons, if any:
               foreach (ListBarGroup group in this.groups)
               {
                  if (group.Visible)
                  {
                     group.DrawButton(pe.Graphics, this.Font, this.Enabled);
                  }
               }
            }         

            // border:
            RenderControlBorder(pe.Graphics);
         }
      }

      /// &lt;summary&gt;
      /// Draw a border around the control.  The default
      /// implementation draws a 1 pixel inset border.
      /// &lt;/summary&gt;
      /// &lt;param name="gfx"&gt;The graphics object to drawn onto.&lt;/param&gt;
      protected virtual void RenderControlBorder(
         Graphics gfx)
      {
         // draw the control's border
         Pen darkPen = new Pen(CustomBorderColor.ColorDark(this.BackColor));
         Pen lightPen = new
          Pen(CustomBorderColor.ColorLightLight(this.BackColor));
         gfx.DrawLine(darkPen, 
            this.ClientRectangle.Left, this.ClientRectangle.Bottom -2, 
            this.ClientRectangle.Left, this.ClientRectangle.Top);
         gfx.DrawLine(darkPen, 
            this.ClientRectangle.Left, this.ClientRectangle.Top, 
            this.ClientRectangle.Right -2, this.ClientRectangle.Top);
         gfx.DrawLine(lightPen, 
            this.ClientRectangle.Right - 1, this.ClientRectangle.Top, 
            this.ClientRectangle.Right -1, this.ClientRectangle.Bottom -1);
         gfx.DrawLine(lightPen, 
            this.ClientRectangle.Right - 1, this.ClientRectangle.Bottom - 1, 
            this.ClientRectangle.Left, this.ClientRectangle.Bottom -1);
         darkPen.Dispose();
         lightPen.Dispose();
      }

      /// &lt;summary&gt;
      /// Draws the drag insert point, if any.  The drag insert point is
      /// drawn using the same style as the Windows XP ListView drag
      /// insert point.
      /// 
      /// Note that the Outlook ListBar draws a single pixel drag insert
      /// point rather than a double width one.  I preferred the ListView 
      /// XP style so went with this.  The code can be overridden to
      /// use a single pixel border instead if desired. 
      /// &lt;/summary&gt;
      /// &lt;param name="gfx"&gt;The graphics object to draw onto.&lt;/param&gt;
      /// &lt;param name="selectedGroup"&gt;The currently selected
       ListBarGroup.&lt;/param&gt;
      protected virtual void RenderDragInsertPoint(
         Graphics gfx,
         ListBarGroup selectedGroup
         )
      {
         if (dragInsertPoint != null)
         {            
            ListBarItem itemAfter = dragInsertPoint.ItemAfter;
            ListBarItem itemBefore = dragInsertPoint.ItemBefore;

            int offset = (selectedGroup.View == ListBarGroupView.LargeIcons ? 2
             : 0);

            if (itemAfter != null)
            {
               // Get the bounding rectangle of the item after:
               Rectangle rcItem = new Rectangle(itemAfter.Location, new
                Size(itemAfter.Width, itemAfter.Height));
               // adjust the rectangle so it corresponds to the display:
               rcItem.Offset(0, 
                  selectedGroup.ButtonLocation.Y + selectedGroup.ButtonHeight + 
                  selectedGroup.ScrollOffset);

               // Draw the insertion point line:
               if ((selectedGroup.View == ListBarGroupView.SmallIconsOnly) ||
                (selectedGroup.View == ListBarGroupView.LargeIconsOnly))
               {
                  gfx.DrawLine(SystemPens.WindowText,
                     rcItem.Right, rcItem.Top + 2, 
                     rcItem.Right, rcItem.Bottom - 1);
                  gfx.DrawLine(SystemPens.WindowText,
                     rcItem.Right + 1, rcItem.Top + 2, 
                     rcItem.Right + 1, rcItem.Bottom - 1);

                  // Draw triangles:
                  if (itemBefore != null)
                  {
                     // left triangles:
                     ListBarUtility.FillRightAngleTriangle(gfx,
                      SystemBrushes.WindowText, 
                        new Point(rcItem.Right + 1, rcItem.Top + 2), 5, 5);
                     ListBarUtility.FillRightAngleTriangle(gfx,
                      SystemBrushes.WindowText, 
                        new Point(rcItem.Right + 1, rcItem.Bottom), 5, -6);
                  }

                  // right triangles:
                  ListBarUtility.FillRightAngleTriangle(gfx,
                   SystemBrushes.WindowText, 
                     new Point(rcItem.Right, rcItem.Top + 2), -4, 4);
                  ListBarUtility.FillRightAngleTriangle(gfx,
                   SystemBrushes.WindowText, 
                     new Point(rcItem.Right, rcItem.Bottom), -5, -6);

               }
               else
               {
                  gfx.DrawLine(SystemPens.WindowText,
                     rcItem.Left + 7, rcItem.Bottom + offset, 
                     rcItem.Right - 7, rcItem.Bottom + offset);
                  gfx.DrawLine(SystemPens.WindowText,
                     rcItem.Left + 7, rcItem.Bottom + offset + 1, 
                     rcItem.Right - 7, rcItem.Bottom + offset + 1);

                  // Draw the triangles:
                  if (itemBefore != null)
                  {
                     // below triangles:
                     ListBarUtility.FillRightAngleTriangle(gfx,
                      SystemBrushes.WindowText, 
                        new Point(rcItem.Left + 7, rcItem.Bottom + offset + 1),
                         10, 5);
                     ListBarUtility.FillRightAngleTriangle(gfx,
                      SystemBrushes.WindowText,
                        new Point(rcItem.Right - 6, rcItem.Bottom + offset +
                         1), -10, 5);                     
                  }
                  
                  // above triangles
                  ListBarUtility.FillRightAngleTriangle(gfx,
                   SystemBrushes.WindowText, 
                     new Point(rcItem.Left + 7, rcItem.Bottom + offset), 10,
                      -5);
                  ListBarUtility.FillRightAngleTriangle(gfx,
                   SystemBrushes.WindowText,
                     new Point(rcItem.Right - 6, rcItem.Bottom + offset), -10,
                      -5);

               }
            }
            else
            {
               // before the first item:

               // Get the bounding rectangle of the item after:
               Rectangle rcItem ;
               if (itemBefore != null)
               {
                  rcItem = new Rectangle(itemBefore.Location, new
                   Size(this.Width, itemBefore.Height));
                  // adjust the rectangle so it corresponds to the display:
                  rcItem.Offset(0, 
                     selectedGroup.ButtonLocation.Y +
                      selectedGroup.ButtonHeight + 
                     selectedGroup.ScrollOffset);
               }
               else
               {
                  rcItem = new Rectangle(selectedGroup.ButtonLocation, 
                     new Size(selectedGroup.ButtonWidth,
                      selectedGroup.ButtonHeight));
                  rcItem.Offset(0, selectedGroup.ButtonHeight);
               }

               // draw the insertion point line:
               if ((selectedGroup.View == ListBarGroupView.SmallIconsOnly) ||
                (selectedGroup.View == ListBarGroupView.LargeIconsOnly))
               {
                  gfx.DrawLine(SystemPens.WindowText,
                     rcItem.Left + 1, rcItem.Top + 2, 
                     rcItem.Left + 1, rcItem.Bottom - 1);
                  gfx.DrawLine(SystemPens.WindowText,
                     rcItem.Left + 2, rcItem.Top + 2, 
                     rcItem.Left + 2, rcItem.Bottom - 1);                  

                  // left triangles:
                  ListBarUtility.FillRightAngleTriangle(gfx,
                   SystemBrushes.WindowText, 
                     new Point(rcItem.Left + 2, rcItem.Top + 2), 5, 5);
                  ListBarUtility.FillRightAngleTriangle(gfx,
                   SystemBrushes.WindowText, 
                     new Point(rcItem.Left + 2, rcItem.Bottom), 5, -6);
               }
               else
               {
                  gfx.DrawLine(SystemPens.WindowText,
                     rcItem.Left + 7, rcItem.Top + offset, 
                     rcItem.Right - 7, rcItem.Top + offset);
                  gfx.DrawLine(SystemPens.WindowText,
                     rcItem.Left + 7, rcItem.Top + offset + 1, 
                     rcItem.Right - 7, rcItem.Top + offset + 1);

                  // Now draw the triangles:
                  ListBarUtility.FillRightAngleTriangle(gfx,
                   SystemBrushes.WindowText, 
                     new Point(rcItem.Left + 7, rcItem.Top + offset + 1), 10,
                      5);
                  ListBarUtility.FillRightAngleTriangle(gfx,
                   SystemBrushes.WindowText,
                     new Point(rcItem.Right - 6, rcItem.Top + offset + 1), -10,
                      5);
               }
            }
         }
      }

      /// &lt;summary&gt;
      /// Creates a new instance of the ListBarGroupCollection used by this
      /// control to store the ListBarGroups.  Fired during control 
      /// initialisation.
      /// &lt;/summary&gt;
      /// &lt;returns&gt;A new instance of the ListBarGroupCollection to be used
      /// by the control to store ListBarGroups.&lt;/returns&gt;
      protected virtual ListBarGroupCollection CreateListBarGroupCollection()
      {
         return new ListBarGroupCollection(this);
      }

      /// &lt;summary&gt;
      /// Creates a new instance of a ListBarScrollButton used by this control
      /// to draw the scroll buttons.  Fired during control initialisation
      /// &lt;/summary&gt;
      /// &lt;param name="buttonType"&gt;The type of scroll button (Up or Down)
      /// to create&lt;/param&gt;
      /// &lt;returns&gt;A new ListBarScrollButton which is drawn when a ListBar
      /// contains more items than can be displayed.&lt;/returns&gt;
      protected virtual ListBarScrollButton
       CreateListBarScrollButton(ListBarScrollButton.ListBarScrollButtonType
       buttonType)
      {
         return new ListBarScrollButton(buttonType);
      }

      /// &lt;summary&gt;
      /// Gets/sets how the ListBar control will be drawn.
      /// &lt;/summary&gt;
      [Description("Gets/sets the style used to draw the ListBar control.")]
      public ListBarDrawStyle DrawStyle
      {
         get
         {
            return this.drawStyle;
         }
         set
         {
            this.drawStyle = value;
         }
      }

      /// &lt;summary&gt;
      /// Gets the collection of groups in the ListBar.
      /// &lt;/summary&gt;
      [Description("Gets the collection of groups in the ListBar.")]
      public ListBarGroupCollection Groups
      {
         get
         {
            return this.groups;
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets the tooltip object associated with this control.
      /// The control does not generate its own internal Tooltips
      /// and instead relies on an external ToolTip object to
      /// display tooltips.
      /// &lt;/summary&gt;
      [Description("Gets/sets the tooltip object which will be used to show
       tooltips for groups and items in the control.")]
      public ToolTip ToolTip
      {
         get
         {
            return this.toolTip;
         }
         set
         {
            this.toolTip = value;            
         }
      }
      
      /// &lt;summary&gt;
      /// Gets/sets the large icon ImageList to be used for items 
      /// with the &lt;see cref="ListBarGroupView.LargeIcons"/&gt; and 
      /// &lt;see cref="ListBarGroupView.LargeIconsOnly"/&gt; view.
      /// &lt;/summary&gt;
      [Description("Gets/sets the large icon ImageList to be used for items in
       groups with the LargeIcons or LargeIconsOnly view.")]
      public ImageList LargeImageList
      {
         get
         {
            return this.largeImageList;
         }
         set
         {
            this.largeImageList = value;
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the small icon ImageList to be used for ListBar groups
      /// using the &lt;see cref="ListBarGroupView.SmallIcons"/&gt; or 
      /// &lt;see cref="ListBarGroupView.SmallIconsOnly "/&gt; view.
      /// &lt;/summary&gt;
      [Description("Gets/sets the small icon ImageList to be used for items in
       groups with the SmallIcons or SmallIconsOnly view.")]
      public ImageList SmallImageList
      {
         get
         {
            return this.smallImageList;
         }
         set
         {
            this.smallImageList = value;
         }
      }

      /// &lt;summary&gt;
      /// Returns the currently selected group in the ListBar control,
      /// if any.
      /// &lt;/summary&gt;
      [Description("Gets the currently selected group in the ListBar control.")]
      public virtual ListBarGroup SelectedGroup
      {
         get
         {
            ListBarGroup selGroup = null;
            if (this.groups.Count &gt; 0)
            {
               foreach (ListBarGroup group in this.groups)
               {
                  if (group.Selected)
                  {
                     selGroup = group;
                     break;
                  }
               }               
            }
            return selGroup;
         }
      }
      #endregion 

      #region Component Designer generated code
      /// &lt;summary&gt; 
      /// Required method for Designer support - do not modify 
      /// the contents of this method with the code editor.
      /// &lt;/summary&gt;
      private void InitializeComponent()
      {
         this.txtEdit = new System.Windows.Forms.TextBox();
         this.SuspendLayout();
         // 
         // txtEdit
         // 
         this.txtEdit.BorderStyle =
          System.Windows.Forms.BorderStyle.FixedSingle;
         this.txtEdit.Location = new System.Drawing.Point(60, 92);
         this.txtEdit.Multiline = true;
         this.txtEdit.Name = "txtEdit";
         this.txtEdit.Size = new System.Drawing.Size(80, 44);
         this.txtEdit.TabIndex = 0;
         this.txtEdit.Text = "";
         this.txtEdit.TextAlign =
          System.Windows.Forms.HorizontalAlignment.Center;
         this.txtEdit.Visible = false;
         this.txtEdit.TextChanged += new
          System.EventHandler(this.txtEdit_TextChanged);
         // 
         // ListBar
         // 
         this.Controls.AddRange(new System.Windows.Forms.Control[] {         
                                                        this.txtEdit});
         this.Name = "ListBar";
         this.ResumeLayout(false);

      }
      #endregion

   }   
   #endregion

   #region ListBarGroupCollection class
   /// &lt;summary&gt;
   /// A class to hold the collection of groups in the ListBar control.
   /// &lt;/summary&gt;
   [SerializableAttribute()]
   public class ListBarGroupCollection : CollectionBase, ISerializable
   {
      /// &lt;summary&gt;
      /// The ListBar which owns this collection
      /// &lt;/summary&gt;
      private ListBar owner = null;      

      /// &lt;summary&gt;
      /// Adds a new &lt;see cref="ListBarGroup"/&gt; to the control.
      /// &lt;/summary&gt;
      /// &lt;param name="group"&gt;The group to add to the control&lt;/param&gt;
      /// &lt;returns&gt;The index at which the group was added.&lt;/returns&gt;
      [Description("Adds a new ListBarGroup to the control.")]
      public virtual int Add( ListBarGroup group )
      {
         int ret = this.InnerList.Add(group);
         group.SetOwner(owner);
         return ret;
      }

      /// &lt;summary&gt;
      /// Adds a new &lt;see cref="ListBarGroup"/&gt; with the specified caption to
      /// the control and returns a reference to it.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;The caption for the new ListBarGroup.&lt;/param&gt;
      /// &lt;returns&gt;The ListBarGroup added to the control.&lt;/returns&gt;
      [Description("Adds a new ListBarGroup with the specified caption to the
       control and returns a reference to it.")]
      public virtual ListBarGroup Add ( 
         string caption
         )
      {
         ListBarGroup group = new ListBarGroup(caption);
         this.InnerList.Add(group);
         group.SetOwner(owner);
         return group;
      }

      /// &lt;summary&gt;
      /// Adds a series of &lt;see cref="ListBarGroup"/&gt; objectss based on the
       supplied captions.
      /// &lt;/summary&gt;
      /// &lt;param name="captions"&gt;The array of captions to use when creating
      /// the &lt;see cref="ListBarGroup"/&gt; objects.&lt;/param&gt;
      [Description("Adds a series of ListBarGroups with the specified captions
       to the control.")]
      public virtual void AddRange (
         string[] captions
         )
      {
         foreach(string caption in captions)
         {
            Add(caption);
         }
      }

      /// &lt;summary&gt;
      /// Adds a range of previously defined &lt;see cref="ListBarGroup" /&gt;
       objects.
      /// &lt;/summary&gt;
      /// &lt;param name="values"&gt;The array of ListBarGroups to add
      /// to the control.&lt;/param&gt;
      [Description("Adds a range of previously defined ListBarGroup objects.")]
            
      public virtual void AddRange ( 
         ListBarGroup[] values 
         )
      {
         foreach (ListBarGroup group in values)
         {
            this.InnerList.Add(group);
            group.SetOwner(owner);
         }
      }
      
      /// &lt;summary&gt;
      /// Determines whether a &lt;see cref="ListBarGroup"/&gt; element is contained
       within 
      /// the control's collection of groups.
      /// &lt;/summary&gt;
      /// &lt;param name="group"&gt;The ListBarGroup to check if present.&lt;/param&gt;
      /// &lt;returns&gt;True if the ListBarGroup is contained within the control's
      /// collection, False otherwise.&lt;/returns&gt;
      [Description("Determins whether a ListBarGroup element is contained
       within the control's collection of groups.")]
      public virtual bool Contains ( ListBarGroup group )
      {
         return this.InnerList.Contains(group);
      }

      /// &lt;summary&gt;
      /// Gets the 0-based index of the specified &lt;see cref="ListBarGroup"/&gt;
       within this
      /// collection.
      /// &lt;/summary&gt;
      /// &lt;param name="group"&gt;The group to find the index for.&lt;/param&gt;
      /// &lt;returns&gt;The 0-based index of the group, if found, otherwise -
       1.&lt;/returns&gt;
      [Description("Gets the 0-based index of the specified ListBarGroup within
       this collection.")]
      public virtual int IndexOf ( ListBarGroup group )
      {
         return this.InnerList.IndexOf(group);
      }

      /// &lt;summary&gt;
      /// Inserts a group at the specified 0-based index in the collection
      /// of groups.
      /// &lt;/summary&gt;
      /// &lt;param name="index"&gt;The 0-based index to insert the group at.&lt;/param&gt;
      /// &lt;param name="group"&gt;The ListBarGroup to add.&lt;/param&gt;
      [Description("(Inserts a group at the specified 0-based index in the
       collection of groups.")]
      public virtual void Insert ( int index , ListBarGroup group )
      {
         this.InnerList.Insert(index, group);
         group.SetOwner(owner);
      }
      /// &lt;summary&gt;
      /// Inserts a group immediately before the specified &lt;see
       cref="ListBarGroup"/&gt;.
      /// &lt;/summary&gt;
      /// &lt;param name="groupBefore"&gt;ListBarGroup to insert before.&lt;/param&gt;
      /// &lt;param name="group"&gt;Group to insert.&lt;/param&gt;
      [Description("(Inserts a group immediately before the specified
       ListBarGroup object.")]
      public virtual void InsertBefore( ListBarGroup groupBefore, ListBarGroup
       group)
      {
         this.InnerList.Insert( this.InnerList.IndexOf(groupBefore), group );
         group.SetOwner(owner);
      }
      /// &lt;summary&gt;
      /// Inserts a &lt;see cref="ListBarGroup"/&gt; immediately after the specified
       ListBarGroup.
      /// &lt;/summary&gt;
      /// &lt;param name="groupAfter"&gt;ListBarGroup to insert after.&lt;/param&gt;
      /// &lt;param name="group"&gt;Group to insert.&lt;/param&gt;
      [Description("(Inserts a group immediately after the specified
       ListBarGroup object.")]
      public virtual void InsertAfter( ListBarGroup groupAfter, ListBarGroup
       group)
      {
         int index = this.InnerList.IndexOf(groupAfter);
         if (index == this.InnerList.Count - 1)
         {
            this.Add(group);   
         }
         else
         {
            this.Insert(index + 1, group);
         }
      }


      /// &lt;summary&gt;
      /// Removes the specified &lt;see cref="ListBarGroup"/&gt;.
      /// &lt;/summary&gt;
      /// &lt;param name="group"&gt;The group to remove.&lt;/param&gt;
      [Description("(Removes the specified ListBarGroup object.")]
      public virtual void Remove ( ListBarGroup group )
      {
         this.InnerList.Remove(group);
         NotifyOwner(group, true);
      }

      /// &lt;summary&gt;
      /// Gets the &lt;see cref="ListBarGroup"/&gt; at the specified 0-based index.
      /// &lt;/summary&gt;
      [Description("(Gets the ListBarGroup at the specified 0-based index.")]
      public ListBarGroup this[int index]
      {
         get
         {
            return (ListBarGroup)this.InnerList[index];
         }
      }

      /// &lt;summary&gt;
      /// Gets the &lt;see cref="ListBarGroup"/&gt; with the specified string key.
      /// &lt;/summary&gt;
      [Description("(Gets the ListBarGroup with the specified string key.")]
      public ListBarGroup this[string key]
      {
         get
         {
            ListBarGroup ret = null;
            foreach (ListBarGroup group in this.InnerList)
            {
               if (group.Key.Equals(key))
               {
                  ret = group;
                  break;
               }
            }
            return ret;
         }
      }

      /// &lt;summary&gt;
      /// Notifies the owning ListBar control of any changes to a group.
      /// &lt;/summary&gt;
      /// &lt;param name="group"&gt;The Group which has changed.&lt;/param&gt;
      /// &lt;param name="addRemove"&gt;Whether the control should resize
      /// all groups associated with the ListBar.&lt;/param&gt;
      protected virtual void NotifyOwner(ListBarGroup group, bool addRemove)
      {
         if (this.owner != null)
         {
            this.owner.GroupChanged(group, addRemove);
         }
      }

      /// &lt;summary&gt;
      /// Notifies the control after clearing all groups.
      /// &lt;/summary&gt;
      protected override void OnClearComplete (  )
      {
         NotifyOwner(null, true);
      }
      
      /// &lt;summary&gt;
      /// Notifies the control after inserting a new ListBarGroup.
      /// &lt;/summary&gt;
      protected override void OnInsertComplete ( System.Int32 index ,
       System.Object value )
      {
         NotifyOwner((ListBarGroup)value, true);
      }
      
      /// &lt;summary&gt;
      /// Notifies the control after removing a new ListBarGroup.
      /// &lt;/summary&gt;
      protected override void OnRemoveComplete ( System.Int32 index ,
       System.Object value )
      {
         NotifyOwner(null, true);
      }
      
      /// &lt;summary&gt;
      /// Notifies the control after setting a ListBarGroup to another
       ListBarGroup.
      /// &lt;/summary&gt;
      protected override void OnSetComplete ( System.Int32 index ,
       System.Object oldValue , System.Object newValue )
      {
         NotifyOwner((ListBarGroup)newValue, false);
      }

      /// &lt;summary&gt;
      /// 
      /// TODO: This method has not been implemented yet.
      /// 
      /// Populates a System.Runtime.Serialization.SerializationInfo object
       with the 
      /// data needed to serialize this object.
      /// &lt;/summary&gt;
      /// &lt;param name="info"&gt;The System.Runtime.Serialization.SerializationInfo 
      /// to populate with data.&lt;/param&gt;
      /// &lt;param name="context"&gt;The destination (see 
      /// System.Runtime.Serialization.StreamingContext) for this
       serialization.&lt;/param&gt;
      public virtual void GetObjectData ( 
         SerializationInfo info , 
         StreamingContext context )
      {
         // TODO
      }

      /// &lt;summary&gt;
      /// Enables a deserialized object graph to be associated with a ListBar
      /// control.
      /// &lt;/summary&gt;
      /// &lt;param name="owner"&gt;The ListBar control which will own
      /// this collection of items.&lt;/param&gt;
      public virtual void SetOwner(ListBar owner)
      {
         this.owner = owner;
         foreach (ListBarGroup group in this.InnerList)
         {
            group.SetOwner(owner);
         }
      }

      /// &lt;summary&gt;
      /// 
      /// TODO: This method has not been implemented yet.
      /// 
      /// Constructs this object from a serialized representation.
      /// &lt;/summary&gt;
      /// &lt;param name="info"&gt;The System.Runtime.Serialization.SerializationInfo 
      /// containing the serialized data to build this object from.&lt;/param&gt;
      /// &lt;param name="context"&gt;The destination (see 
      /// System.Runtime.Serialization.StreamingContext) for this
       serialization.&lt;/param&gt;
      public ListBarGroupCollection (
         SerializationInfo info , 
         StreamingContext context )
      {

      }
      
      /// &lt;summary&gt;
      /// Creates a new instance of the ListBarGroup collection and associates
      /// it with the control which owns it.
      /// &lt;/summary&gt;
      /// &lt;param name="owner"&gt;The owning ListBar control.&lt;/param&gt;
      public ListBarGroupCollection(ListBar owner)
      {
         this.owner = owner;
      }      

   }
   #endregion 

   #region ListBarGroup class
   /// &lt;summary&gt;
   /// A &lt;c&gt;ListBarGroup&lt;/c&gt; is a bar within a &lt;see cref="ListBar"/&gt; control.
   /// A bar can either contain items or it can contain a Windows
   /// Forms control.
   /// &lt;/summary&gt;
   [SerializableAttribute()]
   public class ListBarGroup : IMouseObject, ISerializable
   {
      /// &lt;summary&gt;
      /// The owning control.
      /// &lt;/summary&gt;
      private ListBar owner = null;      
      /// &lt;summary&gt;
      /// The caption of the group.
      /// &lt;/summary&gt;
      private string caption = "";
      /// &lt;summary&gt;
      /// Whether the item is selected or not.
      /// &lt;/summary&gt;
      private bool selected = false;
      /// &lt;summary&gt;
      /// The tooltip text for this group.
      /// &lt;/summary&gt;
      private string toolTipText = "";
      /// &lt;summary&gt;
      /// The string key to associate with this item.
      /// &lt;/summary&gt;
      private string key = "";
      /// &lt;summary&gt;
      /// User-defined data to associate with this item.
      /// &lt;/summary&gt;
      private object tag = null;
      /// &lt;summary&gt;
      /// Temporary array to hold the subitems to add to
      /// this group once it's owner has been assigned.
      /// &lt;/summary&gt;
      private ListBarItem[] subItems;
      /// &lt;summary&gt;
      /// The collection of items associated with this 
      /// group.
      /// &lt;/summary&gt;
      private ListBarItemCollection items = null;
      /// &lt;summary&gt;
      /// A child control to display in this bar instead
      /// of the child items.
      /// &lt;/summary&gt;
      private Control childControl = null;
      /// &lt;summary&gt;
      /// Font to render this group with.
      /// &lt;/summary&gt;
      private Font font = null;
      /// &lt;summary&gt;
      /// ForeColor to render this group with.
      /// &lt;/summary&gt;
      private Color foreColor = Color.FromKnownColor(KnownColor.WindowText);
      /// &lt;summary&gt;
      /// BackColor to render this group with.
      /// &lt;/summary&gt;
      private Color backColor = Color.FromKnownColor(KnownColor.Control);
      /// &lt;summary&gt;
      /// Bounding rectangle for this group's button.  The height
      /// is managed by this object but the other members are typically
      /// adjusted by the owning control through the &lt;see
       cref="SetLocationAndWidth"/&gt;
      /// and the &lt;see cref="SetButtonHeight"/&gt; methods.
      /// &lt;/summary&gt;
      protected Rectangle rectangle = new Rectangle(0, 0, 0, 24);
      /// &lt;summary&gt;
      /// The view (LargeIcons or SmallIcons) to use when drawing the items 
      /// in the bar.
      /// &lt;/summary&gt;
      private ListBarGroupView iconSize = ListBarGroupView.LargeIcons;      
      /// &lt;summary&gt;
      /// The scroll 
      /// &lt;/summary&gt;
      private int scrollOffset = 0;
      /// &lt;summary&gt;
      /// Whether the mouse is over the button or not.
      /// &lt;/summary&gt;
      private bool mouseOver = false;
      /// &lt;summary&gt;
      /// Whether the mouse is down on the button or not.
      /// &lt;/summary&gt;
      private bool mouseDown = false;
      /// &lt;summary&gt;
      /// The point at which the mouse was clicked on the group
      /// button.
      /// &lt;/summary&gt;
      private Point mouseDownPoint = new Point(0, 0);
      /// &lt;summary&gt;
      /// Whether the group is visible or not.
      /// &lt;/summary&gt;
      private bool visible = true;

      /// &lt;summary&gt;
      /// Returns a string representation of this &lt;see cref="ListBarGroup"/&gt;.
      /// &lt;/summary&gt;
      /// &lt;returns&gt;A string containing the class name, caption, rectangle
      /// and item count for this group.&lt;/returns&gt;
      [Description("Returns a string representation of this ListBarGroup.")]
      public override string ToString()
      {
         return String.Format("{0} Caption={1} Location={2} Height={3}
          ItemCount={4}",
            this.GetType().FullName, this.caption, this.ButtonLocation,
             this.ButtonHeight, this.items.Count);
      }

      /// &lt;summary&gt;
      /// Returns the selected &lt;see cref="ListBarItem"/&gt; in this Group, if any,
       otherwise null.
      /// &lt;/summary&gt;
      [Description("Returns the selected ListBarItem in this Group, if any,
       otherwise null.")]
      public ListBarItem SelectedItem
      {
         get
         {
            ListBarItem ret = null;
            foreach (ListBarItem item in this.items)
            {
               if (item.Selected)
               {
                  ret = item;
                  break;
               }
            }
            return ret;
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets a &lt;see cref="System.Windows.Forms.Control"/&gt;
      /// which can be displayed within this group.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;
      /// Do not set the child control until this group has
      /// been added to the control.
      /// &lt;/remarks&gt;
      [Description("Gets/sets a Control which is displayed in this group rather
       than items.")]
      public Control ChildControl
      {
         get
         {
            return this.childControl;
         }
         set
         {            
            value.Visible = false;
            this.childControl = value;
            this.childControl.Parent = this.owner;
            NotifyOwner(true);
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the point at which the mouse was clicked on the group
      /// button.
      /// &lt;/summary&gt;
      [Description("Gets/sets the point at which the mouse was clicked on the
       group button.")]
      public Point MouseDownPoint
      {
         get
         {
            return this.mouseDownPoint;
         }
         set
         {
            this.mouseDownPoint = value;
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets whether the mouse is over the group button.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether the mouse is over the group button.")]
      public bool MouseOver
      {
         get
         {
            return this.mouseOver;
         }
         set
         {
            this.mouseOver = (value &amp; this.visible);
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets whether the mouse is down over the group button.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether the mouse is down over the group
       button.")]
      public bool MouseDown
      {
         get
         {
            return this.mouseDown;
         }
         set
         {
            this.mouseDown = (value &amp; this.visible);
         }
      }

      /// &lt;summary&gt;
      /// Called to create a new item collection for this ListBarGroup.
      /// &lt;/summary&gt;
      /// &lt;returns&gt;The ListBarItemCollection that will be used for this
      /// ListBarGroup&lt;/returns&gt;
      protected virtual ListBarItemCollection CreateListBarItemCollection()
      {
         return new ListBarItemCollection(owner);
      }

      /// &lt;summary&gt;
      /// Called to create a new item collection for this ListBarGroup
      /// when the data is being deserialized
      /// &lt;/summary&gt;
      /// &lt;returns&gt;The ListBarItemCollection that will be used for this
      /// ListBarGroup&lt;/returns&gt;
      protected virtual ListBarItemCollection CreateListBarItemCollection(
         SerializationInfo info , 
         StreamingContext context )
      {
         return new ListBarItemCollection(info, context);
      }

      /// &lt;summary&gt;
      /// Internal member holding the negative scrolled 
      /// offset of this bar from the top of the client area
      /// &lt;/summary&gt;
      protected internal int ScrollOffset
      {
         get
         {
            return this.scrollOffset;
         }
         set
         {
            this.scrollOffset = value;
         }
      }
      
      /// &lt;summary&gt;
      /// Gets/sets the which view to show the items within this bar.
      /// &lt;/summary&gt;
      [Description("Gets/sets the which view to show the items within this
       bar.")]
      public ListBarGroupView View
      {
         get
         {
            return this.iconSize;
         }
         set
         {
            if (this.iconSize != value)
            {
               this.iconSize = value;
               SetLocationAndWidth(this.rectangle.Location,
                this.rectangle.Width);
               NotifyOwner(true);
            }
         }
      }

      private void SetItemSize()
      {         
         if (this.items != null)
         {
            foreach (ListBarItem item in this.items)
            {
               this.owner.ItemChanged(item, false);
            }
            NotifyOwner(true);
         }
      }
      /// &lt;summary&gt;
      /// Called to set the height of this group's button by the owning control.
      /// &lt;/summary&gt;
      /// &lt;param name="defaultFont"&gt;The default &lt;see
       cref="System.Drawing.Font"/&gt;
      /// to use when this item does not have a specific font set.&lt;/param&gt;
      [Description("Called to set the height of this group's button by the
       owning control.")]
      public virtual void SetButtonHeight(
         Font defaultFont
         )
      {
         // Select the font we're going to use
         Font drawFont = defaultFont;
         if (this.Font != null)
         {
            drawFont = this.Font;
         }

         // Get the string to measure to determine
         // the item's height
         string measureString = "Xg";
         // Measure the height of an item 
         Bitmap measureBitmap = new Bitmap(30, 30);
         Graphics graphics = Graphics.FromImage(measureBitmap);
         SizeF textSize = graphics.MeasureString(measureString, drawFont);
         graphics.Dispose();
         measureBitmap.Dispose();

         this.rectangle.Height = (int)textSize.Height + 8;
      }


      /// &lt;summary&gt;
      /// Returns the location of the button
      /// which activates this group relative
      /// to the owning control.
      /// &lt;/summary&gt;
      [Description("Returns the location of the button which activates this
       group relative to the owning control.")]
      public virtual Point ButtonLocation
      {
         get
         {
            return this.rectangle.Location;
         }
      }

      /// &lt;summary&gt;
      /// Returns the width of the button
      /// which activates this group.
      /// &lt;/summary&gt;
      [Description("Returns the width of the button which activates this
       group.")]
      public virtual int ButtonWidth
      {
         get
         {
            return this.rectangle.Width;
         }
      }

      /// &lt;summary&gt;
      /// Returns the height of the button
      /// which activates this group.
      /// &lt;/summary&gt;
      [Description("Returns the height of the button which activates this
       group.")]
      public virtual int ButtonHeight
      {
         get
         {
            return this.rectangle.Height;
         }
      }

      /// &lt;summary&gt;
      /// Sets the location and width of the button which
      /// activates this &lt;see cref="ListBarGroup"/&gt;.  This method
      /// is called by internally by the &lt;see cref="ListBar"/&gt; 
      /// which owns this item.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;
      /// This member is not intended to be called from client code.
      /// If you do use it, it is likely that a subsequent operation
      /// on the control or group will replace the values.  If you
      /// need more control over placement, override this class
      /// and build the logic into the override for this method
      /// instead.
      /// &lt;/remarks&gt;
      /// &lt;param name="location"&gt;The new location for the item.&lt;/param&gt;
      /// &lt;param name="width"&gt;The new width of the item.&lt;/param&gt;
      [Description("Sets the location and width of the button which activates
       this group.  This method is called internally by the owning ListBar
       control.")]
      public virtual void SetLocationAndWidth(Point location, int width)
      {
         this.rectangle.Location = location;
         this.rectangle.Width = width;
         if (this.items != null)
         {
            Point itemLocation = new Point(location.X, 0);
            
            Font defaultFont = this.Font;
            if (defaultFont == null)
            {
               if (this.owner == null)
               {
                  defaultFont = System.Windows.Forms.SystemInformation.MenuFont;
               }
               else
               {
                  defaultFont = this.owner.Font;
               }
            }

            Size imageSize = new Size(32, 32);
            if ((this.iconSize == ListBarGroupView.LargeIcons) ||
             (this.iconSize == ListBarGroupView.LargeIconsOnly))
            {
               if (this.owner != null)
               {
                  if (this.owner.LargeImageList != null)
                  {
                     imageSize = this.owner.LargeImageList.ImageSize;
                  }
               }
            }
            else
            {
               imageSize.Width = 16;
               imageSize.Height = 16;
               if (this.owner != null)
               {
                  if (this.owner.SmallImageList != null)
                  {
                     imageSize = this.owner.SmallImageList.ImageSize;
                  }
               }
            }

            if ((this.View == ListBarGroupView.SmallIconsOnly) || (this.View ==
             ListBarGroupView.LargeIconsOnly))
            {
               int itemWidth = imageSize.Width + 16;
               for (int i = 0; i &lt; this.items.Count; i++)
               {
                  ListBarItem item = this.items[i];
                  item.SetSize(this.View, defaultFont, imageSize);
                  item.SetLocationAndWidth(itemLocation, itemWidth);
                  itemLocation.X += item.Width;
                  if (i &lt; this.items.Count - 1)
                  {
                     if ((item.Location.X + this.items[i+1].Width) &gt; width)
                     {
                        itemLocation.X = location.X;
                        itemLocation.Y += item.Height;
                     }
                  }
               }
            }
            else
            {
               if (this.Owner != null)
               {
                  width = this.Owner.Width;
               }

               foreach (ListBarItem item in this.items)
               {
                  item.SetSize(this.iconSize, defaultFont, imageSize);
                  item.SetLocationAndWidth(itemLocation, width);
                  itemLocation.Y += item.Height;
               }
            }
         }
      }
   
      /// &lt;summary&gt;
      /// Draws the items within this &lt;see cref="ListBarGroup"/&gt; onto the
       control.
      /// &lt;/summary&gt;
      /// &lt;param name="gfx"&gt;The &lt;see cref="System.Drawing.Graphics"/&gt; object to
       draw onto.&lt;/param&gt;
      /// &lt;param name="bounds"&gt;The bounding &lt;see
       cref="System.Drawing.Rectangle"/&gt; within which
      /// to draw the items.&lt;/param&gt;
      /// &lt;param name="ils"&gt;The &lt;see cref="System.Windows.Forms.ImageList"/&gt;
       object to use to draw
      /// the bar.&lt;/param&gt;
      /// &lt;param name="defaultFont"&gt;The default &lt;see
       cref="System.Drawing.Font"/&gt; to use.&lt;/param&gt;
      /// &lt;param name="style"&gt;The style to draw the ListBar in.&lt;/param&gt;
      /// &lt;param name="enabled"&gt;Whether the ListBar control is enabled or
       not.&lt;/param&gt;
      [Description("Draws the items within this group bar onto the ListBar
       control.  Called internally by the owning ListBar control.")]
      public virtual void DrawBar(
         Graphics gfx,
         Rectangle bounds,
         ImageList ils,
         Font defaultFont,
         ListBarDrawStyle style,
         bool enabled
         )
      {
         if (this.childControl != null)
         {
            this.childControl.Location = bounds.Location;
            this.childControl.Size = bounds.Size;
         }
         else
         {
            this.Items.Draw(
               gfx, bounds, ils, defaultFont, 
               style, this.View, enabled,
               this.scrollOffset + this.rectangle.Bottom);
         }
      }

      /// &lt;summary&gt;
      /// Draws the button for this group onto the control.
      /// &lt;/summary&gt;
      /// &lt;param name="gfx"&gt;The &lt;see cref="System.Drawing.Graphics"/&gt; object to
       draw onto.&lt;/param&gt;
      /// &lt;param name="defaultFont"&gt;The default &lt;see
       cref="System.Drawing.Font"/&gt; to 
      /// draw with.&lt;/param&gt;
      /// &lt;param name="enabled"&gt;Whether this control is enabled or not.&lt;/param&gt;
      [Description("Draws the button for this group onto the control.")]
      public virtual void DrawButton(
         Graphics gfx,
         Font defaultFont,
         bool enabled
         )
      {
         if (this.visible)
         {
            // Get the font to draw with:
            Font drawFont = this.font;
            if (drawFont  == null)
            {
               drawFont = defaultFont;
            }

            // Fill the item:
            Brush br = new SolidBrush(this.backColor);
            gfx.FillRectangle(br, this.rectangle);
            br.Dispose();

            // Draw the text:
            StringFormat format = new StringFormat(StringFormatFlags.LineLimit
             | StringFormatFlags.NoWrap);
            format.Trimming = StringTrimming.EllipsisCharacter;
            format.Alignment = StringAlignment.Center;
            format.LineAlignment = StringAlignment.Center;
            format.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.Show;
            RectangleF rectF = new RectangleF(rectangle.X, rectangle.Y,
               rectangle.Width, rectangle.Height);
            if (enabled)
            {
               br = new SolidBrush(this.foreColor);
               gfx.DrawString(this.caption, drawFont, br, rectF, format);
               br.Dispose();
            }
            else
            {
               rectF.Offset(1F, 1F);
               br = new
                SolidBrush(CustomBorderColor.ColorLightLight(this.backColor));
               gfx.DrawString(this.caption, drawFont, br, rectF, format);
               br.Dispose();
               rectF.Offset(-1F, -1F);
               br = new SolidBrush(CustomBorderColor.ColorDark(this.backColor));
               gfx.DrawString(this.caption, drawFont, br, rectF, format);
               br.Dispose();
            }
            format.Dispose();

            // Draw the border:
            Pen darkDarkPen = new
             Pen(CustomBorderColor.ColorDarkDark(this.BackColor));
            Pen darkPen = new Pen(CustomBorderColor.ColorDark(this.BackColor));
            Pen lightPen = new
             Pen(CustomBorderColor.ColorLight(this.BackColor));
            Pen lightLightPen = new
             Pen(CustomBorderColor.ColorLightLight(this.BackColor));

            if (this.mouseDown &amp;&amp; this.mouseOver)
            {
               gfx.DrawLine(darkDarkPen, 
                  rectangle.Left, rectangle.Bottom - 2, 
                  rectangle.Left, rectangle.Top);
               gfx.DrawLine(darkDarkPen,
                  rectangle.Left, rectangle.Top,
                  rectangle.Right - 2, rectangle.Top);
               gfx.DrawLine(darkPen, 
                  rectangle.Left + 1, rectangle.Bottom - 3, 
                  rectangle.Left + 1, rectangle.Top + 1);
               gfx.DrawLine(darkPen,
                  rectangle.Left + 1, rectangle.Top + 1,
                  rectangle.Right - 3, rectangle.Top + 1);

               gfx.DrawLine(lightLightPen, 
                  rectangle.Right - 1, rectangle.Top, 
                  rectangle.Right - 1, rectangle.Bottom - 1);
               gfx.DrawLine(lightLightPen, 
                  rectangle.Right - 1, rectangle.Bottom - 1, 
                  rectangle.Left, rectangle.Bottom - 1);
               gfx.DrawLine(lightPen, 
                  rectangle.Right - 2, rectangle.Top + 1, 
                  rectangle.Right - 2, rectangle.Bottom - 2);
               gfx.DrawLine(lightPen, 
                  rectangle.Right - 2, rectangle.Bottom - 2, 
                  rectangle.Left + 1, rectangle.Bottom - 2);               
            }
            else if (this.MouseOver || this.mouseDown)
            {
               gfx.DrawLine(lightLightPen, 
                  rectangle.Left, rectangle.Bottom - 2, 
                  rectangle.Left, rectangle.Top);
               gfx.DrawLine(lightLightPen,
                  rectangle.Left, rectangle.Top,
                  rectangle.Right - 2, rectangle.Top);
               gfx.DrawLine(lightPen, 
                  rectangle.Left + 1, rectangle.Bottom - 3, 
                  rectangle.Left + 1, rectangle.Top + 1);
               gfx.DrawLine(lightPen,
                  rectangle.Left + 1, rectangle.Top + 1,
                  rectangle.Right - 3, rectangle.Top + 1);

               gfx.DrawLine(darkDarkPen, 
                  rectangle.Right - 1, rectangle.Top, 
                  rectangle.Right - 1, rectangle.Bottom - 1);
               gfx.DrawLine(darkDarkPen, 
                  rectangle.Right - 1, rectangle.Bottom - 1, 
                  rectangle.Left, rectangle.Bottom - 1);
               gfx.DrawLine(darkPen, 
                  rectangle.Right - 2, rectangle.Top + 1, 
                  rectangle.Right - 2, rectangle.Bottom - 2);
               gfx.DrawLine(darkPen, 
                  rectangle.Right - 2, rectangle.Bottom - 2, 
                  rectangle.Left + 1, rectangle.Bottom - 2);
            }
            else
            {
               gfx.DrawLine(lightLightPen, 
                  rectangle.Left, rectangle.Bottom - 2, 
                  rectangle.Left, rectangle.Top + 1);
               gfx.DrawLine(lightLightPen,
                  rectangle.Left, rectangle.Top + 1,
                  rectangle.Right - 2, rectangle.Top + 1);
               gfx.DrawLine(darkPen, 
                  rectangle.Right - 1, rectangle.Top + 1, 
                  rectangle.Right - 1, rectangle.Bottom - 1);
               gfx.DrawLine(darkPen, 
                  rectangle.Right - 1, rectangle.Bottom - 1, 
                  rectangle.Left, rectangle.Bottom - 1);
            }

            lightLightPen.Dispose();
            lightPen.Dispose();
            darkPen.Dispose();
            darkDarkPen.Dispose();

         }
      }      

      /// &lt;summary&gt;
      /// Returns the collection of items belonging to this &lt;see
       cref="ListBarGroup" /&gt;.
      /// group.
      /// &lt;/summary&gt;
      [Description("Returns the collection of items belonging to this
       ListBarGroup")]
      public virtual ListBarItemCollection Items
      {
         get
         {
            return this.items;
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets whether this group is visible in the control 
      /// or not.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether this group is visible in the control or
       not.")]
      public virtual bool Visible
      {
         get
         {
            return this.visible;
         }
         set
         {
            this.visible = value;
            NotifyOwner(true);
         }
      }

      
      /// &lt;summary&gt;
      /// Gets/sets the &lt;see cref="System.Drawing.Font"/&gt; to draw the caption
       for this group.
      /// &lt;/summary&gt;
      [Description("Returns the Font used to draw the caption for this group.")]
      public virtual Font Font
      {
         get
         {
            return this.font;
         }
         set
         {
            this.font = value;
            NotifyOwner(true);
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the foreground colour to use when drawing
      /// the button for this group.
      /// &lt;/summary&gt;
      [Description("Gets/sets the foreground colour to use when drawing the
       button for this group.")]
      public virtual Color ForeColor
      {
         get
         {
            return this.foreColor;
         }
         set
         {
            this.foreColor = value;
            NotifyOwner(false);
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the background colour to use when drawing the button for
       this group.
      /// &lt;/summary&gt;
      [Description("Gets/sets the background colour to use when drawing the
       button for this group.")]
      public virtual Color BackColor
      {
         get
         {
            return this.backColor;
         }
         set
         {
            this.backColor = value;
            NotifyOwner(false);
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the caption displayed for this group.
      /// &lt;/summary&gt;
      [Description("Gets/sets the caption displayed for this group.")]
      public virtual string Caption
      {
         get
         {
            return this.caption ;
         }
         set
         {
            this.caption = value;            
            NotifyOwner(false);
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the string key associated with this group.
      /// &lt;/summary&gt;
      [Description("Gets/sets a string key associated with this group.")]
      public virtual string Key
      {
         get
         {
            return this.key;
         }
         set
         {
            this.key = value;
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets the tooltip that will be displayed when the user
      /// hovers over this group's button.
      /// &lt;/summary&gt;
      [Description("Gets/sets the tooltip text that will be displayed when the
       user hovers over this group's button.")]
      public virtual string ToolTipText
      {
         get
         {
            return this.toolTipText ;
         }
         set
         {
            this.toolTipText = value;
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets whether this group is selected or not.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether this group is selected or not.")]
      public virtual bool Selected
      {
         get
         {
            return this.selected;
         }
         set
         {
            if (value != this.selected)
            {
               this.selected = value;            
               if (this.childControl != null)
               {
                  this.childControl.Visible = value;
               }
               NotifyOwner(false);
            }
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets a user-defined object associated with this group.
      /// &lt;/summary&gt;
      [Description("Gets/sets a user-defined object associated with this
       group.")]
      public virtual object Tag
      {
         get
         {
            return this.tag;
         }
         set
         {
            this.tag = value;
         }
      }

      /// &lt;summary&gt;
      /// Starts editing this item.  The &lt;c&gt;BeforeLabelEdit&lt;/c&gt; event will
      /// be fired prior to the text box being made visible.
      /// &lt;/summary&gt;
      /// &lt;exception cref="InvalidOperationException"&gt;If the item is not
      /// part of a ListBar control.&lt;/exception&gt;
      [Description("Starts editing this item and fires the BeforeLabelEdit
       event.")]
      public virtual void StartEdit()
      {
         if (this.owner != null)
         {
            owner.StartGroupEdit(this);
         }
         else
         {
            throw new InvalidOperationException("Owner of this ListBarGroup has
             not been set.");
         }
      }
      /// &lt;summary&gt;
      /// Notifies the owning ListBar control of any changes to a group.
      /// &lt;/summary&gt;
      /// &lt;param name="addRemove"&gt;Whether the control should resize
      /// all groups associated with the ListBar.&lt;/param&gt;
      protected virtual void NotifyOwner(bool addRemove)
      {
         if (owner != null)
         {
            owner.GroupChanged(this, addRemove);
         }
      }

      /// &lt;summary&gt;
      /// Sets the owning control for this Group.  Called automatically
      /// whenever a group is added to the group collection associated with
      /// a ListBar control.
      /// &lt;/summary&gt;
      /// &lt;param name="owner"&gt;The ListBar control which owns this group.&lt;/param&gt;
      protected internal void SetOwner(ListBar owner)
      {
         this.owner = owner;
         if (this.items == null)
         {
            this.items = CreateListBarItemCollection();
         }
         if (this.subItems != null)
         {
            this.items.AddRange(subItems);
            this.subItems = null;
         }
         // Set the size of any items which belong
         // to this bar:
         SetItemSize();

         NotifyOwner(true);
      }
      /// &lt;summary&gt;
      /// Gets the owning ListBar control for this item.
      /// &lt;/summary&gt;
      protected internal ListBar Owner
      {
         get
         {
            return this.owner;
         }
      }

      /// &lt;summary&gt;
      /// Populates a System.Runtime.Serialization.SerializationInfo object
       with the 
      /// data needed to serialize this object.
      /// &lt;/summary&gt;
      /// &lt;param name="info"&gt;The System.Runtime.Serialization.SerializationInfo 
      /// to populate with data.&lt;/param&gt;
      /// &lt;param name="context"&gt;The destination (see 
      /// System.Runtime.Serialization.StreamingContext) for this
       serialization.&lt;/param&gt;
      public virtual void GetObjectData ( 
         SerializationInfo info , 
         StreamingContext context )
      {
         info.AddValue("Font", this.font);
         info.AddValue("ToolTipText", this.toolTipText);
         info.AddValue("Caption", this.caption);
         info.AddValue("ForeColor", this.foreColor);
         info.AddValue("BackColor", this.backColor);
         info.AddValue("Tag", this.tag);
         info.AddValue("Key", this.key);
         info.AddValue("Rectangle", this.rectangle);
         info.AddValue("View", ((int)this.iconSize));
         info.AddValue("Selected", this.selected);
         
         info.AddValue("Items", this.items);
      }

      /// &lt;summary&gt;
      /// Constructs this object from a serialized representation.
      /// &lt;/summary&gt;
      /// &lt;param name="info"&gt;The System.Runtime.Serialization.SerializationInfo 
      /// containing the serialized data to build this object from.&lt;/param&gt;
      /// &lt;param name="context"&gt;The destination (see 
      /// System.Runtime.Serialization.StreamingContext) for this
       serialization.&lt;/param&gt;
      public ListBarGroup (
         SerializationInfo info , 
         StreamingContext context )
      {
         this.font = (Font)info.GetValue("Font", typeof(Font));
         this.toolTipText = info.GetString("ToolTipText");
         this.caption = info.GetString("Caption");
         this.foreColor = (Color)info.GetValue("ForeColor", typeof(Color));
         this.backColor = (Color)info.GetValue("BackColor", typeof(Color));
         this.tag = info.GetValue("Tag", typeof(object));
         this.key = info.GetString("Key");
         this.rectangle = (Rectangle)info.GetValue("Rectangle",
          typeof(Rectangle));
         this.View = (ListBarGroupView)info.GetInt32("View");
         this.selected = info.GetBoolean("Selected");

         this.items = CreateListBarItemCollection(info, context);
         
      }


      /// &lt;summary&gt;
      /// Constructs a new, blank instance of a ListBarGroup.
      /// &lt;/summary&gt;
      public ListBarGroup()
      {         
         // intentionally empty
      }

      /// &lt;summary&gt;
      /// Constructs a new instance of a ListBarGroup with the specified
      /// caption.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;Caption for the group's control button.&lt;/param&gt;
      public ListBarGroup(
         string caption
         ) : this()
      {
         this.caption = caption;
      }
      /// &lt;summary&gt;
      /// Constructs a new instance of a ListBarGroup with the specified
      /// caption and items.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;Caption for the group's control button.&lt;/param&gt;
      /// &lt;param name="subItems"&gt;The array of items to add to the group's
      /// collection of items.&lt;/param&gt;
      public ListBarGroup(
         string caption,
         ListBarItem[] subItems
         ) : this(caption)
      {
         this.subItems = subItems;
      }
      /// &lt;summary&gt;
      /// Constructs a new instance of a ListBarGroup with the specified
      /// caption and tooltip text.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;Caption for the group's control button.&lt;/param&gt;
      /// &lt;param name="toolTipText"&gt;ToolTip text to show when hovering over
      /// the group.&lt;/param&gt;
      public ListBarGroup(
         string caption, 
         string toolTipText
         ) : this(caption)
      {
         this.toolTipText = toolTipText;
      }
      /// &lt;summary&gt;
      /// Constructs a new instance of a ListBarGroup with the specified
      /// caption, tooltip text and user-defined data.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;Caption for the group's control button.&lt;/param&gt;
      /// &lt;param name="toolTipText"&gt;ToolTip text to show when hovering over
      /// the group.&lt;/param&gt;
      /// &lt;param name="tag"&gt;User-defined object data which is associated with
      /// the group.&lt;/param&gt;
      public ListBarGroup(
         string caption, 
         string toolTipText,
         object tag
         ) : this(caption, toolTipText)
      {
         this.tag = tag;
      }

   }
   #endregion

   #region ListBarItemCollection class
   /// &lt;summary&gt;
   /// This class manages a collection of items within a ListBarGroup.
   /// &lt;/summary&gt;
   [SerializableAttribute()]
   public class ListBarItemCollection : CollectionBase, ISerializable
   {
      /// &lt;summary&gt;
      /// The owning ListBar control.
      /// &lt;/summary&gt;
      private ListBar owner = null;

      /// &lt;summary&gt;
      /// Sorts the items in this collection using the specified
      /// comparer.
      /// &lt;/summary&gt;
      /// &lt;param name="comparer"&gt;IComparer implementation specifying
      /// how to sort the objects.&lt;/param&gt;
      [Description("Sorts the items in this collection using the specified
       comparer")]
      public virtual void Sort(IComparer comparer)
      {
         this.InnerList.Sort(comparer);
         owner.ItemChanged(null, true);
      }
      /// &lt;summary&gt;
      /// Sorts the items in this collection using the default comparison
      /// operation (alphabetic).
      /// &lt;/summary&gt;
      [Description("Sorts the items in this collection alphabetically.")]
      public virtual void Sort()
      {
         this.InnerList.Sort();
         owner.ItemChanged(null, true);
      }

      /// &lt;summary&gt;
      /// Draws the items within this collection.
      /// &lt;/summary&gt;
      /// &lt;param name="gfx"&gt;The graphics object to draw onto.&lt;/param&gt;
      /// &lt;param name="bounds"&gt;The bounding rectangle within which
      /// to draw the items.&lt;/param&gt;
      /// &lt;param name="ils"&gt;The ImageList to use when drawing the icons.&lt;/param&gt;
      /// &lt;param name="defaultFont"&gt;The default &lt;see
       cref="System.Drawing.Font"/&gt; to use.&lt;/param&gt;
      /// &lt;param name="style"&gt;The Style to draw the items using.&lt;/param&gt;
      /// &lt;param name="view"&gt;The view to use when drawing the items.&lt;/param&gt;
      /// &lt;param name="enabled"&gt;Whether the owning group is enabled or
       not.&lt;/param&gt;
      /// &lt;param name="scrollOffset"&gt;The scrolled offset at which to start
      /// drawing the items.&lt;/param&gt;            
      public virtual void Draw(
         Graphics gfx,
         Rectangle bounds,
         ImageList ils,
         Font defaultFont,
         ListBarDrawStyle style, 
         ListBarGroupView view,
         bool enabled,
         int scrollOffset
         )
      {
         bool skipDraw = false;
         ListBarItem editItem = this.owner.EditItem;

         gfx.SetClip(bounds);
         foreach (ListBarItem item in this.InnerList)
         {
            skipDraw = false;
            if (editItem != null)
            {
               skipDraw = editItem.Equals(item);
            }
            int itemTop = item.Location.Y;
            itemTop += scrollOffset;
            if (
               ((itemTop &gt;= bounds.Top) &amp;&amp; (itemTop &lt;= bounds.Bottom)) ||
               (((itemTop + item.Height) &lt;= bounds.Bottom) &amp;&amp; ((itemTop +
                item.Height) &gt; bounds.Top))
               )
            {
               item.DrawButton(gfx, ils, defaultFont, 
                  style, view, scrollOffset, enabled, skipDraw);
            }
         }
         gfx.ResetClip();
      }

      /// &lt;summary&gt;
      /// Gets the height of all the items within this collection.
      /// &lt;/summary&gt;
      [Description("Gets the overall height of all the items in the
       collection.")]
      public virtual int Height
      {
         get
         {
            int maxHeight = 0;
            foreach (ListBarItem item in this.InnerList)
            {
               int itemBottom = item.Location.Y + item.Height;
               if (itemBottom &gt; maxHeight)
               {
                  maxHeight = itemBottom;
               }
            }
            return maxHeight;
         }
      }

      /// &lt;summary&gt;
      /// Adds a &lt;see cref="ListBarItem"/&gt; object to the group.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;The ListBarItem to add.&lt;/param&gt;
      [Description("Adds a ListBarItem object to the items in the group.")]
      public virtual void Add(
         ListBarItem item
         )
      {
         this.InnerList.Add(item);
         item.SetOwner(owner);
         EnsureSingleSelection(item);
         NotifyOwner(item, true);
      }

      /// &lt;summary&gt;
      /// Constructs a new &lt;see cref="ListBarItem"/&gt; object using the specified
      /// caption, adds it to the bar and returns it.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;The caption to use for the ListBarItem.&lt;/param&gt;
      /// &lt;returns&gt;The newly added ListBarItem object.&lt;/returns&gt;
      [Description("Constructs a new ListBarItem object and adds it to the
       group.")]
      public virtual ListBarItem Add ( 
         string caption
         )
      {
         ListBarItem item = new ListBarItem(caption);
         this.InnerList.Add(item);
         item.SetOwner(owner);
         NotifyOwner(item, true);
         return item;
      }

      /// &lt;summary&gt;
      /// Constructs a new ListBarItem object using the specified
      /// caption and icon, adds it to the bar and returns it.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;The caption to use for the ListBarItem.&lt;/param&gt;
      /// &lt;param name="iconIndex"&gt;The 0-based index of the icon for the
       ListBarItem
      /// within an ImageList&lt;/param&gt;
      /// &lt;returns&gt;The newly added ListBarItem object.&lt;/returns&gt;
      [Description("Constructs a new ListBarItem object and adds it to the
       group.")]
      public virtual ListBarItem Add ( 
         string caption,
         int iconIndex
         )
      {
         ListBarItem item = new ListBarItem(caption, iconIndex);
         this.InnerList.Add(item);
         item.SetOwner(owner);
         NotifyOwner(item, true);
         return item;
      }

      /// &lt;summary&gt;
      /// Adds a range of &lt;see cref="ListBarItem"/&gt; objects to the bar from an
       array.
      /// &lt;/summary&gt;
      /// &lt;param name="values"&gt;The array of ListBarItem objects to
      /// add.&lt;/param&gt;
      [Description("Adds of range of ListBarItem objects to the bar.")]
      public virtual void AddRange ( 
         ListBarItem[] values 
         )
      {
         foreach (ListBarItem item in values)
         {
            this.InnerList.Add(item);
            item.SetOwner(owner);
         }
         EnsureSingleSelection(this[0]);
         NotifyOwner(values[0], true);
      }

      /// &lt;summary&gt;
      /// Returns &lt;c&gt;true&lt;/c&gt; if the specified &lt;see cref="ListBarItem "/&gt; is
       contained
      /// within this collection, otherwise &lt;c&gt;false&lt;/c&gt;.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;The ListBarItem to check.&lt;/param&gt;
      /// &lt;returns&gt;True if the specified ListBarItem is contained
      /// within this collection, False otherwise.&lt;/returns&gt;
      [Description("Returns true if the specified ListBarItem is found in this
       collection, otherwise false.")]
      public virtual bool Contains ( ListBarItem item )
      {
         return this.InnerList.Contains(item);
      }

      /// &lt;summary&gt;
      /// Returns the 0-based index of the specified item in the
      /// collection if present, -1 otherwise.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;The ListBarItem to check.&lt;/param&gt;
      /// &lt;returns&gt;The 0-based index of the specified item in the
      /// collection if present, -1 otherwise.&lt;/returns&gt;
      [Description("Returns the 0-based index of the specified item in the
       collection")]
      public virtual int IndexOf ( ListBarItem item )
      {
         return this.InnerList.IndexOf(item);
      }

      /// &lt;summary&gt;
      /// Inserts a &lt;see cref="ListBarItem"/&gt; at the specified index in the bar.
      /// &lt;/summary&gt;
      /// &lt;param name="index"&gt;The index to insert at.&lt;/param&gt;
      /// &lt;param name="item"&gt;The ListBarItem to insert.&lt;/param&gt;
      [Description("Inserts a ListBarItem at the specified index in the bar.")]
      public virtual void Insert ( int index , ListBarItem item )
      {
         this.InnerList.Insert(index, item);
         item.SetOwner(this.owner);
         EnsureSingleSelection(item);
         NotifyOwner(item, true);
      }

      /// &lt;summary&gt;
      /// Inserts a &lt;see cref="ListBarItem"/&gt; immediately before the specified
       ListBarItem.
      /// &lt;/summary&gt;
      /// &lt;param name="itemBefore"&gt;ListBarItem to insert before.&lt;/param&gt;
      /// &lt;param name="item"&gt;Item to insert.&lt;/param&gt;
      [Description("Inserts a ListBarItem immediately before the specified
       ListBarItem.")]
      public virtual void InsertBefore( ListBarItem itemBefore, ListBarItem
       item)
      {
         this.InnerList.Insert( this.InnerList.IndexOf(itemBefore), item );
         EnsureSingleSelection(item);
         NotifyOwner(item, true);
      }

      /// &lt;summary&gt;
      /// Inserts a &lt;see cref="ListBarItem"/&gt; immediately after the specified
       ListBarItem.
      /// &lt;/summary&gt;
      /// &lt;param name="itemAfter"&gt;ListBarItem to insert after.&lt;/param&gt;
      /// &lt;param name="item"&gt;Item to insert.&lt;/param&gt;
      [Description("Inserts a ListBarItem immediately after the specified
       ListBarItem.")]
      public virtual void InsertAfter( ListBarItem itemAfter, ListBarItem item)
      {
         int index = this.InnerList.IndexOf(itemAfter);
         if (index == this.InnerList.Count - 1)
         {
            this.Add(item);   
         }
         else
         {
            this.Insert(index + 1, item);
         }
         NotifyOwner(item, true);
      }

      /// &lt;summary&gt;
      /// Removes the specified &lt;see cref="ListBarItem"/&gt; from the collection.
      /// &lt;/summary&gt;
      /// &lt;param name="item"&gt;Item to remove.&lt;/param&gt;
      [Description("Removes the specified ListBarItem from the collection.")]
      public virtual void Remove ( ListBarItem item )
      {
         this.InnerList.Remove(item);
         NotifyOwner(item, true);
      }

      /// &lt;summary&gt;
      /// Gets the &lt;see cref="ListBarItem"/&gt; at the specified 0-based index.
      /// &lt;/summary&gt;
      [Description("Gets the ListBarItem at the specified 0-based index.")]    
        
      public ListBarItem this[int index]
      {
         get
         {
            return (ListBarItem)this.InnerList[index];
         }
      }

      /// &lt;summary&gt;
      /// Gets the &lt;see cref="ListBarItem"/&gt; with the specified key.
      /// &lt;/summary&gt;
      [Description("Gets the ListBarItem at the specified key.")]      
      public ListBarItem this[string key]
      {
         get
         {
            ListBarItem ret = null;
            foreach (ListBarItem item in this.InnerList)
            {
               if (item.Key.Equals(key))
               {
                  ret = item;
                  break;
               }
            }
            return ret;
         }
      }

      private void EnsureSingleSelection(ListBarItem newItem)
      {
         bool foundSelectedItem = false;
         if (newItem.Selected)
         {
            foundSelectedItem = true;
         }

         foreach (ListBarItem item in this.InnerList)
         {
            if (!item.Equals(newItem))
            {
               if (item.Selected)
               {
                  if (foundSelectedItem)
                  {
                     item.Selected = false;
                  }
                  else
                  {
                     foundSelectedItem = true;
                  }
               }
            }
         }
      }


      /// &lt;summary&gt;
      /// Notifies the owner control that the items have been
      /// cleared.
      /// &lt;/summary&gt;
      protected override void OnClearComplete (  )
      {
         NotifyOwner(null, true);
      }
      /// &lt;summary&gt;
      /// Notifies the owner control after an item has been inserted.
      /// &lt;/summary&gt;
      /// &lt;param name="index"&gt;Index of inserting item&lt;/param&gt;
      /// &lt;param name="value"&gt;Item which has been inserted.&lt;/param&gt;
      protected override void OnInsertComplete ( System.Int32 index ,
       System.Object value )
      {
         NotifyOwner((ListBarItem)value, true);
      }
      /// &lt;summary&gt;
      /// Notifies the owner control after an item has been removed.
      /// &lt;/summary&gt;
      /// &lt;param name="index"&gt;Index of inserting item&lt;/param&gt;
      /// &lt;param name="value"&gt;Item which has been inserted.&lt;/param&gt;
      protected override void OnRemoveComplete ( System.Int32 index ,
       System.Object value )
      {
         NotifyOwner((ListBarItem)value, true);
      }
      /// &lt;summary&gt;
      /// Notifies the owner control after an item has been changed using set.
      /// &lt;/summary&gt;
      /// &lt;param name="index"&gt;Index of inserting item&lt;/param&gt;
      /// &lt;param name="oldValue"&gt;Old item which was there.&lt;/param&gt;
      /// &lt;param name="newValue"&gt;New Item which has been set.&lt;/param&gt;
      protected override void OnSetComplete ( System.Int32 index ,
       System.Object oldValue , System.Object newValue )
      {
         NotifyOwner((ListBarItem)newValue, true);
      }

      /// &lt;summary&gt;
      /// Notifies the owning control of a change in this item.
      /// &lt;/summary&gt;
      /// &lt;param name="addRemove"&gt;Set to true if the change
      /// that has been made requires the size of the display
      /// to be recalculated.&lt;/param&gt;
      /// &lt;param name="item"&gt;The Item which has been changed
      /// (or null if the item itm is invalid)&lt;/param&gt;
      protected virtual void NotifyOwner(ListBarItem item, bool addRemove)
      {
         if (owner != null)
         {
            owner.ItemChanged(item, addRemove);
         }
      }

      /// &lt;summary&gt;
      /// 
      /// TODO: This method has not been implemented yet.
      /// 
      /// Populates a System.Runtime.Serialization.SerializationInfo object
       with the 
      /// data needed to serialize this object.
      /// &lt;/summary&gt;
      /// &lt;param name="info"&gt;The System.Runtime.Serialization.SerializationInfo 
      /// to populate with data.&lt;/param&gt;
      /// &lt;param name="context"&gt;The destination (see 
      /// System.Runtime.Serialization.StreamingContext) for this
       serialization.&lt;/param&gt;
      public virtual void GetObjectData ( 
         SerializationInfo info , 
         StreamingContext context )
      {
         //
         // TODO: This method has not been implemented yet.
         // 
      }

      /// &lt;summary&gt;
      /// Enables a deserialized object graph to be associated with a ListBar
      /// control.
      /// &lt;/summary&gt;
      /// &lt;param name="owner"&gt;The ListBar control which will own
      /// this collection of items.&lt;/param&gt;
      public virtual void SetOwner(ListBar owner)
      {
         this.owner = owner;
         foreach (ListBarItem item in this.InnerList)
         {
            item.SetOwner(owner);
         }
      }

      /// &lt;summary&gt;
      /// 
      /// TODO: This method has not been implemented yet.
      /// 
      /// Constructs this object from a serialized representation.
      /// &lt;/summary&gt;
      /// &lt;param name="info"&gt;The System.Runtime.Serialization.SerializationInfo 
      /// containing the serialized data to build this object from.&lt;/param&gt;
      /// &lt;param name="context"&gt;The destination (see 
      /// System.Runtime.Serialization.StreamingContext) for this
       serialization.&lt;/param&gt;
      public ListBarItemCollection (
         SerializationInfo info , 
         StreamingContext context )
      {
         // 
         // TODO: This method has not been implemented yet.
         // 
      }

      /// &lt;summary&gt;
      /// Constructs a new instance of this collection and sets
      /// the owner.  Typically this is performed by the owning ListBar
      /// control.
      /// &lt;/summary&gt;
      /// &lt;param name="owner"&gt;The ListBar which owns this collection&lt;/param&gt;
      public ListBarItemCollection(ListBar owner)
      {
         this.owner = owner;
      }      

   }
   #endregion
   
   #region ListBarItem class
   /// &lt;summary&gt;
   /// A class containing the information describing an Item in the ListBar
   /// control.
   /// &lt;/summary&gt;
   [SerializableAttribute()]
   public class ListBarItem : IComparable, IMouseObject, ISerializable
   {
      private ListBar owner = null;
      private bool selected = false;
      private Font font = null;
      private string toolTipText = "";
      private string caption = "";
      private Color foreColor = Color.FromKnownColor(KnownColor.WindowText);   
         
      private object tag = "";
      private string key = "";
      private int iconIndex;
      /// &lt;summary&gt;
      /// Bounding rectangle for this item, relative to its owning
      /// group.  The members of this are typically adjusted by the 
      /// owning control through the &lt;see cref="SetLocationAndWidth"/&gt;
      /// and the &lt;see cref="SetSize"/&gt; methods.
      /// &lt;/summary&gt;
      protected Rectangle rectangle = new Rectangle(0, 0, 0, 72);
      /// &lt;summary&gt;
      /// The rectangle containing the icon for this item.  Set this 
      /// when overriding the standard drawing mode for an item;
      /// the owning ListBar control uses it for hit-testing.
      /// &lt;/summary&gt;
      protected Rectangle iconRectangle;
      /// &lt;summary&gt;
      /// The rectangle containing the text for this item.  Set this
      /// when overriding the standard drawing mode for an item; 
      /// the owning ListBar control uses it for hit-testing.
      /// &lt;/summary&gt;
      protected Rectangle textRectangle;
      private bool enabled = true;
      private bool mouseOver = false;
      private bool mouseDown = false;
      private Point mouseDownPoint = new Point(0, 0);

      /// &lt;summary&gt;
      /// Returns a string representation of this &lt;see cref="ListBarItem"/&gt;.
      /// &lt;/summary&gt;
      /// &lt;returns&gt;A string containing the class name, caption, icon index,
      /// enabled state and rectangle for this item.&lt;/returns&gt;
      [Description("Returns a string representation of this ListBarItem")]
      public override string ToString()
      {
         return String.Format("{0} Caption={1} IconIndex={2} Enabled={3}
          Location={4} Height={5}",
            this.GetType().FullName, this.caption, this.iconIndex,
             this.enabled, this.Location, this.Height);
      }

      /// &lt;summary&gt;
      /// Gets/sets the point at which the mouse was pressed
      /// on this object.
      /// &lt;/summary&gt;
      [Description("Gets/sets the point at which the mouse was pressed on this
       object.")]
      public Point MouseDownPoint
      {
         get
         {
            return this.mouseDownPoint;
         }
         set
         {
            this.mouseDownPoint = value;
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets whether the mouse is over this item.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether the mouse is over this item.")]
      public bool MouseOver
      {
         get
         {
            return this.mouseOver;
         }
         set
         {
            this.mouseOver = value;
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets whether the mouse is down on this item.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether the mouse is down on this item.")]
      public bool MouseDown
      {
         get
         {
            return this.mouseDown;
         }
         set
         {
            this.mouseDown = (value &amp; this.enabled);
         }
      }

      /// &lt;summary&gt;
      /// Draws this item into the specified graphics object.
      /// &lt;/summary&gt;
      /// &lt;param name="gfx"&gt;The &lt;see cref="System.Drawing.Graphics"/&gt; object to
       draw onto.&lt;/param&gt;
      /// &lt;param name="ils"&gt;The &lt;see cref="System.Windows.Forms.ImageList"/&gt;to
       source icons from.&lt;/param&gt;
      /// &lt;param name="defaultFont"&gt;The default &lt;see
       cref="System.Drawing.Font"/&gt; to use to render
      /// the item.&lt;/param&gt;
      /// &lt;param name="style"&gt;The style (Outlook version) to draw using.&lt;/param&gt;
      /// &lt;param name="view"&gt;The view (large or small icons) to draw
       using.&lt;/param&gt;
      /// &lt;param name="scrollOffset"&gt;The offset of the first item from the 
      /// (0,0) point in the graphics object.&lt;/param&gt;
      /// &lt;param name="controlEnabled"&gt;Whether the control is enabled or
       not.&lt;/param&gt;
      /// &lt;param name="skipDrawText"&gt;Whether to skip drawing text or not
      /// (the item is being edited)&lt;/param&gt; 
      [Description("Draws this item into the specified graphics object")]
      public virtual void DrawButton(
         Graphics gfx, 
         ImageList ils, 
         Font defaultFont,
         ListBarDrawStyle style, 
         ListBarGroupView view,
         int scrollOffset,
         bool controlEnabled,
         bool skipDrawText
         )
      {         

         bool rightToLeft = false;
         Color backColor = Color.FromKnownColor(KnownColor.Control);
         if (this.owner != null)
         {
            backColor = this.owner.BackColor;
            if (this.owner.RightToLeft == RightToLeft.Yes)
            {
               rightToLeft = true;
            }
         }

         // Work out the icon &amp; text rectangles:         
         textRectangle = new Rectangle(this.rectangle.Location,
          this.rectangle.Size);
         textRectangle.Offset(0, scrollOffset);
         if (view == ListBarGroupView.SmallIcons)
         {
            textRectangle.Y += 1;
            textRectangle.Height -= 1;
         }
         iconRectangle = new Rectangle(textRectangle.Location,
          textRectangle.Size);
         
         if (view == ListBarGroupView.SmallIcons)
         {
            if (ils != null)
            {
               if (rightToLeft)
               {
                  iconRectangle.X = iconRectangle.Right - ils.ImageSize.Width -
                   4;
                  iconRectangle.Width = ils.ImageSize.Width;
               }
               else
               {
                  iconRectangle.X += 4;
                  iconRectangle.Width = ils.ImageSize.Width;
                  textRectangle.X += ils.ImageSize.Width + 8;
               }
               textRectangle.Width -= (iconRectangle.Width + 8);
               iconRectangle.Height = ils.ImageSize.Height;
               iconRectangle.Y += (this.rectangle.Height -
                iconRectangle.Height) / 2;
            }
            else
            {
               textRectangle.Inflate(-2,-2);
            }
         }
         else
         {
            if (ils != null)
            {
               iconRectangle.Y += 7;
               iconRectangle.Height = ils.ImageSize.Height;
               iconRectangle.Width = ils.ImageSize.Width;
               iconRectangle.X = iconRectangle.Left + (this.rectangle.Width -
                iconRectangle.Width) / 2;
               
               textRectangle.Y += ils.ImageSize.Height + 11;
               textRectangle.Height -= (ils.ImageSize.Height + 11);
            }
            else
            {
               textRectangle.Inflate(-2,-2);
            }
         }

         // If we're drawing using XP style and the button is
         // hot or down then we draw the background:
         Rectangle rcHighlight = new Rectangle(iconRectangle.Location,
          iconRectangle.Size);               
         rcHighlight.Inflate(2,2);
         if (style == ListBarDrawStyle.ListBarDrawStyleOfficeXP)
         {
            if ((this.enabled &amp;&amp; controlEnabled) &amp;&amp; (this.MouseOver ||
             this.mouseDown))
            {
               Color highlightColor;
               if (this.mouseDown &amp;&amp; this.mouseOver)
               {
                  highlightColor = ListBarUtility.BlendColor(
                     Color.FromKnownColor(KnownColor.Highlight), 
                     Color.FromKnownColor(KnownColor.Window), 
                     224);
               }
               else
               {
                  highlightColor = ListBarUtility.BlendColor(
                     Color.FromKnownColor(KnownColor.Highlight), 
                     Color.FromKnownColor(KnownColor.Window), 
                     128);
               }
               SolidBrush highlight = new SolidBrush(Color.FromArgb(128,
                highlightColor));
               gfx.FillRectangle(highlight, rcHighlight);
               highlight.Dispose();
               gfx.DrawRectangle(SystemPens.Highlight, rcHighlight);
            }
         }

         
         // Draw the icon if necessary:
         if (ils != null)
         {
            if (this.iconIndex &gt;= 0 &amp;&amp; this.iconIndex &lt;= ils.Images.Count)
            {

               int iconX = iconRectangle.X;
               int iconY = iconRectangle.Y;


               if (this.mouseDown &amp;&amp; this.mouseOver)
               {
                  iconX++;
                  iconY++;
               }
               if (this.enabled &amp;&amp; controlEnabled)
               {
                  ils.Draw(gfx, iconRectangle.X + 1, iconRectangle.Y + 1,
                   this.iconIndex);
               }
               else
               {
                  ControlPaint.DrawImageDisabled(gfx,
                   ils.Images[this.iconIndex], iconX, iconY,
                   Color.FromArgb(0,0,0,0));
               }

            }
            else
            {
               // We don't want an exception in a paint event
               Trace.WriteLine(
                  String.Format("Icon {0} doesn't exist in ImageList {1}", 
                  this.iconIndex,
                  ils));
            }
         }
         // We do this to make the hit testing more usable:
         iconRectangle.Inflate(4, 4);

         if (skipDrawText)
         {
            return;
         }

         if ((view == ListBarGroupView.SmallIconsOnly) || (view ==
          ListBarGroupView.LargeIconsOnly))
         {
            textRectangle = new Rectangle(0,0,0,0);
         }
         else
         {

            // Draw the text:
            // Get the font to draw with:
            Font drawFont = this.font;
            if (drawFont  == null)
            {
               if (this.owner != null)
               {
                  drawFont = this.owner.Font;
               }
            }
            if (drawFont == null)
            {
               drawFont = System.Windows.Forms.SystemInformation.MenuFont;
            }
            // Set up format:
            StringFormat format = new StringFormat(StringFormatFlags.LineLimit);
            format.Trimming = StringTrimming.EllipsisCharacter;
            if (view == ListBarGroupView.SmallIcons)
            {            
               format.Alignment = StringAlignment.Near;
               format.LineAlignment = StringAlignment.Center;
               format.FormatFlags = format.FormatFlags |
                StringFormatFlags.NoWrap;
            }
            else
            {
               format.Alignment = StringAlignment.Center;
            }
            format.LineAlignment = StringAlignment.Near;
            format.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.Show;
            // Bounding rectangle:
            RectangleF rectF = new RectangleF(textRectangle.X, textRectangle.Y,
               textRectangle.Width, textRectangle.Height);
            if (view == ListBarGroupView.SmallIcons)
            {
               SizeF textSize = gfx.MeasureString(this.caption, drawFont,
                textRectangle.Width, format);
               rectF.Y += (rectF.Height - textSize.Height) / 2;
               textRectangle.Y += (int)((rectF.Height - textSize.Height) / 2);
               textRectangle.Height = (int)textSize.Height;
            }
            // Color:
            SolidBrush br = new SolidBrush(this.foreColor);
            // Finally...
            if (this.enabled &amp;&amp; controlEnabled)
            {
               gfx.DrawString(this.caption, drawFont, br, rectF, format);
            }
            else
            {
               Brush lightBrush = new
                SolidBrush(CustomBorderColor.ColorLightLight(backColor));
               Brush darkBrush = new
                SolidBrush(CustomBorderColor.ColorDark(backColor));
               rectF.Offset(1F, 1F);
               gfx.DrawString(this.caption, drawFont, lightBrush, rectF,
                format);
               rectF.Offset(-1F, -1F);
               gfx.DrawString(this.caption, drawFont, darkBrush, rectF, format);
               darkBrush.Dispose();
               lightBrush.Dispose();
               /*   
               ControlPaint.DrawStringDisabled(gfx, 
                  this.caption, drawFont, 
                  Color.FromKnownColor(KnownColor.Control), 
                  rectF, format);
               */
            }
            br.Dispose();
            format.Dispose();
         }

         // The border around the item if required:
         if (this.owner.DrawStyle == ListBarDrawStyle.ListBarDrawStyleNormal)
         {   
            if (this.enabled &amp;&amp; controlEnabled)
            {               
               Pen penTopLeft = null;
               Pen penBottomRight = null;
               if ((this.mouseDown) &amp;&amp; (this.mouseDown))
               {
                  // inset 3d border:
                  penTopLeft = SystemPens.ControlDarkDark;
                  penBottomRight = SystemPens.ControlLight;
               }
               else if ((this.mouseOver) || (this.mouseDown))
               {
                  // raised 3d border:
                  penTopLeft = SystemPens.ControlLight;
                  penBottomRight = SystemPens.ControlDarkDark;
               }
               if (penTopLeft != null)
               {
                  gfx.DrawLine(penTopLeft, rcHighlight.Left, rcHighlight.Bottom
                   - 2, 
                     rcHighlight.Left, rcHighlight.Top);
                  gfx.DrawLine(penTopLeft, rcHighlight.Left, rcHighlight.Top,
                     rcHighlight.Right - 2, rcHighlight.Top);
                  gfx.DrawLine(penBottomRight, rcHighlight.Right - 1,
                   rcHighlight.Top,
                     rcHighlight.Right - 1, rcHighlight.Bottom - 1);
                  gfx.DrawLine(penBottomRight, rcHighlight.Right - 1,
                   rcHighlight.Bottom - 1,
                     rcHighlight.Left, rcHighlight.Bottom - 1);
               }
            }
         }

      }

      /// &lt;summary&gt;
      /// Gets/sets whether this item is enabled.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether this item is enabled.")]
      public bool Enabled
      {
         get
         {
            return this.enabled;
         }
         set
         {
            this.enabled = value;
            NotifyOwner(false);
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the foreground colour for this item.
      /// &lt;/summary&gt;
      [Description("Gets/sets the foreground colour for this item.")]
      public Color ForeColor
      {
         get
         {
            return this.foreColor;
         }
         set
         {
            this.foreColor = value;
            NotifyOwner(false);
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the font used for this object.  The default
      /// font is null which means the item renders using the
      /// font of the parent control.
      /// &lt;/summary&gt;
      [Description("Gets/sets the font for this item.")]
      public Font Font
      {
         get
         {
            return this.font;
         }
         set
         {
            this.font = value;
            NotifyOwner(false);
         }
      }

      /// &lt;summary&gt;
      /// Gets the location for this item in the control.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;
      /// The location is relative to the group the 
      /// item belongs to.  Therefore to find the position
      /// relative to the control you need to add the 
      /// bottom position of the button rectangle for the group
      /// and the scroll offset of the item. 
      /// &lt;/remarks&gt;
      [Description("Gets the location of this item in the control.")]
      public virtual Point Location
      {
         get
         {
            return this.rectangle.Location;
         }
      }

      /// &lt;summary&gt;
      /// Gets the height of this item.
      /// &lt;/summary&gt;
      [Description("Gets the height of this item in the control.")]
      public virtual int Height
      {
         get
         {
            return this.rectangle.Height;
         }
      }

      /// &lt;summary&gt;
      /// Gets the width of this item.
      /// &lt;/summary&gt;
      [Description("Gets the width of this item in the control.")]
      public virtual int Width
      {
         get
         {
            return this.rectangle.Width;
         }
      }

      /// &lt;summary&gt;
      /// Returns the rectangle in which the icon is drawn for
      /// this item, relative to the control.
      /// &lt;/summary&gt;
      [Description("Returns the rectangle in which the icon is drawn for this
       item, relative to the control.")]
      public virtual Rectangle IconRectangle
      {
         get
         {
            return this.iconRectangle;
         }
      }

      /// &lt;summary&gt;
      /// Returns the rectangle in which the text is drawn for
      /// this item, relative to the control.
      /// &lt;/summary&gt;
      [Description("Returns the rectangle in which the text is drawn for this
       item, relative to the control.")]
      public virtual Rectangle TextRectangle
      {
         get
         {
            return this.textRectangle;
         }
      }

      /// &lt;summary&gt;
      /// Sets the location and width of this item.  This method
      /// is called by internally by the &lt;see cref="ListBar"/&gt; or
      /// the &lt;see cref="ListBarGroup"/&gt; which owns this item.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;
      /// This member is not intended to be called from client code.
      /// If you do use it, it is likely that a subsequent operation
      /// on the control or group will replace the values.  If you
      /// need more control over placement, override this class
      /// and build the logic into the override for this method
      /// instead.
      /// &lt;/remarks&gt;
      /// &lt;param name="location"&gt;The new location for the item.&lt;/param&gt;
      /// &lt;param name="width"&gt;The new width of the item.&lt;/param&gt;
      [Description("Sets the location and width of this item in the control.
       Called internally by the owning ListBar or group")]
      public virtual void SetLocationAndWidth(Point location, int width)
      {
         this.rectangle.Location = location;
         this.rectangle.Width = width;
      }

      /// &lt;summary&gt;
      /// Called to set the height of the item by the owning control.
      /// &lt;/summary&gt;
      /// &lt;param name="view"&gt;The &lt;see cref="ListBarGroupView"/&gt; in which this
      /// item is being shown.&lt;/param&gt;
      /// &lt;param name="defaultFont"&gt;The default &lt;see
       cref="System.Drawing.Font"/&gt;
      /// to use when this item does not have a specific font set.&lt;/param&gt;
      /// &lt;param name="imageSize"&gt;The size of the images in the ImageList
      /// used to render this view.&lt;/param&gt;      
      [Description("Called to set the height of an item by the owning
       control.")]
      public virtual void SetSize(
         ListBarGroupView view,
         Font defaultFont,
         Size imageSize
         )
      {
         // Select the font we're going to use
         Font drawFont = defaultFont;
         if (this.Font != null)
         {
            drawFont = this.Font;
         }

         // Get the string to measure to determine
         // the item's height
         string measureString = "Xg";
         if (view == ListBarGroupView.LargeIcons)
         {
            // by default we allow for two lines:
            measureString += "\r\nXg";
         }

         // Measure the height of an item 
         Bitmap measureBitmap = new Bitmap(30, 30);
         Graphics graphics = Graphics.FromImage(measureBitmap);
         SizeF textSize = graphics.MeasureString(measureString, drawFont);
         graphics.Dispose();
         measureBitmap.Dispose();

         // Set the height using the text size &amp; the image size
         int height = imageSize.Height;
         if (view == ListBarGroupView.LargeIcons)
         {
            height += (int)textSize.Height;
            height += 12;
         }
         else
         {
            if (textSize.Height &gt; height)
            {
               height = (int)textSize.Height;
            }
            height += 8;
         }
         this.rectangle.Height = height;
      }

      /// &lt;summary&gt;
      /// Compares this object with another object of the same type.
      /// The implementation compares the captions of the items to
      /// allow items to be sorted alphabetically.
      /// &lt;/summary&gt;
      /// &lt;param name="obj"&gt;Another ListBarItem object&lt;/param&gt;
      /// &lt;returns&gt;A 32-bit signed integer that indicates the relative order of
       the comparands.  
      /// The return value has these meanings: 
      /// &amp;lt; 0: This instance is less than obj.  
      /// 0: This instance is equal to obj.  
      /// &amp;gt; 0: This instance is greater than obj. &lt;/returns&gt;
      [Description("Compares this object with another object of the same
       type.")]
      public virtual System.Int32 CompareTo ( System.Object obj )
      {
         return caption.CompareTo(((ListBarItem)obj).Caption);
      }

      /// &lt;summary&gt;
      /// Gets/sets whether this item is "selected" or not.
      /// Only one item in the ListBar control can be selected
      /// at a time.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether this item is selected or not.")]      
      public virtual bool Selected
      {
         get
         {
            return this.selected;
         }
         set
         {
            if (this.selected != value)
            {
               this.selected = value;
               NotifyOwner(false);
            }
         }
      }

      /// &lt;summary&gt;
      /// Ensures that this item can be seen in the owner
      /// control.
      /// &lt;/summary&gt;
      /// &lt;exception cref="InvalidOperationException"&gt;If the item is not
      /// part of a ListBarGroup.&lt;/exception&gt;
      [Description("Ensures that this item can be seen in the owning control.")]
      public virtual void EnsureVisible()
      {
         if (this.owner != null)
         {
            owner.EnsureItemVisible(this);
         }
         else
         {
            throw new InvalidOperationException("Owner of this ListBarItem has
             not been set.");
         }
      }

      /// &lt;summary&gt;
      /// Starts editing this item.  The &lt;c&gt;BeforeLabelEdit&lt;/c&gt; event will
      /// be fired prior to the text box being made visible.
      /// &lt;/summary&gt;
      /// &lt;exception cref="InvalidOperationException"&gt;If the item is not
      /// part of a ListBarGroup or not part of the selected group
      /// in the control.&lt;/exception&gt;
      [Description("Starts editing this item.  The BeforeLabelEdit event will
       be fired prior to editing commencing.")]
      public virtual void StartEdit()
      {
         if (this.owner != null)
         {
            owner.StartItemEdit(this);
         }
         else
         {
            throw new InvalidOperationException("Owner of this ListBarItem has
             not been set.");
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets a user-defined string value which can be used
      /// to look up the item in the collection which owns it.
      /// &lt;/summary&gt;
      [Description("Gets/sets a user-defined string value which can be used to
       look up the item in the collection which owns it.")]
      public virtual string Key
      {
         get
         {
            return this.key;
         }
         set
         {
            this.key = value;
         }
      }
      
      /// &lt;summary&gt;
      /// Gets/sets the tooltip text that will be displayed when
      /// the user hovers over this item.
      /// &lt;/summary&gt;
      [Description("Gets/sets the tooltip text that will be displayed when the
       user hovers over this item.")]
      public virtual string ToolTipText
      {
         get
         {
            return this.toolTipText ;
         }
         set
         {
            this.toolTipText = value;
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the caption displayed for this item.
      /// &lt;/summary&gt;
      [Description("Gets/sets the caption displayed for this item.")]
      public virtual string Caption
      {
         get
         {
            return this.caption ;
         }
         set
         {
            this.caption = value;
            NotifyOwner(false);
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets the 0-based index of an icon in an &lt;see
       cref="System.Windows.Forms.ImageList"/&gt;
      /// displayed with this item.
      /// &lt;/summary&gt;
      [Description("Gets/sets the 0-based index of an icon in an ImageList
       displayed with this item.")]
      public virtual int IconIndex
      {
         get
         {
            return this.iconIndex;
         }
         set
         {
            this.iconIndex = value;
            NotifyOwner(false);
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets an object which can be used to associate
      /// user-defined data with this item.
      /// &lt;/summary&gt;
      [Description("Gets/sets an object which can be used to associate
       user-defined data with this item.")]
      public virtual object Tag
      {
         get
         {
            return this.tag;
         }
         set
         {
            this.tag = value;
         }
      }

      /// &lt;summary&gt;
      /// Notifies the owning control of a change in this item.
      /// &lt;/summary&gt;
      /// &lt;param name="addRemove"&gt;Set to true if the change
      /// that has been made requires the size of the display
      /// to be recalculated.&lt;/param&gt;
      protected virtual void NotifyOwner(bool addRemove)
      {
         if (owner != null)
         {
            owner.ItemChanged(this, addRemove);
         }
      }

      /// &lt;summary&gt;
      /// Gets the owning ListBar control for this item.
      /// &lt;/summary&gt;
      protected internal ListBar Owner
      {
         get
         {
            return this.owner;
         }
      }

      /// &lt;summary&gt;
      /// Sets the owning ListBar control for this item.
      /// &lt;/summary&gt;
      /// &lt;param name="owner"&gt;The owning ListBar control for this item.&lt;/param&gt;
      protected internal void SetOwner(ListBar owner)
      {
         this.owner = owner;         
         NotifyOwner(true);
      }

      /// &lt;summary&gt;
      /// Populates a System.Runtime.Serialization.SerializationInfo object
       with the 
      /// data needed to serialize this object.
      /// &lt;/summary&gt;
      /// &lt;param name="info"&gt;The System.Runtime.Serialization.SerializationInfo 
      /// to populate with data.&lt;/param&gt;
      /// &lt;param name="context"&gt;The destination (see 
      /// System.Runtime.Serialization.StreamingContext) for this
       serialization.&lt;/param&gt;
      public virtual void GetObjectData ( 
         SerializationInfo info , 
         StreamingContext context )
      {
         info.AddValue("Font", this.font);
         info.AddValue("ToolTipText", this.toolTipText);
         info.AddValue("Caption", this.caption);
         info.AddValue("ForeColor", this.foreColor);
         info.AddValue("Tag", this.tag);
         info.AddValue("Key", this.key);
         info.AddValue("IconIndex", this.iconIndex);
         info.AddValue("Rectangle", this.rectangle);
         info.AddValue("Selected", this.selected);
      }

      /// &lt;summary&gt;
      /// Constructs this object from a serialized representation.
      /// &lt;/summary&gt;
      /// &lt;param name="info"&gt;The System.Runtime.Serialization.SerializationInfo 
      /// containing the serialized data to build this object from.&lt;/param&gt;
      /// &lt;param name="context"&gt;The destination (see 
      /// System.Runtime.Serialization.StreamingContext) for this
       serialization.&lt;/param&gt;
      public ListBarItem (
         SerializationInfo info , 
         StreamingContext context )
      {
         this.font = (Font)info.GetValue("Font", typeof(Font));
         this.toolTipText = info.GetString("ToolTipText");
         this.caption = info.GetString("Caption");
         this.foreColor = (Color)info.GetValue("ForeColor", typeof(Color));
         this.tag = info.GetString("Tag");
         this.key = info.GetString("Key");
         this.iconIndex = info.GetInt32("IconIndex");
         this.rectangle = (Rectangle)info.GetValue("Rectangle",
          typeof(Rectangle));
      }

      /// &lt;summary&gt;
      /// Constructs a new, empty instance of a ListBarItem.
      /// &lt;/summary&gt;
      public ListBarItem()
      {         
      }
      /// &lt;summary&gt;
      ///  Constructs a new instance of a ListBarItem, specifying
      ///  the caption to display.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;The caption for this item.&lt;/param&gt;
      public ListBarItem(string caption) : this()
      {
         this.caption = caption;
      }
      /// &lt;summary&gt;
      ///  Constructs a new instance of a ListBarItem, specifying
      ///  the caption and the index of the icon to display.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;The caption for this item.&lt;/param&gt;
      /// &lt;param name="iconIndex"&gt;The 0-based index of the icon
      /// to display&lt;/param&gt;
      public ListBarItem(
            string caption, 
            int iconIndex
         ) : this(caption)
      {
         this.iconIndex = iconIndex;
      }
      /// &lt;summary&gt;
      ///  Constructs a new instance of a ListBarItem, specifying
      ///  the caption, the index of the icon and the 
      ///  tooltip text.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;The caption for this item.&lt;/param&gt;
      /// &lt;param name="iconIndex"&gt;The 0-based index of the icon
      /// to display&lt;/param&gt;
      /// &lt;param name="toolTipText"&gt;The tooltip text to show
      /// when the mouse hovers over this item.&lt;/param&gt;
      public ListBarItem(
         string caption,
         int iconIndex,
         string toolTipText
         ) : this (caption, iconIndex)
      {
         this.toolTipText = toolTipText;
      }
      /// &lt;summary&gt;
      ///  Constructs a new instance of a ListBarItem, specifying
      ///  the caption, the index of the icon, the 
      ///  tooltip text and the tag.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;The caption for this item.&lt;/param&gt;
      /// &lt;param name="iconIndex"&gt;The 0-based index of the icon
      /// to display&lt;/param&gt;
      /// &lt;param name="toolTipText"&gt;The tooltip text to show
      /// when the mouse hovers over this item.&lt;/param&gt;
      /// &lt;param name="tag"&gt;An object which can be used to 
      /// associate user-defined data with the item.&lt;/param&gt;
      public ListBarItem(
         string caption,
         int iconIndex,
         string toolTipText,
         object tag
         ) : this (caption, iconIndex, toolTipText)
      {
         this.tag = tag;
      }
      /// &lt;summary&gt;
      ///  Constructs a new instance of a ListBarItem, specifying
      ///  the caption, the index of the icon, the 
      ///  tooltip text, the tag and the key.
      /// &lt;/summary&gt;
      /// &lt;param name="caption"&gt;The caption for this item.&lt;/param&gt;
      /// &lt;param name="iconIndex"&gt;The 0-based index of the icon
      /// to display&lt;/param&gt;
      /// &lt;param name="toolTipText"&gt;The tooltip text to show
      /// when the mouse hovers over this item.&lt;/param&gt;
      /// &lt;param name="tag"&gt;An object which can be used to 
      /// associate user-defined data with the item.&lt;/param&gt;
      /// &lt;param name="key"&gt;A user-defined string which is 
      /// associated with the item.&lt;/param&gt;
      public ListBarItem(
         string caption,
         int iconIndex,
         string toolTipText,
         object tag,
         string key
         ) : this (caption, iconIndex, toolTipText, tag)
      {
         this.key = key;
      }

   }
   #endregion

   #region ListBarScrollButton class
   /// &lt;summary&gt;
   /// A class which manages the behaviour and data associated with
   /// a scrolling button in the ListBar control.  This class can
   /// be overridden to provide (for example) an alternative rendering
   /// of the button.
   /// &lt;/summary&gt;
   public class ListBarScrollButton : IMouseObject
   {
      /// &lt;summary&gt;
      /// Enumeration of available scroll button types 
      /// for this control.
      /// &lt;/summary&gt;
      public enum ListBarScrollButtonType
      {
         /// &lt;summary&gt;
         /// The scroll button is an up button.
         /// &lt;/summary&gt;
         Up,
         /// &lt;summary&gt;
         /// The scroll button is a down button.
         /// &lt;/summary&gt;
         Down
      }

      /// &lt;summary&gt;
      /// The bounding rectangle for this button
      /// &lt;/summary&gt;
      private Rectangle rectangle = new Rectangle(0, 0,
       SystemInformation.VerticalScrollBarWidth,
       SystemInformation.HorizontalScrollBarHeight);
      /// &lt;summary&gt;
      /// Whether the mouse is down on the button or not
      /// &lt;/summary&gt;
      private bool mouseDown = false;
      /// &lt;summary&gt;
      /// Whether the mouse is over this button or not
      /// &lt;/summary&gt;
      private bool mouseOver = false;
      /// &lt;summary&gt;
      /// The point at which the mouse was pressed on this button.
      /// &lt;/summary&gt;
      private Point mouseDownPoint = new Point(0, 0);
      /// &lt;summary&gt;
      /// Whether this button is visible or not.
      /// &lt;/summary&gt;
      private bool visible = false;
      /// &lt;summary&gt;
      /// The type of scroll button.
      /// &lt;/summary&gt;
      private ListBarScrollButtonType buttonType = ListBarScrollButtonType.Up; 
      /// &lt;summary&gt;
      /// ToolTip Text to display.
      /// &lt;/summary&gt;
      private string toolTipText = "";

      /// &lt;summary&gt;
      /// Gets/sets the tooltip text to display for this button.
      /// &lt;/summary&gt;
      [Description("Gets/sets the tooltip text to display for this button.")]
      public string ToolTipText
      {
         get
         {
            return this.toolTipText;
         }
         set
         {
            this.toolTipText = value;
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets whether this object is visible or not.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether this object is visible or not.")]
      public bool Visible
      {
         get
         {
            return this.visible;
         }
         set
         {
            this.visible = value;
            if (!value)
            {
               this.mouseDown = false;
               this.mouseOver = false;
            }
         }
      }

      /// &lt;summary&gt;
      /// Determines whether the specified point is within the control.
      /// &lt;/summary&gt;
      /// &lt;param name="pt"&gt;The point to test.&lt;/param&gt;
      /// &lt;returns&gt;True if the point is over the button and the button
      /// is visible, false otherwise.&lt;/returns&gt;
      public bool HitTest(Point pt)
      {
         bool hitTest = false;
         if (visible)
         {
            hitTest = this.rectangle.Contains(pt);
         }
         return hitTest;
      }

      /// &lt;summary&gt;
      /// Gets which type of scroll button this is (Up or Down)
      /// &lt;/summary&gt;
      [Description("Gets which type of scroll button this is (Up or Down)")]
      public ListBarScrollButtonType ButtonType
      {
         get
         {
            return this.buttonType;
         }
      }

      /// &lt;summary&gt;
      /// Draws the button onto the specified &lt;see
       cref="System.Drawing.Graphics" /&gt; 
      /// object.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;
      /// Note that this method is called by the owning bar even if the 
      /// the button's &lt;see cref="Visible"/&gt; property is set to &lt;c&gt;False&lt;/c&gt;.
      /// In subclasses of this object this enables the button to       
      /// be shown disabled when it isn't needed, rather than the default
      /// behaviour which is to remove it entirely.
      /// &lt;/remarks&gt;
      /// &lt;param name="gfx"&gt;The &lt;see cref="System.Drawing.Graphics"/&gt; object 
      /// to draw on.&lt;/param&gt;
      /// &lt;param name="defaultBackColor"&gt;The default background
      /// &lt;see cref="System.Drawing.Color"/&gt; to use when drawing
      /// the button.&lt;/param&gt;
      /// &lt;param name="controlEnabled"&gt;Whether the owning control is enabled
      /// or not.&lt;/param&gt;
      public virtual void DrawItem(
         Graphics gfx,
         Color defaultBackColor,
         bool controlEnabled
         )
      {
         if (this.visible)
         {
            if
             (defaultBackColor.Equals(Color.FromKnownColor(KnownColor.Control)))
            {
               // Use the default mechanism:
               ButtonState buttonState = ButtonState.Normal;
               if (controlEnabled)
               {
                  buttonState = ((mouseDown &amp;&amp; mouseOver) ? ButtonState.Pushed
                   : ButtonState.Normal);
               }
               else
               {
                  buttonState = ButtonState.Inactive;
               }
               ControlPaint.DrawScrollButton(gfx, 
                  this.rectangle, 
                  (this.buttonType == ListBarScrollButtonType.Up ?
                   ScrollButton.Up : ScrollButton.Down),
                  buttonState);                  
            }
            else
            {
               // Not as easy when using custom border colours:
               
               // Fill background:
               Brush br = new SolidBrush(defaultBackColor);
               gfx.FillRectangle(br, this.rectangle);
               br.Dispose();

               // Draw the glyph:
               Point centrePoint = new Point(
                  (this.rectangle.Width / 2),
                  (this.rectangle.Height / 2)
                  );
               centrePoint.Offset(this.rectangle.Left + 1, this.rectangle.Top);
               if (mouseDown &amp;&amp; mouseOver)
               {
                  centrePoint.Offset(1, 1);
               }
               int opposite = 0;
               if (this.ButtonType == ListBarScrollButtonType.Up)
               {
                  opposite = -4;
                  centrePoint.Offset(0, 2);
               }
               else
               {
                  opposite = 4;
                  centrePoint.Offset(0, -1);
               }

               if (!controlEnabled)
               {
                  br = new
                   SolidBrush(CustomBorderColor.ColorLightLight(defaultBackColor
                  ));
                  centrePoint.Offset(1, 1);
                  ListBarUtility.FillRightAngleTriangle(
                     gfx, br, centrePoint, 4, opposite);
                  ListBarUtility.FillRightAngleTriangle(
                     gfx, br, centrePoint, -4, opposite);
                  br.Dispose();
                  centrePoint.Offset(-1, -1);
                  br = new
                   SolidBrush(CustomBorderColor.ColorDark(defaultBackColor));
                  ListBarUtility.FillRightAngleTriangle(
                     gfx, br , centrePoint, 4, opposite);
                  ListBarUtility.FillRightAngleTriangle(
                     gfx, br, centrePoint, -4, opposite);
                  br.Dispose();
               }
               else
               {
                  ListBarUtility.FillRightAngleTriangle(
                     gfx, SystemBrushes.WindowText, centrePoint, 4, opposite);
                  ListBarUtility.FillRightAngleTriangle(
                     gfx, SystemBrushes.WindowText, centrePoint, -4, opposite);
               }

               // Draw the border:
               CustomBorderColor.DrawBorder(
                  gfx, this.rectangle, defaultBackColor, true, 
                  (mouseDown &amp;&amp; mouseOver));
            }
         }
      }

      /// &lt;summary&gt;
      /// Gets/sets whether the mouse is down on this object or not.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether the mouse is down on this object or
       not.")]
      public bool MouseDown
      {
         get
         {
            return this.mouseDown;
         }
         set
         {
            this.mouseDown = value;
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets whether the mouse is over this object or not.
      /// &lt;/summary&gt;
      [Description("Gets/sets whether the mouse is over this object or not.")]
      public bool MouseOver
      {
         get
         {
            return this.mouseOver;
         }
         set
         {
            this.mouseOver = value;
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets the point at which the mouse was pressed on
      /// this object.
      /// &lt;/summary&gt;
      [Description("Gets/sets the point at which the mouse was pressed on this
       object.")]
      public Point MouseDownPoint
      {
         get
         {
            return this.mouseDownPoint;
         }
         set
         {
            this.mouseDownPoint = value;
         }
      }

      /// &lt;summary&gt;
      /// Gets the bounding rectangle for this button.
      /// &lt;/summary&gt;
      [Description("Gets the bounding rectangle for this button.")]
      public Rectangle Rectangle
      {
         get
         {
            return this.rectangle;
         }
      }

      /// &lt;summary&gt;
      /// Sets the bounding rectangle for this button.
      /// &lt;/summary&gt;
      /// &lt;param name="rect"&gt;&lt;/param&gt;
      protected internal virtual void SetRectangle(Rectangle rect)
      {
         this.rectangle = rect;
      }

      /// &lt;summary&gt;
      /// Creates a new instance of this class with the specified
      /// button type (Up or Down)
      /// &lt;/summary&gt;
      /// &lt;param name="buttonType"&gt;The scroll button type to create.&lt;/param&gt;
      public ListBarScrollButton(ListBarScrollButtonType buttonType)
      {
         this.buttonType = buttonType;
      }
   }
   #endregion

   #region IMouseObject interface
   /// &lt;summary&gt;
   /// An internal interface specifying the properties and methods which must
   /// be supported by an object in the control which interacts with the
   /// mouse.
   /// TODO: think of a better name for this interface
   /// &lt;/summary&gt;
   internal interface IMouseObject
   {
      /// &lt;summary&gt;
      /// Gets/sets the point at which the mouse button was
      /// pressed.
      /// &lt;/summary&gt;
      Point MouseDownPoint
      {
         get;
         set;
      }
      /// &lt;summary&gt;
      /// Gets/sets the tooltip text for this object.
      /// &lt;/summary&gt;
      string ToolTipText
      {
         get;
         set;
      }
      /// &lt;summary&gt;
      /// Gets/sets whether the mouse is over the object or not.
      /// &lt;/summary&gt;
      bool MouseOver
      {
         get;
         set;
      }
      /// &lt;summary&gt;
      /// Gets/sets whether the mouse was pressed on the object or not.
      /// &lt;/summary&gt;
      bool MouseDown
      {
         get;
         set;
      }
   }
   #endregion

   #region ListBarDragDropInsertPoint class
   /// &lt;summary&gt;
   /// An internal class to manage the drag-drop insert point
   /// within the control.
   /// &lt;/summary&gt;
   internal class ListBarDragDropInsertPoint : IComparable
   {
      /// &lt;summary&gt;
      /// The item before the drag-drop insert point, if any
      /// &lt;/summary&gt;
      private ListBarItem itemBefore;
      /// &lt;summary&gt;
      /// The item after the drag-drop insert point, if any 
      /// &lt;/summary&gt;
      private ListBarItem itemAfter;
      /// &lt;summary&gt;
      /// If we're over an empty bar.
      /// &lt;/summary&gt;
      private bool overEmptyBar;

      /// &lt;summary&gt;
      /// Compares this object with another object of the same type.
      /// This implementation is only really useful for testing equality
      /// &lt;/summary&gt;
      /// &lt;param name="obj"&gt;Another ListBarDragDropInsertPoint object&lt;/param&gt;
      /// &lt;returns&gt;A 32-bit signed integer that indicates the relative order of
       the comparands.  
      /// The return value has these meanings: 
      /// &amp;lt; 0: This instance is less than obj.  
      /// 0: This instance is equal to obj.  
      /// &amp;gt; 0: This instance is greater than obj. &lt;/returns&gt;
      public virtual System.Int32 CompareTo ( System.Object obj )
      {
         int ret = 1;
         ListBarDragDropInsertPoint compare = (ListBarDragDropInsertPoint)obj; 
                 
         if (compare.ItemBefore == this.ItemBefore)
         {
            if (compare.ItemAfter == this.ItemAfter)
            {
               if (compare.OverEmptyBar == this.OverEmptyBar)
               {
                  ret = 0;
               }
            }
         }
         return ret;
      }


      /// &lt;summary&gt;
      /// Returns the item before the drag-drop point, if any.  At least one
      /// of the properties ItemBefore or ItemAfter will return an item.
      /// &lt;/summary&gt;
      public ListBarItem ItemBefore
      {
         get
         {
            return this.itemBefore;
         }
      }
      /// &lt;summary&gt;
      /// Returns the item after the drag-drop point, if any.  At least one
      /// of the properties ItemBefore or ItemAfter will return an item.
      /// &lt;/summary&gt;
      public ListBarItem ItemAfter
      {
         get
         {
            return this.itemAfter;
         }
      }

      /// &lt;summary&gt;
      /// Returns whether the drag point is over an empty bar
      /// or not.
      /// &lt;/summary&gt;
      public bool OverEmptyBar
      {
         get
         {
            return this.overEmptyBar;
         }
      }

      /// &lt;summary&gt;
      ///  Constructs a new instance of this class, setting the items
      ///  before and after the drag-drop insertion point.
      /// &lt;/summary&gt;
      /// &lt;param name="itemBefore"&gt;Item before the drag-drop insertion
      /// point, or null if no item before.&lt;/param&gt;
      /// &lt;param name="itemAfter"&gt;Item after the drag-drop insertion
      /// point, or null if no item after.&lt;/param&gt;
      /// &lt;param name="overEmptyBar"&gt;Whether the drag-drop insertion
      /// point should be displayed in an empty bar.&lt;/param&gt;
      public ListBarDragDropInsertPoint(
         ListBarItem itemBefore,
         ListBarItem itemAfter,
         bool overEmptyBar
         )
      {
         this.itemBefore = itemBefore;
         this.itemAfter = itemAfter;
         this.overEmptyBar = overEmptyBar;
      }
   }
   #endregion

   #region Utility class (static methods)
   /// &lt;summary&gt;
   /// An internal class holding static utility methods for the ListBar
   /// control.
   /// &lt;/summary&gt;
   internal class ListBarUtility   
   {
      /// &lt;summary&gt;
      /// Private constructor - all methods are intended to be static
      /// so you shouldn't be able to create an instance of the class.
      /// &lt;/summary&gt;
      private ListBarUtility()
      {
         // intentionally blank
      }

      /// &lt;summary&gt;
      /// Fills a right-angled triangle using the specified brush.  The
      /// origin of the triangle is taken to be the right-angle corner.
      /// &lt;/summary&gt;
      /// &lt;param name="gfx"&gt;Graphics object to draw onto.&lt;/param&gt;
      /// &lt;param name="brush"&gt;Brush to fill the right-angled triangle
       with.&lt;/param&gt;
      /// &lt;param name="origin"&gt;Location of the right-angle corner of the
       triangle.&lt;/param&gt;
      /// &lt;param name="adjacent"&gt;The length of the adjacent side of the
       triangle.&lt;/param&gt;
      /// &lt;param name="opposite"&gt;The length of the opposite side of the
       triangle.&lt;/param&gt;
      public static void FillRightAngleTriangle(
         Graphics gfx,
         Brush brush,
         Point origin,
         int adjacent,
         int opposite
         )
      {
         GraphicsPath path = new GraphicsPath();
         path.AddLine(origin.X, origin.Y, origin.X + adjacent, origin.Y);
         path.AddLine(origin.X + adjacent, origin.Y, origin.X, origin.Y +
          opposite);
         path.CloseFigure();
         gfx.FillPath(brush, path);         
         path.Dispose();
      }

      /// &lt;summary&gt;
      /// Blends two colours together using the specified alpha amount.
      /// &lt;/summary&gt;
      /// &lt;param name="colorFrom"&gt;Base colour&lt;/param&gt;
      /// &lt;param name="colorTo"&gt;Colour to blend with the base colour.&lt;/param&gt;
      /// &lt;param name="alpha"&gt;Alpha amount to use when blending the
       colours.&lt;/param&gt;
      /// &lt;returns&gt;The blended colour.&lt;/returns&gt;
      public static Color BlendColor(
         Color colorFrom,
         Color colorTo,
         int alpha
         )
      {
         Color retColor =  Color.FromArgb(
            ((colorFrom.R * alpha) / 255) + ((colorTo.R * (255 - alpha)) /
             255), 
            ((colorFrom.G * alpha) / 255) + ((colorTo.G * (255 - alpha)) /
             255), 
            ((colorFrom.B * alpha) / 255) + ((colorTo.B * (255 - alpha)) / 255)
            );
         return retColor;
      }
   }
   #endregion

}
</pre><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<noscript>
<A HREF="..\..\..\..\..\vb\code\libraries\compression\index.html" ><IMG SRC="..\..\..\..\..\res\compress.png" ALT="Create and read Zip files and compress your data using Zlib" WIDTH=468 HEIGHT=60 BORDER=0></A>
</noscript>

</p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">Controls</a>&#160;.&#160;<a href="..\index.html">ListBar</a>&#160;.&#160;<a href="article.html">.NET Outlook Style ListBar Control</a>&#160;.&#160;<a href="listbar_control_source.html">ListBar Control Source</a>&#160;.&#160;ListBar.cs</p><br /><p class="nav"><a href="..\..\..\..\..\the_site\copyright\article.html">Copyright</a> &#169; 2003 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 7 November 2003</p></td><td></td></tr></table>
</body></html>