<html lang="en" >
<head>

<title>vbAccelerator - Creating and Modifying Shortcuts</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="This article provides a .NET class wrapper around the ShellLink object
which enables you to read, create and modify Shortcuts under any version of
Windows.  As a bonus, you also get an Icon Picker implementation which
demonstrates how to extract all the Windows icon resources from any executable
or DLL file in small or large sizes." /><link rel="stylesheet" href="..\..\..\..\..\res\screen.css" media="SCREEN" /><link rel="stylesheet" href="..\..\..\..\..\res\print.css" media="PRINT" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><td colspan="3">
<!-- TF 468x60 JScript HORIZ NoPop code -->
<script language=javascript><!--
document.write('<scr'+'ipt language=javascript src="http://a.tribalfusion.com/j.ad?site=VBAcceleratorcom&adSpace=ROS&size=468x60&type=horiz&pop=0&requestID='+((new Date()).getTime() % 2147483648) + Math.random()+'"></scr'+'ipt>');
//-->
</script>
<noscript>
   <a href="javascript:window.alert(&quot;http://a.tribalfusion.com/i.click?site=VBAcceleratorcom&adSpace=ROS&size=468x60&requestID=1423477941\nThis link was not retrieved.&quot;)" target=_blank>
   <img src="http://cdn5.tribalfusion.com/media/493786.gif" 
                  width=468 height=60 border=0 alt="Click Here"></a>
</noscript>
<!-- TF 468x60 JScript HORIZ NoPop code -->
</td></tr><tr class="navbar"><td><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">Libraries</a>&#160;.&#160;<a href="..\index.html">Shell Projects</a>&#160;.&#160;Creating and Modifying Shortcuts</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="..\..\..\..\..\res\download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="shelllink_code.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />ShellLink Code</a> (59K)</p><br /><br /><img src="..\..\..\..\..\res\information.png" width="125" height="21" alt="Information" /><p class="nav">Article:4301</p><p class="nav">&#160;&#160;<a href="..\..\..\..\..\..\linkto_asp\id=4301&type=article&title=creating_20and_20modifying_20shortcuts.html">Link to this page</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;.NET</p><p class="nav">&#160;&#160;C#</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="..\..\..\..\..\res\bugtrak.png" width="125" height="21" alt="BugTrak System" /><p class="nav">No logged bugs.</p><br /><br /><img src="..\..\..\..\..\res\updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="..\..\..\..\..\res\update.png" width="8" height="8" alt="Update" />8 Mar 2003<br />First Posted</p><br /><br /><img src="..\..\..\..\..\res\related.png" width="125" height="21" alt="Related Items" /><p class="nav"><img src="..\..\..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\auto-file_completion_for_text_boxes_and_combo_boxes\article.html">Auto-File and URL Completion for Text Boxes and Combo Boxes</a></p><p class="nav"><img src="..\..\..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\getting_file_icons_using_the_shell\article.html">Getting File Icons Using The Shell</a></p><br /><br /><img src="..\..\..\..\..\res\search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="javascript:window.alert(&quot;http://www.google.com/search\nThis link was not retrieved.&quot;)"><img src="..\..\..\..\..\..\..\www_google_com\logos\logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="..\..\..\..\..\the_site\newsite\article.html"><img src="..\..\..\..\..\res\newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>Creating and Modifying Shortcuts</h1><p class="splash">Use COM Interop for complete control</p><img src="shortcut.png" width="249" height="254" alt="Shortcut Sample &#xD;&#xA;            Application" /><p /><p>This article provides a .NET class wrapper around the <i>ShellLink</i> object
which enables you to read, create and modify Shortcuts under any version of
Windows.  As a bonus, you also get an Icon Picker implementation which
demonstrates how to extract all the Windows icon resources from any executable
or DLL file in small or large sizes.</p><h2>Using the ShellLink Class</h2><p>A shortcut in Windows has a number of properties, most of which are
optional:</p><ul><li><strong>The shortcut's Target</strong><br />
This is the file or Shell object to launch when the shortcut is opened and is 
the only required property.</li><li><strong>The icon to display</strong><br />
There are two ways to specify the icon.  Firstly, if nothing is specified,
Windows display's the target's default icon.  Otherwise, you can specify either
a .ICO file or the index of an icon resource within a Windows EXE or DLL.</li><li><strong>Target Arguments</strong><br />
Any arguments are passed to the target when it is started, for example, a
Shortcut could have a target of Notepad.exe and a arguments containing a file to
open.</li><li><strong>Working Directory</strong><br />
The directory to change to for the any new process started using the 
shortcut.</li><li><strong>Shortcut Description</strong><br />
The description can be displayed in the Comments column of Explorer's
Details view or as an InfoTip when the user hovers over the shortcut.</li><li><strong>Open State</strong><br />
This specifies whether to open the object in a normal, minimised or maximised
Window.</li><li><strong>Hot Key</strong><br />
Specifies a key combination which will open the shortcut from anywhere in
Windows.  This is typically used with icons on the desktop.</li></ul><p>The ShellLink object provided with the download provides a straightforward
wrapper around these properties.  Once you've created an instance of the object,
you can use the <i>Open</i> method to read an existing shortcut if you want
to modify one.  The <i>Target</i>, <i>IconPath</i> and <i>IconIndex</i>,
<i>Arguments</i>, <i>WorkingDirectory</i>, <i>Description</i>,
<i>DisplayMode</i> and <i>HotKey</i> properties then provide read/write access
to the shortcut's details.  To get the small or large icon associated with
the shortcut, use the <i>SmallIcon</i> and <i>LargeIcon</i> and  properties.
Finally, the <i>Save</i> method allows the shortcut to be, erm, saved.</p><p>If you try the sample, you'll see it also provides a .NET version of the
Windows Change Icon dialog.  Rather than use the undocumented Shell export
to call the built in Windows dialog, this has been implemented from scratch,
and includes code demonstrating how to extract large and small Win32 icon
resources from executables, libraries and icon files as well as building a
multi-column icon ListBox.</p><h2>In Detail</h2><p>The <i>ShellLink</i> object is currently only available from the Shell using
a COM object.  This involves the following objects:</p><ul><li><strong>IPersistFile</strong><br />
This interface is used for reading and saving shortcuts to files (note that
it in turn implements the otherwise fairly useless <i>IPersist</i>
interface.</li><li><strong>IShellLink</strong><br />
This interface provides all of the methods for accessing a Shell Link's
properties and a helper method for reading shortcut files.  Note that
there are two versions of this interface: an ANSI one for Win9x systems
and a Unicode one for NT and above.</li><li><strong>ShellLink</strong><br />
This class, provided by the Shell, provides the concrete implementation of
the <i>IShellLink</i> and <i>IPersistFile</i> interfaces.</li></ul><p>I'll cover how to create the Interop for each of these objects first,
then move onto using these in a real class.</p><h2>1. Implementing the ShellLink Interfaces</h2><p>The first step in implementing a ShellLink object is therefore to
provide COM Interop structures for each of the interfaces.   Whilst the
code itself provides versions for both the ANSI and Unicode interfaces,
here I'll concentrate on the Unicode interface.</p><h3>1.1 IShellLink Interface</h3><p>You will find the definition of the IShellLink interface as IDL in the
Platform SDK file <i>ShObjIdl.idl</i>.  Unsurprisingly, IDL is fairly closely
related to the language you use to describe COM Interop Interfaces in .NET,
so you simply start by pasting the whole lot directly in.  Then you need to
modify it a little and start "decorating" the code with attributes.
(Well, the documentation describes it as decoration; if your idea of
decoration is to drop a large pile of rubbish in every corner of the room then
its about right).  In general these tips help greatly in the translation:</p><ul><li>Pass structures as <i>ref</i></li><li>The <i>[in, out]</i> IDL specification is equivalent to <i>ref</i>
for a parameter.  There is no direct equivalent to <i>[in]</i> - just
remove it and make sure you don't specify <i>out</i> or <i>ref</i>.</li><li>Strings that are passed to an interface typically require their type to
be specified using the <i>MarshalAs</i> attribute.  For Unicode strings, use
the LPWStr type, for ANSI use LPStr and for automatic platform-dependent
types use LPTStr.</li><li>Strings returned to an interface should be passed as 
<i>StringBuilder</i> objects.  Use the <i>Out()</i> attribute to specify that
the data is returned and the <i>MarshalAs</i> attribute to specifying the
correct string type (again, this is generally LPWStr for Unicode, LPStr for ANSI
or LPTStr for an auto- platform dependent string type). The <i>StringBuilder</i>
will need to be initialised to an appropriate size prior to calling the
interface's method.</li><li>Use the <i>IntPtr</i> type for handles and pointers.</li><li>COM methods always return a <i>HRESULT</i> which includes both the
result of the method and any error code.  If you want to be able to
read the <i>HRESULT</i> then use the <i>PreserveSig</i> attribute on
the method and declare it as a function with result type as <i>int</i>
or <i>uint</i>, otherwise declare the method as <i>void</i>.</li></ul><pre>
      [ComImportAttribute()]
      [GuidAttribute("000214F9-0000-0000-C000-000000000046")]
      [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
      private interface IShellLinkW
      {
         //[helpstring("Retrieves the path and filename of
            // a shell link object")]
         void GetPath(
            [Out(), MarshalAs(UnmanagedType.LPWStr)]
                StringBuilder pszFile,
            int cchMaxPath,
            ref _WIN32_FIND_DATAW pfd,
            uint fFlags);

         //[helpstring("Retrieves the list of shell link
            // item identifiers")]
         void GetIDList(out IntPtr ppidl);

         //[helpstring("Sets the list of shell link
            // item identifiers")]
         void SetIDList(IntPtr pidl);

         //[helpstring("Retrieves the shell link
            // description string")]
         void GetDescription(
            [Out(), MarshalAs(UnmanagedType.LPWStr)]
                StringBuilder pszFile,
            int cchMaxName);

         //[helpstring("Sets the shell link description string")]
         void SetDescription(
            [MarshalAs(UnmanagedType.LPWStr)] string pszName);

         //[helpstring("Retrieves the name of the shell link
            // working directory")]
         void GetWorkingDirectory(
            [Out(), MarshalAs(UnmanagedType.LPWStr)]
                StringBuilder pszDir,
            int cchMaxPath);

         //[helpstring("Sets the name of the shell link
            // working directory")]
         void SetWorkingDirectory(
            [MarshalAs(UnmanagedType.LPWStr)] string pszDir);

         //[helpstring("Retrieves the shell link
            // command-line arguments")]
         void GetArguments(
            [Out(), MarshalAs(UnmanagedType.LPWStr)]
                StringBuilder pszArgs,
            int cchMaxPath);

         //[helpstring("Sets the shell link command-line
            // arguments")]
         void SetArguments(
            [MarshalAs(UnmanagedType.LPWStr)] string pszArgs);

         //[propget, helpstring("Retrieves or sets the
            // shell link hot key")]
         void GetHotkey(out short pwHotkey);
         //[propput, helpstring("Retrieves or sets the
            // shell link hot key")]
         void SetHotkey(short pwHotkey);

         //[propget, helpstring("Retrieves or sets the shell
            // link show command")]
         void GetShowCmd(out uint piShowCmd);
         //[propput, helpstring("Retrieves or sets the shell 
            // link show command")]
         void SetShowCmd(uint piShowCmd);

         //[helpstring("Retrieves the location (path and index) 
            // of the shell link icon")]
         void GetIconLocation(
            [Out(), MarshalAs(UnmanagedType.LPWStr)] 
                StringBuilder pszIconPath,
            int cchIconPath,
            out int piIcon);

         //[helpstring("Sets the location (path and index) 
            // of the shell link icon")]
         void SetIconLocation(
            [MarshalAs(UnmanagedType.LPWStr)] string pszIconPath,
            int iIcon);

         //[helpstring("Sets the shell link relative path")]
         void SetRelativePath(
            [MarshalAs(UnmanagedType.LPWStr)] 
                string pszPathRel,
            uint dwReserved);

         //[helpstring("Resolves a shell link. The system
            // searches for the shell link object and updates 
            // the shell link path and its list of 
            // identifiers (if necessary)")]
         void Resolve(
            IntPtr hWnd,
            uint fFlags);

         //[helpstring("Sets the shell link path and filename")]
         void SetPath(
            [MarshalAs(UnmanagedType.LPWStr)]
                string pszFile);
      }
</pre><h3>1.2 CShellLink</h3><p>The concrete Shell Link object can be found in the <i>ShlGuid.h</i> file
of the Platform SDK. Search for <i>CLSID_ShellLink</i> to find it.</p><pre>
    [GuidAttribute("00021401-0000-0000-C000-000000000046")]
    [ClassInterfaceAttribute(ClassInterfaceType.None)]
    [ComImportAttribute()]
    private class CShellLink{}
</pre><h3>1.3 Structures Used by IShellLink</h3><p>The <i>GetPath</i> method of IShellLink requires a <i>_WIN32_FIND_DATA</i>
object.  This object can be found in the <i>WinBase.h</i> Platform SDK file.
Note the following tips for translating structures:</p><ul><li>Use the <i>StructLayoutAttribute</i> to specify how the structure
members should be packed in memory (in this case 4 bytes), the <i>LayoutKind</i>
and optionally the <i>CharSet</i> of the structure.</li><li>Arrays of characters should be passed as strings, using the <i>MarshallAs</i>
attribute to specify the type of string and the <i>SizeConst</i> of the
character array.</li></ul><pre>
      [StructLayoutAttribute(LayoutKind.Sequential,
          Pack=4, Size=0, CharSet=CharSet.Unicode)]
      private struct _WIN32_FIND_DATAW
      {
         public uint dwFileAttributes;
         public _FILETIME ftCreationTime;
         public _FILETIME ftLastAccessTime;
         public _FILETIME ftLastWriteTime;
         public uint nFileSizeHigh;
         public uint nFileSizeLow;
         public uint dwReserved0;
         public uint dwReserved1;
         [MarshalAs(UnmanagedType.ByValTStr , SizeConst = 260)]
         public string cFileName;
         [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 14)]
         public string cAlternateFileName;
      }

      [StructLayoutAttribute(LayoutKind.Sequential,
          Pack=4, Size=0)]
      private struct _FILETIME
      {
         public uint dwLowDateTime;
         public uint dwHighDateTime;
      }
</pre><h3>1.4 IPersistFile</h3><p>In order to load or save shortcuts, you need to access the concrete 
ShellLink implementation of <i>IPersistFile</i>.
The <i>IPersistFile</i> and <i>IPersist</i> interfaces can be found in
the <i>ObjIdl.Idl</i> file.  In the Platform SDK <i>IPersistFile</i> is
declared like this:</p><pre>
[
    object,
    uuid(0000010b-0000-0000-C000-000000000046),
    pointer_default(unique)
]
interface IPersistFile : IPersist
{
  // interface here
}
</pre><p>What you'd like to write in .NET is something like this:</p><pre>
   [GuidAttribute("0000010B-0000-0000-C000-000000000046")]
   [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
   private interface IPersistFile : IPersist
   {
      // interface here
   }
</pre><p>However, this doesn't work.  There isn't a way of modifying the
<i>InterfaceTypeAttribute</i> attribute to do this either that I can see, as
it only allows you to specify whether you're using <i>IUnknown</i>,
<i>IDispatch</i> or <i>Dual</i> COM interfaces.  Perhaps there is a way?
<a href="mailto:steve@vbaccelerator.com?subject=IPersistFile%20and%20IPersist">Let
me know!</a></p><p>In any case, you can work around this,
by moving the single <i>IPersist</i> interface member into <i>IPersistFile</i>
prior to any of the <i>IPersistFile</i> members.</p><pre>
      [ComImportAttribute()]
      [GuidAttribute("0000010B-0000-0000-C000-000000000046")]
      [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
      private interface IPersistFile
      {
         // can't get this to go if I extend IPersist, 
         // so put it here:
         [PreserveSig]
         int GetClassID(out Guid pClassID);

         //[helpstring("Checks for changes since
         // last file write")]
         [PreserveSig]
         int IsDirty();

         //[helpstring("Opens the specified file and
         // initializes the object from its contents")]
         void Load(
            [MarshalAs(UnmanagedType.LPWStr)] string pszFileName,
            uint dwMode);

         //[helpstring("Saves the object into 
         // the specified file")]
         void Save(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszFileName,
            [MarshalAs(UnmanagedType.Bool)] 
            bool fRemember);

         //[helpstring("Notifies the object that save
         // is completed")]
         void SaveCompleted(
            [MarshalAs(UnmanagedType.LPWStr)]
            string pszFileName);

         //[helpstring("Gets the current name of the 
         // file associated with the object")]
         void GetCurFile(
            [MarshalAs(UnmanagedType.LPWStr)]
            out string ppszFileName);
      }
</pre><h2>2. Using the COM Interop Objects</h2><p>The first thing to do to use these objects is to create a new instance of
the implementation of the class, which you then cast to the <i>IShellLink</i>
interface for use:</p><pre>
   private IShellLink link = null;

   public ShellLink()
   {
       link = (IShellLink)new CShellLink();
   }
</pre><p>Once you have that then most other things are pretty straightforward, so
I'll just look at opening existing links,  reading one of the string
parameters and playing around with Icons as examples:</p><h3>2.1 Opening Existing Links</h3><p>To open a link, you need to call the <i>Load</i> method of the link's
<i>IPersistFile</i> interface to specify the filename and then call the
<i>IShellLink</i>'s <i>Resolve</i> method, which checks whether the
Target of the link has moved and if it has, offers options to find
it again.  Resolve flags are as specified in the code, however,
basically they allow you go specify whether a UI is shown asking the
user if they want to search for the shortcut or not, and how to go
about searching. Incidentally, on Windows ME the UI always
shows up unless the hWnd specified to the <i>Resolve</i> method 
is also zero.</p><pre>
      public void Open(
         string linkFile,
         IntPtr hWnd,
         EShellLinkResolveFlags resolveFlags,
         ushort timeOut
         )
      {
         uint flags;

         if ((resolveFlags &amp; EShellLinkResolveFlags.SLR_NO_UI) ==
            EShellLinkResolveFlags.SLR_NO_UI)
         {
            flags = (uint)((int)resolveFlags | (timeOut &lt;&lt; 16));
         }
         else
         {
            flags = (uint)resolveFlags;
         }

         // Get the IPersistFile interface and call Load:
         ((IPersistFile)link).Load(linkFile, 0);
         // Resolve the link:
         link.Resolve(hWnd, flags);
      }
</pre><h3>2.2 Getting String Parameters From the Interface</h3><p>Since the <i>out</i> string parameters are actually marshalled as
<i>StringBuilder</i> objects, you need to first initialise a
<i>StringBuilder</i> to a suitable size prior to calling the method.  Here
is the sample Get/Set for the <i>Arguments</i> of the Shortcut:</p><pre>
      /// &lt;summary&gt;
      /// Gets/sets any command line arguments associated with the link
      /// &lt;/summary&gt;
      public string Arguments
      {
         get
         {
            StringBuilder arguments = new StringBuilder(260, 260);
            linkW.GetArguments(arguments, arguments.Capacity);
            return arguments.ToString();
         }
         set
         {
            linkW.SetArguments(value);
         }
      }
</pre><h3>2.3 Getting the Associated Icon for a Shortcut</h3><p>As noted in the introduction, the icon parameter for a shortcut is optional;
if not specified the default icon for the Target is used.  So the first part
of getting the icon is getting the cion when no icon filename is specified.
This is done using the Shell's <i>SHGetFileInfo</i> method.  The same code used
in the article <a href="..\getting_file_icons_using_the_shell\article.html">File icons from the Shell</a>
is used here for this case.</p><p>When the icon parameters are specified, you need a way to read the icon
resource from the specified icon file, executable or DLL.  The easiest way
to do this is to use the <i>ExtractIconEx</i> function provided in User32.DLL:
</p><pre>
    [DllImport("Shell32", CharSet=CharSet.Auto)]
    internal extern static int ExtractIconEx (
            [MarshalAs(UnmanagedType.LPTStr)]
            string lpszFile,
            int nIconIndex,
            IntPtr[] phIconLarge,
            IntPtr[] phIconSmall,
            int nIcons);
</pre><p>This function can be used in to get two pieces of information.  
If <i>nIconIndex</i> is set to -1, and <i>phIconLarge</i> and <i>phIconSmall</i> 
are <i>null</i>, and <i>nIcons</i> is zero, then the function returns the total 
number of icons in the file (if the file is an icon file, there will only ever 
be one).</p><p>Otherwise, <i>nIconIndex</i> specifies the start index of the icons to be
read, and <i>nIcons</i> the number of icons to be read out.  The 
<i>phIconLarge</i> and <i>phIconSmall</i> arrays should either be set to null
if you don't want a particular size icon or should be preinitialised to the 
number of icons you want.</p><p>So to get the Small Icon for a shortcut with a specified IconFile and Target,
the code is like this:</p><pre>
    IntPtr[] hIconEx = new IntPtr[1] {IntPtr.Zero};
    int iconCount = 0;

    iconCount = UnManagedMethods.ExtractIconEx(
		iconFile,
		iconIndex,
		null,
		hIconEx,
		1);

    // If success then return as a GDI+ object
    Icon icon = null;
    if (hIconEx[0] != IntPtr.Zero)
    {
        icon = Icon.FromHandle(hIconEx[0]);
    }
    return icon;
</pre><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<noscript>
<A HREF="..\..\..\..\..\vb\code\libraries\compression\index.html" ><IMG SRC="..\..\..\..\..\res\compress.png" ALT="Create and read Zip files and compress your data using Zlib" WIDTH=468 HEIGHT=60 BORDER=0></A>
</noscript>

</p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">Libraries</a>&#160;.&#160;<a href="..\index.html">Shell Projects</a>&#160;.&#160;Creating and Modifying Shortcuts</p><br /><p class="nav"><a href="..\..\..\..\..\the_site\copyright\article.html">Copyright</a> &#169; 2003 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 1 April 2003</p></td><td></td></tr></table>
</body></html>
