<html lang="en" >
<head>

<title>vbAccelerator - Folder Browser Dialog</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="The Folder Browser dialog is one of the missing components from .NET Framework 1.0 - I believe it is
included in v1.1 of the Framework.  Until then however, this provides a full .NET implementation with
support for every feature I could find, including the IFolderFilter interface, which allows the
items shown in the Folder Browser to be filtered using regular expressions." /><link rel="stylesheet" href="..\..\..\..\..\res\screen.css" media="SCREEN" /><link rel="stylesheet" href="..\..\..\..\..\res\print.css" media="PRINT" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><td colspan="3">
<!-- TF 468x60 JScript HORIZ NoPop code -->
<script language=javascript><!--
document.write('<scr'+'ipt language=javascript src="http://a.tribalfusion.com/j.ad?site=VBAcceleratorcom&adSpace=ROS&size=468x60&type=horiz&pop=0&requestID='+((new Date()).getTime() % 2147483648) + Math.random()+'"></scr'+'ipt>');
//-->
</script>
<noscript>
   <a href="javascript:window.alert(&quot;http://a.tribalfusion.com/i.click?site=VBAcceleratorcom&adSpace=ROS&size=468x60&requestID=1423477941\nThis link was not retrieved.&quot;)" target=_blank>
   <img src="http://cdn5.tribalfusion.com/media/493786.gif" 
                  width=468 height=60 border=0 alt="Click Here"></a>
</noscript>
<!-- TF 468x60 JScript HORIZ NoPop code -->
</td></tr><tr class="navbar"><td><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">Libraries</a>&#160;.&#160;<a href="..\index.html">Shell Projects</a>&#160;.&#160;Folder Browser Dialog</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="..\..\..\..\..\res\download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="folderbrowser_code.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />FolderBrowser Code</a> (41K)</p><br /><br /><img src="..\..\..\..\..\res\information.png" width="125" height="21" alt="Information" /><p class="nav">Article:4503</p><p class="nav">&#160;&#160;<a href="..\..\..\..\..\..\linkto_asp\id=4503&type=article&title=folder_20browser_20dialog.html">Link to this page</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;.NET</p><p class="nav">&#160;&#160;C#</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="..\..\..\..\..\res\bugtrak.png" width="125" height="21" alt="BugTrak System" /><p class="nav">No logged bugs.</p><br /><br /><img src="..\..\..\..\..\res\updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="..\..\..\..\..\res\update.png" width="8" height="8" alt="Update" />8 Mar 2003<br />First Posted</p><br /><br /><img src="..\..\..\..\..\res\related.png" width="125" height="21" alt="Related Items" /><br /><br /><img src="..\..\..\..\..\res\search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="javascript:window.alert(&quot;http://www.google.com/search\nThis link was not retrieved.&quot;)"><img src="..\..\..\..\..\..\..\www_google_com\logos\logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="..\..\..\..\..\the_site\newsite\article.html"><img src="..\..\..\..\..\res\newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>Folder Browser Dialog</h1><p class="splash">Fully featured support for the Shell's Folder Browser, including file filtering</p><img src="folderbrowser.png" width="250" height="240" alt="Folder Browser in Action" /><p /><p>The Folder Browser dialog is one of the missing components from .NET Framework 1.0 - I believe it is
included in v1.1 of the Framework.  Until then however, this provides a full .NET implementation with
support for every feature I could find, including the <i>IFolderFilter</i> interface, which allows the
items shown in the Folder Browser to be filtered using regular expressions.</p><h2>What Can You Do With It</h2><p>Here's the code from the sample which demonstrates most of the functionality you'll want
to use when using a Folder Browser:</p><pre>
   using (FolderBrowser f = new FolderBrowser())
   {
   	// Add events:

    // Initialised is fired when the folder browser
    // is first shown:
   	EventHandler initEventHandler = new EventHandler(
   		folderBrowser_Initialised);
   	f.Initialized += initEventHandler;

   	// Selection changed is fired whenever the 
   	// selected folder changes:
   	SelectionChangedEventHandler selChangeEventHandler =
   		new SelectionChangedEventHandler(
   		folderBrowser_SelectionChanged);
   	f.SelectionChanged += selChangeEventHandler;

   	// Validation failed is fired if the EditBox
   	// and the ValidateEditBox properties are set,
   	// and the user types in an unknown file name.
   	ValidationFailedEventHandler validationFailedEventHandler =
   		new ValidationFailedEventHandler(
   		folderBrowser_ValidationFailed);
   	f.ValidationFailed += validationFailedEventHandler;

   	// Set main properties:
   	f.Title = this.txtTitle.Text;
   	f.StatusText = this.txtStatusText.Text;
   	f.NewDialogStyle = (this.chkNewDialog.Checked);
   	f.ShowEditBox = (this.chkEditBox.Checked);
   	f.ValidateEditBox = (this.chkValidateEditBox.Checked);
   	f.NoNewFolderButton = (this.chkNoNewFolder.Checked);
   	f.IncludeFiles = (this.chkIncludeFiles.Checked);
   	f.InitialPath = this.txtInitialPath.Text;
   	f.RootPath = this.txtRootPath.Text;

   	// Add a filter:
   	f.Filter.ApplyFilter = (this.chkFilter.Checked);
   	if (f.Filter.ApplyFilter)
   	{
   	    // Filters are any regular expression and
   	    // can be applied to either files or folders.
   	    // Remember that some things appear as Shell 
   	    // folders even when they're not file folders,
   	    // e.g. Zip files.
   		f.Filter.Items.Add(
           new FileFilterSpecification(".jpg", true, false));
   	}

   	// Show the Dialog and get the result:
   	if (DialogResult.OK == f.ShowDialog(this))
   	{
   		txtSelection.Text = f.SelectedPath;
   	}
   	else
   	{
   		txtSelection.Text = "Dialog Cancelled";
   	}

   	// Done!
   	f.Initialized -= initEventHandler;
   	f.SelectionChanged -= selChangeEventHandler;
   	f.ValidationFailed -= validationFailedEventHandler;
   } // Dispose f
</pre><p>Other things you can do include moving and sizing the dialog,
creating a completely customised filter by overriding the <i>ShouldFilter</i>
method.</p><h2>Implementing The FolderBrowser</h2><p>Behind any folder browser implementation is one API call with a simple
structure to implement.  The Shell's <i>SHBrowseForFolder</i> API takes a
<i>BrowseInfo</i> structure and you can implement a minimal browser with 
very few lines of code:</p><pre>
public class SimpleFolderBrowse
{

	[StructLayout(LayoutKind.Sequential)]
	private struct BrowseInfo
	{
		public IntPtr hwndOwner;
		public IntPtr pidlRoot;
		[MarshalAs(UnmanagedType.LPTStr)]
		public string displayname;
		[MarshalAs(UnmanagedType.LPTStr)]
		public string title;
		public int flags;
		[MarshalAs(UnmanagedType.FunctionPtr)]
		public IntPtr callback;
		public IntPtr lparam;
	}

	[DllImport("Shell32.dll", CharSet=CharSet.Auto)]
	internal extern static System.IntPtr SHBrowseForFolder(
       ref BrowseInfo bi);

    private string folder = null;

    public string Folder
    {
       get
       {
           return this.folder;
       }
    }

    public DialogResult ShowBasicDialog(
        System.Windows.Forms.IWin32Window owner)
    {
        BrowseInfo bi = new BrowseInfo();
        bi.hwndOwner = owner.Handle;
        bi.title = "Choose Folder";
        bi.displayname = new string('\0', 260);
        if (SHBrowseForFolder(ref bi) != IntPtr.Zero)
        {
            folder = bi.displayname;
            return DialogResult.OK;
        }
        else
        {
            return DialogResult.Cancel;
        }
    }
}
</pre><p>However, there's plenty more options to investigate.  The main interesting
features are:</p><ol><li>Modifying the Dialog Options</li><li>Setting Root and Initial Paths</li><li>Connecting a File Filter</li></ol><p>I'll cover these in turn.</p><h3>1. Modifying Dialog Options</h3><p>The <i>flags</i> member of the <i>BrowseInfo</i> structure provides a
number of options which allow you to modify the appearance and functionality
of the basic folder browser dialog:</p><pre>
	[Flags]
	private enum BrowseFlags : int
	{
	    // Only return file system directories:
		BIF_RETURNONLYFSDIRS   = 0x0001,
		// When looking at Network computers, don't
		// go down to the share level:
		BIF_DONTGOBELOWDOMAIN = 0x0002,
		// Show a status text box as well as a title:
		BIF_STATUSTEXT = 0x0004,
		// Gray the ok button when a non-file system 
		// item is selected:
		BIF_RETURNFSANCESTORS = 0x0008,
		// Show an Edit box to allow the user to type
		// a file name:
		BIF_EDITBOX = 0x0010,
		// Cause the Browse Folder to callback when 
		// the user clicks OK but invalid text is in
		// the edit box:
		BIF_VALIDATE = 0x0020,
		// Make the dialog appear with the new UI style:
		// a resizable dialog with drag-drop, ordering,
		// shortcut menus, new folder button, ability to
		// delete folders.
		BIF_NEWDIALOGSTYLE = 0x0040,
		// Allow URLs to be selected.  BIF_NEWDIALOGSTYLE,
		// BIF_BROWSEINCLUDEFILES and BIF_EDITBOX must
		// also be set for this to work.
		BIF_BROWSEINCLUDEURLS = 0x0080,
		// Replace the text box with a user interface usage 
		// hint (only if BIF_EDITBOX not set)
		BIF_UAHINT = 0x0100,
		// Don't show the New Folder button when the new
		// dialog style is being used:
		BIF_NONEWFOLDERBUTTON = 0x0200,
		// Browse for computers; if anything else selected,
		// the dialog can't be OKed.
		BIF_BROWSEFORCOMPUTER = 0x1000,
		// Browse for printers; if anything else selected,
		// the dialog can't be OKed.
		BIF_BROWSEFORPRINTER = 0x2000,
		// Include files in a New Style dialog:
		BIF_BROWSEINCLUDEFILES = 0x4000,
		// Shareable resources on remote systems are
		// included:
		BIF_SHAREABLE = 0x8000,
    }
</pre><h3>2. Setting Root and Initial Paths</h3><p>In order to work more closely with the dialog, you need to do two things:
firstly, install a callback procedure to receive notifications of events in
the dialog and secondly to be able to translate paths to and from the
unfortunately named "Pidls" (Pointer to ID Lists).</p><h3>2.1 Installing a Callback Procedure</h3><p>The callback procedure itself is a function with the following
signature:</p><pre>
	private int BrowseCallbackProc(
		IntPtr hwnd,
		int msg,
		IntPtr lParam,
		IntPtr lpData
		)
	{
	}
</pre><p>To install the callback, create this function and then create a Delegate
for it.  Then modify the <i>BrowseInfo</i> structure so the <i>callback</i>
parameter is of the Delegate's type:</p><pre>
    private delegate int BrowseCallBackProc(
        IntPtr hwnd,
        int msg,
        IntPtr lp,
        IntPtr wp);

	[StructLayout(LayoutKind.Sequential)]
	private struct BrowseInfo
	{
		public IntPtr hwndOwner;
		public IntPtr pidlRoot;
		[MarshalAs(UnmanagedType.LPTStr)]
		public string displayname;
		[MarshalAs(UnmanagedType.LPTStr)]
		public string title;
		public int flags;
		[MarshalAs(UnmanagedType.FunctionPtr)]
		public BrowseInfo callback;
		public IntPtr lparam;
	}
</pre><p>When calling the dialog, you can then specify the delegate when setting
up the <i>BrowseInfo</i> structure:</p><pre>
    BrowseInfo bi = new BrowseInfo();

    ..
    bi = new BrowseCallBackProc(this.BrowseCallbackProc);
    ..
</pre><p>The dialog then sends the following messages to the callback procedure:</p><ul><li><i>BFFM_INITIALIZED</i> when the dialog is first created.  You can use
this message to select an initial folder.</li><li><i>BFFM_SELCHANGED</i> whenever the selected folder changes.</li><li><i>BFFM_VALIDATEFAILED</i> if the <i>BIF_VALIDATE</i> flag is set and
the TextBox has invalid text entered when the user OKs</li><li><i>BFFM_IUNKNOWN</i> when the Folder Browser's <i>IUnknown</i> interface
is available, allowing you to install a custom file filter, as described in
the next section.</li></ul><p>In order to set the root folder, or to easily change the selected path,
you need to be able to translate file and folder names to Pidls.  There are
a variety of Shell APIs which allow you to do this, but the one supported
on most OS varieties is to use the <i>IShellFolder</i> COM interface, which
provides a <i>ParseDisplayName</i> function that converts a path to a Pidl.</p><p>To implement this, you need to do three things:</p><ul><li>An <i>IShellFolder</i> interface you can use (which means also having
an <i>IEnumIDList</i> interface).</li><li>An <i>IMalloc</i> interface to allow the memory associated with Pidls
to be freed</li><li>API declares to obtain actual instances of <i>IShellFolder</i> and
<i>IMalloc</i></li></ul><h3>2.1 Implementing <i>IShellFolder</i>, <i>IEnumIDList</i> and <i>IMalloc</i></h3><p>These interfaces are provided in the Platform SDK; as usual you need to
add a little decoration (or untidyness) to allow them to be used properly.
The structures and enumerations associated with these interfaces are all
available in the download so aren't reproduced here:</p><pre>
    [ComImportAttribute()]
	[GuidAttribute("000214F2-0000-0000-C000-000000000046")]
	[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
	//helpstring("IEnumIDList interface")
	private interface IEnumIDList
	{
	   [PreserveSig]
		int Next(
			int celt,
			ref IntPtr rgelt,
			out int pceltFetched);

		void Skip(
			int celt);

		void Reset();

		void Clone(
			ref IEnumIDList ppenum);
	};
	
	[ComImportAttribute()]
	[GuidAttribute("000214E6-0000-0000-C000-000000000046")]
	[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
	//helpstring("IShellFolder interface")
	private interface IShellFolder
	{
		void ParseDisplayName(
			IntPtr hwndOwner,
			IntPtr pbcReserved,
			[MarshalAs(UnmanagedType.LPWStr)] string lpszDisplayName,
			out int pchEaten,
			out IntPtr ppidl,
			out int pdwAttributes);

		void EnumObjects(
			IntPtr hwndOwner,
			[MarshalAs(UnmanagedType.U4)] ESHCONTF grfFlags,
			ref IEnumIDList ppenumIDList
			);

		void BindToObject(
			IntPtr pidl,
			IntPtr pbcReserved,
			ref Guid riid,
			ref IShellFolder ppvOut);

		void BindToStorage(
			IntPtr pidl,
			IntPtr pbcReserved,
			ref Guid riid,
			IntPtr ppvObj
			);

		[PreserveSig]
		int CompareIDs(
			IntPtr lParam,
			IntPtr pidl1,
			IntPtr pidl2);

		void CreateViewObject(
			IntPtr hwndOwner,
			ref Guid riid,
			IntPtr ppvOut);

		void GetAttributesOf(
			int cidl,
			[MarshalAs(UnmanagedType.LPArray, SizeParamIndex=0)] 
			IntPtr[] apidl,
			[MarshalAs(UnmanagedType.U4)] ref ESFGAO rgfInOut);

		void GetUIObjectOf(
			IntPtr hwndOwner,
			int cidl,
			ref IntPtr apidl,
			ref Guid riid,
			out int prgfInOut,
			ref IUnknown ppvOut);

		void GetDisplayNameOf(
			IntPtr pidl,
			[MarshalAs(UnmanagedType.U4)] ESHGDN uFlags,
			ref STRRET_CSTR lpName);

		void SetNameOf(
			IntPtr hwndOwner,
			IntPtr pidl,
			[MarshalAs(UnmanagedType.LPWStr)] string lpszName,
			[MarshalAs(UnmanagedType.U4)] ESHCONTF uFlags,
			ref IntPtr ppidlOut);
		};

	[ComImportAttribute()]
	[GuidAttribute("00000002-0000-0000-C000-000000000046")]
	[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
	//helpstring("IMalloc interface")
	private interface IMalloc
	{
		[PreserveSig]
		IntPtr Alloc(int cb);

		[PreserveSig]
		IntPtr Realloc(
			IntPtr pv,
			int cb);

		[PreserveSig]
		void Free(IntPtr pv);

		[PreserveSig]
		int GetSize(IntPtr pv);

		[PreserveSig]
		int DidAlloc(IntPtr pv);

		[PreserveSig]
		void  HeapMinimize();
	};
</pre><h3>2.2 API Calls To Obtain <i>IShellFolder</i> and <i>IMalloc</i> interfaces
</h3><p>Whew.  After that nastiness its a whole lot easier to actually get hold
of the objects which do this:</p><pre>
	[DllImport("shell32", CharSet = CharSet.Auto)]
	internal extern static int SHGetMalloc(out IMalloc ppMalloc);

	[DllImport("shell32", CharSet = CharSet.Auto)]
	internal extern static int SHGetDesktopFolder(out IShellFolder ppshf);
</pre><h3>2.3 Using <i>IShellFolder</i> and <i>IMalloc</i> to Work with Pidls</h3><p>You're now in a position to start actually generating Pidls.  To avoid
writing the same code a lot, I've wrapped this work into a couple of classes:
<i>SafePidl</i> for Pidls and <i>Allocator</i> for <i>IMalloc</i>.  The
<i>Allocator</i> class is a bit poorly named since it only concerns itself
with freeing memory, but in any case here's the implementation:</p><pre>
public class Allocator : IDisposable
{
	private static IMalloc alloc = null;
	private static bool disposed = false;

	/// &lt;summary&gt;
	/// Frees the specified memory (if allocated by the
	/// Shell).
	/// &lt;/summary&gt;
	/// &lt;param name="ptr"&gt;Pointer to memory to free&lt;/param&gt;
	public static void Free(IntPtr ptr)
	{
		if (!disposed)
		{
			if (alloc == null)
			{
				UnManagedMethods.SHGetMalloc(out alloc);
			}
			if (alloc != null)
			{
				try
				{
					alloc.Free(ptr);
				}
				catch (Exception ex)
				{
					Console.WriteLine("Problem {0}", ex.Message);
				}
			}
		}
	}

	/// &lt;summary&gt;
	/// Frees the reference to the Shell's IMalloc object
	/// &lt;/summary&gt;
	public void Dispose()
	{
		Dispose(true);
		GC.SuppressFinalize(this);
	}

	/// &lt;summary&gt;
	/// Frees the reference to the SHell's IMalloc object
	/// when disposing is true.
	/// &lt;/summary&gt;
	/// &lt;param name="disposing"&gt;&lt;/param&gt;
	protected virtual void Dispose(bool disposing)
	{
		if (disposing)
		{
			if (!disposed)
			{
				if (alloc != null)
				{
					Marshal.ReleaseComObject(alloc);
					alloc = null;
				}
				disposed = true;
			}
		}
	}
}
</pre><p>This class provides an easy to use wrapper for freeing Pidls in the
<i>SafePidl</i> class, which provides functions for translating paths
to Pidls and vice-versa:</p><pre>
public class SafePidl : IDisposable
{
	private IntPtr pidl = IntPtr.Zero;
	private bool shouldFree = true;

	/// &lt;summary&gt;
	/// Returns the Pointer to ID List for this object.
	/// &lt;/summary&gt;
	public IntPtr Pidl
	{
		get
		{
			return pidl;
		}
	}
	/// &lt;summary&gt;
	/// Returns the path name for this Pidl
	/// &lt;/summary&gt;
	public string Path
	{
		get
		{
			StringBuilder path = new StringBuilder(260, 260);
			UnManagedMethods.SHGetPathFromIDList(pidl, path);
			return path.ToString();
		}
	}

	private IntPtr PathToPidl(string path)
	{
		IntPtr newPidl = IntPtr.Zero ;
		IShellFolder ishFolder = null;
		if (UnManagedMethods.SHGetDesktopFolder(
            out ishFolder) == 0) // S_OK
		{
			// we have it:
			int cParsed = 0;
			int afItem = 0;
			ishFolder.ParseDisplayName(
				IntPtr.Zero,
				IntPtr.Zero,
				path,
				out cParsed,
				out newPidl,
				out afItem);
			Marshal.ReleaseComObject(ishFolder);
		}
		return newPidl;
	}

	/// &lt;summary&gt;
	/// Enables the Pidl to be freed.
	/// &lt;/summary&gt;
	public void Dispose()
	{
		Dispose(true);
		GC.SuppressFinalize(this);
	}
	/// &lt;summary&gt;
	/// Enables the Pidl to be freed when disposing is true.
	/// &lt;/summary&gt;
	/// &lt;param name="disposing"&gt;Whether disposing or not&lt;/param&gt;
	protected virtual void Dispose(bool disposing)
	{
		if (disposing)
		{
			if (pidl != IntPtr.Zero)
			{
				if (shouldFree)
				{
					Allocator.Free(pidl);
				}
			}
			pidl = IntPtr.Zero;
		}
	}

	internal SafePidl(IntPtr pidl, bool shouldFree)
	{
		this.pidl = pidl;
		this.shouldFree = shouldFree;
	}
	/// &lt;summary&gt;
	/// Constructs a new Pidl for the specified path
	/// &lt;/summary&gt;
	/// &lt;param name="path"&gt;Path to get Pidl for&lt;/param&gt;
	public SafePidl(string path)
	{
		if (path.Length &gt; 0)
		{
			if (System.IO.Directory.Exists(path))
			{
				this.pidl = PathToPidl(path);
			}
			else
			{
				throw new System.IO.DirectoryNotFoundException(
					String.Format("The path {0} could not be found.", path));
			}
		}
	}
}
</pre><p>After that, you're now in a position to set the root path of the
Folder Browser and the initial path.</p><p>To set the root path, create a <i>SafePidl</i> object and apply this to
the <i>pidlRoot</i> member of the <i>BrowseInfo</i> structure:</p><pre>
   SafePidl pidlRoot = new SafePidl(rootPath);

   // ...
   bi.pidlRoot = pidlRoot.Pidl;
   // ...

   pidlRoot.Dispose();
</pre><p>To set the initial path, use the <i>lparam</i> member of the
<i>BrowseInfo</i> structure to store the initial folder Pidl and then during the
callback event you can tell the Folder Browser to select that path:</p><pre>
   SafePidl pidlInitial = new SafePidl(initialPath);

   // ...
   bi.lparam = pidlInitial.Pidl;
   // ...

   pidlInitial.Dispose();
   
   ...

   private int BrowseCallbackProc(
      IntPtr hwnd,
      int msg,
      IntPtr lParam,
      IntPtr lpData
      )
   {
       switch (msg)
       {
          case BFFM_INITIALIZED:
              if (lpData != IntPtr.Zero)
              {
                 SendMessage(hwnd, BFFM_SETSELECTIONW, IntPtr.Zero, lpData);
              }
              break;
          // ..
       }
   }
</pre><h3>3. Connecting a File Filter</h3><p>As noted before, the <i>BFFM_IUNKNOWN</i> notification event is sent to
Folder Browsers with the New UI style under Windows XP systems.  Using
this notification you can install a file filter provided that you implement
the <i>IFolderFilterSite</i> and <i>IFolderFilter</i> interfaces.  These
interfaces are documented in the Platform SDK in the file <i>ShlObjIdl.idl</i>.
Transcoding the IDL from these files to a COM Interop version, you get something
like this:</p><pre>
	[ComImportAttribute()]
	[GuidAttribute("C0A651F5-B48B-11d2-B5ED-006097C686F6")]
	[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
	//helpstring("IFolderFilterSite"),
	private interface IFolderFilterSite
	{
		void SetFilter(
			[MarshalAs(UnmanagedType.Interface)] IFolderFilter punk);
	}
	
	[ComImportAttribute()]
	[GuidAttribute("9CC22886-DC8E-11d2-B1D0-00C04F8EEB3E")]
	[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
	private interface IFolderFilter
	{
	   [PreserveSig]
		int ShouldShow(
			IShellFolder psf,
			IntPtr pidlFolder,
			IntPtr pidlItem);

		[PreserveSig]
		int GetEnumFlags(
			IShellFolder psf,
			IntPtr pidlFolder,
			IntPtr phwnd,
			[MarshalAs(UnmanagedType.U4)] out ESHCONTF pgrfFlags);
		};
</pre><p>You then need to create a class which provides the implementation of
<i>IFolderFilter</i> which is visible to COM:</p><pre>
	[ComVisible(true)]
	// you need to generate a GUID for your filter:
	[Guid("43104713-CF18-43d4-8A3F-BC45AD280D57")]
	private class BrowseItemFilter : IFolderFilter
	{

		public int ShouldShow(
			IShellFolder psf,
			IntPtr pidlFolder,
			IntPtr pidlItem)
		{
		   // implementation
		}

		public int GetEnumFlags(
			IShellFolder psf,
			IntPtr pidlFolder,
			IntPtr phwnd,
			out ESHCONTF pgrfFlags
			)
		{
	        // implementation
        }
    }
</pre><p>The implementation of the filter is a matter of responding to 
<i>GetEnumFlags</i> by returning which types of Shell Objects the browser
should show, and responding to <i>ShouldShow</i> by returning 1 if the
item should be filtered or 0 otherwise.  <i>GetEnumFlags</i> is fairly 
straightforward generally since you usually ask for all object types.
Using <i>ShouldShow</i> you can use the <i>IShellFolder</i> interface
introduced before to determine what the folder and item Pidls represent.
The <i>GetDisplayNameOf</i> is generally a good place to start - refer
to the code in the <i>BrowseItemFilter</i> class in the download to
see how to do this.</p><p>Having implemented a filter, you need to provide it to the folder through
the IUnknown notification event.  Since you have an <i>IUnknown</i> pointer,
you can use this to get the Folder Browsers <i>IFolderFilterSite</i> 
interface:</p><pre>
   case BFFM_IUNKNOWN:
      // Get the IUnknown Interface pointer to the
      // IFolderFilterSite:
      Guid iidFolderFilterSite = new Guid(
         "C0A651F5-B48B-11d2-B5ED-006097C686F6"); // IID_IFolderFilterSite
      IntPtr ptrFolderFilterSite = IntPtr.Zero;
      Marshal.QueryInterface(
         lParam,
         ref iidFolderFilterSite,
         out ptrFolderFilterSite);

      // If we get it, then convert that to the
      // IFolderFilterSite interface we want:
      if (ptrFolderFilterSite != IntPtr.Zero)
      {
          IFolderFilterSite folderFilterSite =
             (IFolderFilterSite)Marshal.GetTypedObjectForIUnknown(
                 ptrFolderFilterSite,
                 System.Type.GetType("IFolderFilterSite"));

          // Install our filter:
          BrowseItemFilter itemFilter = new BrowseItemFilter();
          folderFilterSite.SetFilter(itemFilter);
       }
       break;
</pre><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<noscript>
<A HREF="..\..\..\..\..\index.html" ><IMG SRC="..\..\..\..\..\res\vbaccelad.png" ALT="vbAccelerator - Faster VB Code" WIDTH=468 HEIGHT=60 BORDER=0></A>
</noscript>

</p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">Libraries</a>&#160;.&#160;<a href="..\index.html">Shell Projects</a>&#160;.&#160;Folder Browser Dialog</p><br /><p class="nav"><a href="..\..\..\..\..\the_site\copyright\article.html">Copyright</a> &#169; 2003 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 11 April 2003</p></td><td></td></tr></table>
</body></html>
