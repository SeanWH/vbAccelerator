<html lang="en" >
<head>

<title>vbAccelerator - System Image List</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="Although you can easily extract copies of icons for any file from the Shell
using the SHGetFileInfo call, if you need
to be able to display the icon for a large number of files you can end up
with too many icons and run out of resources.  The System Image List uses an
intelligent caching technique to provide icons without this overhead." /><link rel="stylesheet" href="..\..\..\..\..\res\screen.css" media="SCREEN" /><link rel="stylesheet" href="..\..\..\..\..\res\print.css" media="PRINT" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><td colspan="3">
<!-- TF 468x60 JScript HORIZ NoPop code -->
<script language=javascript><!--
document.write('<scr'+'ipt language=javascript src="http://a.tribalfusion.com/j.ad?site=VBAcceleratorcom&adSpace=ROS&size=468x60&type=horiz&pop=0&requestID='+((new Date()).getTime() % 2147483648) + Math.random()+'"></scr'+'ipt>');
//-->
</script>
<noscript>
   <a href="javascript:window.alert(&quot;http://a.tribalfusion.com/i.click?site=VBAcceleratorcom&adSpace=ROS&size=468x60&requestID=1423477941\nThis link was not retrieved.&quot;)" target=_blank>
   <img src="http://cdn5.tribalfusion.com/media/493786.gif" 
                  width=468 height=60 border=0 alt="Click Here"></a>
</noscript>
<!-- TF 468x60 JScript HORIZ NoPop code -->
</td></tr><tr class="navbar"><td><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">Libraries</a>&#160;.&#160;<a href="..\index.html">Shell Projects</a>&#160;.&#160;System Image List</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="..\..\..\..\..\res\download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="sysimagelist_code.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />SysImageList Code</a> (48K)</p><p /><p class="nav"><a href="using_sysimagelist_code.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />Using SysImageList Code</a> (25K)</p><br /><br /><img src="..\..\..\..\..\res\information.png" width="125" height="21" alt="Information" /><p class="nav">Article:4303</p><p class="nav">&#160;&#160;<a href="..\..\..\..\..\..\linkto_asp\id=4303&type=article&title=system_20image_20list.html">Link to this page</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;C#</p><p class="nav">&#160;&#160;.NET</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="..\..\..\..\..\res\bugtrak.png" width="125" height="21" alt="BugTrak System" /><p class="nav">No logged bugs.</p><br /><br /><img src="..\..\..\..\..\res\updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="..\..\..\..\..\res\update.png" width="8" height="8" alt="Update" />4 Mar 2003<br />First Posted</p><br /><br /><img src="..\..\..\..\..\res\related.png" width="125" height="21" alt="Related Items" /><p class="nav"><img src="..\..\..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\getting_file_icons_using_the_shell\article.html">Getting File Icons Using The Shell</a></p><br /><br /><img src="..\..\..\..\..\res\search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="javascript:window.alert(&quot;http://www.google.com/search\nThis link was not retrieved.&quot;)"><img src="..\..\..\..\..\..\..\www_google_com\logos\logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="..\..\..\..\..\the_site\newsite\article.html"><img src="..\..\..\..\..\res\newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>System Image List</h1><p class="splash">Get unlimited icons for files without bringing your application to
    its knees (if it has knees).</p><img src="sysimagelist.png" width="473" height="217" alt="System Image List Demonstration" /><p /><p>Although you can easily extract copies of icons for any file from the Shell
using the <a href="..\getting_file_icons_using_the_shell\article.html">SHGetFileInfo</a> call, if you need
to be able to display the icon for a large number of files you can end up
with too many icons and run out of resources.  The System Image List uses an
intelligent caching technique to provide icons without this overhead.</p><h2>Dr. Jeckyll and Dr. Jeckyll</h2><p>The SystemImageList class provided with the download has two distinct
personalities depending on which OS you're running on.</p><p>Under Windows XP, the Shell gains a new function for obtaining the System
Image List, <i>SHGetImageList</i>.  Well, it would if someone
had built the DLL properly - for some reason they forgot to export this
function by name, and therefore it is only available by the mysterious ordinal
<i>#727</i> (see <a href="javascript:window.alert(&quot;http://support.microsoft.com/default.aspx?scid=kb;EN-US;Q316931\nThis link was not retrieved.&quot;)">KB
article Q316931</a> for more details).  In any case this function returns a COM
<i>IImageList</i> interface to the ImageList.  Under previous versions,
the System Image List is obtained by a call to <i>SHGetFileInfo</i>
which returns a handle to a ComCtl32.DLL ImageList which can be used with
the standard exported <i>ImageList_</i> API calls.</p><p>The advantage of the new XP function is that it provides access to the
Extra Large Image List used for in the Tile and Thumbnail views of the Shell.
So the code decides based on the <i>System.Environment.OSVersion.Version</i>
which way to get at the ImageList. Once that's decided the only real difference
between the COM ImageList interface and the standard DLL call version is
that with the COM versions calls do not need you to tell it which ImageList
handle you're working on, as the handle is the <i>IUnknown</i> pointer to
the object.</p><h2>Curses</h2><p>It would be nice if you could use the System Image List directly with a
ListView or similar control, but unfortunately the
<i>System.Windows.Forms.ImageList</i> class is Sealed.  There's probably a good
reason for this, but it doesn't seem to be the best design decision in the
Framework.  This means that if you do want to use this class with a control
that supports a System.Windows.Forms ImageList then you need to find another way
to associated the ImageList.</p><p>For controls like the ListView and TreeView, this is just a matter of using
the API to set the ImageLists.  The code provided comes with a class,
<i>SysImageListHelper</i> which provides two static methods allowing you
to associate a SystemImageList rather than a standard ImageList to these
controls.</p><p>For other controls, you can use the SystemImageList's drawing methods to
draw onto the control itself.  The UsingSysImageList download demonstrates
some very basic code for attaching the System Image List to a ListBox and
ComboBox.</p><h2>Implementing the SystemImageList Class</h2><p>The first point in implementing the class is to get a handle to the
System Image List.  As noted before there are two distinct interfaces to
I'll cover these in turn.</p><h3>Getting the System Image List Handle using <i>SHGetFileInfo</i></h3><p>The first step to doing this is to declare the <i>SHGetFileInfo</i>
DLL call and the flags you need to use it:</p><pre>
using System.Runtime.InteropServices;

    [Flags]
    private enum SHGetFileInfoConstants : int
    {
        SHGFI_ICON = 0x100,                // get icon
        SHGFI_DISPLAYNAME = 0x200,         // get display name
        SHGFI_TYPENAME = 0x400,            // get type name
        SHGFI_ATTRIBUTES = 0x800,          // get attributes
        SHGFI_ICONLOCATION = 0x1000,       // get icon location
        SHGFI_EXETYPE = 0x2000,            // return exe type
        SHGFI_SYSICONINDEX = 0x4000,       // get system icon index
        SHGFI_LINKOVERLAY = 0x8000,        // put a link overlay on icon
        SHGFI_SELECTED = 0x10000,          // show icon in selected state
        SHGFI_ATTR_SPECIFIED = 0x20000,    // get only specified attributes
        SHGFI_LARGEICON = 0x0,             // get large icon
        SHGFI_SMALLICON = 0x1,             // get small icon
        SHGFI_OPENICON = 0x2,              // get open icon
        SHGFI_SHELLICONSIZE = 0x4,         // get shell size icon
        SHGFI_PIDL = 0x8,                  // pszPath is a pidl
        SHGFI_USEFILEATTRIBUTES = 0x10,    // use passed dwFileAttribute
        SHGFI_ADDOVERLAYS = 0x000000020,   // apply the appropriate overlays
        SHGFI_OVERLAYINDEX = 0x000000040   // Get the index of the overlay
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct SHFILEINFO
    {
        public IntPtr hIcon;
        public int iIcon;
        public int dwAttributes;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_PATH)]
        public string szDisplayName;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst=80)]
        public string szTypeName;
    }

    [DllImport("shell32")]
    private static extern IntPtr SHGetFileInfo (
        string pszPath,
        int dwFileAttributes,
        ref SHFILEINFO psfi,
        uint cbFileInfo,
        uint uFlags);
</pre><p>With this in place then the ImageList handle is the return value of
<i>SHGetFileInfo</i> for any file when the <i>SHGFI_SYSICONINDEX</i>
flag is specifed:</p><pre>
    SHGetFileInfoConstants dwFlags =
        SHGetFileInfoConstants.SHGFI_USEFILEATTRIBUTES |
        SHGetFileInfoConstants.SHGFI_SYSICONINDEX ;
    if (size == SysImageListSize.smallIcons)
    {
        dwFlags |= SHGetFileInfoConstants.SHGFI_SMALLICON;
    }
    // Get image list
    SHFILEINFO shfi = new SHFILEINFO();
    uint shfiSize = (uint)Marshal.SizeOf(shfi.GetType());

    // Call SHGetFileInfo to get the image list handle
    // using an arbitrary file:
    hIml = SHGetFileInfo(
        ".txt",
        FILE_ATTRIBUTE_NORMAL,
        ref shfi,
        shfiSize,
        (uint)dwFlags);
</pre><h3>Getting the System Image List using <i>SHGetImageList</i></h3><p>To get the System Image List with this function you need both
to create a COM <i>IImageList</i> Interface to work with and
to declare the <i>SHGetImageList</i> function.  In order to
get the handle correctly, the same function is declared
twice; once to return the COM object and once to get the
handle as an IntPtr - although in theory you can retrieve
the handle from the <i>IUnknown</i> interface of <i>IImageList</i>
directly, I found that the returned value was off by 4 bytes.</p><pre>
    /// &lt;summary&gt;
    /// SHGetImageList is not exported correctly in XP.  See KB316931
    /// http://support.microsoft.com/default.aspx?scid=kb;EN-US;Q316931
    /// Apparently (and hopefully) ordinal 727 isn't going to change.
    /// &lt;/summary&gt;
    [DllImport("shell32.dll", EntryPoint = "#727")]
    private extern static int SHGetImageList(
        int iImageList,
        ref Guid riid,
        ref IImageList ppv
        );

    [DllImport("shell32.dll", EntryPoint = "#727")]
    private extern static int SHGetImageListHandle(
        int iImageList,
        ref Guid riid,
        ref IntPtr handle
        );

    #region Structures
    [StructLayout(LayoutKind.Sequential)]
    private struct POINT
    {
        int x;
        int y;
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct IMAGELISTDRAWPARAMS
    {
        public int cbSize;
        public IntPtr himl;
        public int i;
        public IntPtr hdcDst;
        public int x;
        public int y;
        public int cx;
        public int cy;
        public int xBitmap;        // x offest from the upperleft of bitmap
        public int yBitmap;        // y offset from the upperleft of bitmap
        public int rgbBk;
        public int rgbFg;
        public int fStyle;
        public int dwRop;
        public int fState;
        public int Frame;
        public int crEffect;
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct IMAGEINFO
    {
        public IntPtr hbmImage;
        public IntPtr hbmMask;
        public int Unused1;
        public int Unused2;
        public RECT rcImage;
    }
    #endregion

    #region Private ImageList COM Interop (XP)
    [ComImportAttribute()]
    	[GuidAttribute("46EB5926-582E-4017-9FDF-E8998DAA0950")]
    	[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    	//helpstring("Image List"),
   	interface IImageList
    {
    	[PreserveSig]
    	int Add(
            IntPtr hbmImage,
            IntPtr hbmMask,
            ref int pi);

    	[PreserveSig]
    	int ReplaceIcon(
            int i,
            IntPtr hicon,
            ref int pi);

    	[PreserveSig]
    	int SetOverlayImage(
            int iImage,
            int iOverlay);

    	[PreserveSig]
    	int Replace(
            int i,
            IntPtr hbmImage,
            IntPtr hbmMask);

    	[PreserveSig]
    	int AddMasked(
            IntPtr hbmImage,
            int crMask,
            ref int pi);

    	[PreserveSig]
    	int Draw(
            ref IMAGELISTDRAWPARAMS pimldp);

    	[PreserveSig]
    	    int Remove(
            int i);

    	[PreserveSig]
    	int GetIcon(
            int i,
            int flags,
            ref IntPtr picon);

    	[PreserveSig]
    	int GetImageInfo(
            int i,
            ref IMAGEINFO pImageInfo);

    	[PreserveSig]
    	int Copy(
            int iDst,
            IImageList punkSrc,
            int iSrc,
            int uFlags);

    	[PreserveSig]
    	int Merge(
            int i1,
            IImageList punk2,
            int i2,
            int dx,
            int dy,
            ref Guid riid,
            ref IntPtr ppv);

    	[PreserveSig]
    	int Clone(
            ref Guid riid,
            ref IntPtr ppv);

    	[PreserveSig]
    	int GetImageRect(
            int i,
            ref RECT prc);

    	[PreserveSig]
    	int GetIconSize(
            ref int cx,
            ref int cy);

    	[PreserveSig]
    	int SetIconSize(
            int cx,
            int cy);

    	[PreserveSig]
    	    int GetImageCount(
            ref int pi);

    	[PreserveSig]
    	int SetImageCount(
            int uNewCount);

    	[PreserveSig]
    	int SetBkColor(
            int clrBk,
            ref int pclr);

    	[PreserveSig]
    	int GetBkColor(
            ref int pclr);

    	[PreserveSig]
    	int BeginDrag(
            int iTrack,
            int dxHotspot,
            int dyHotspot);

    	[PreserveSig]
    	int EndDrag();

    	[PreserveSig]
    	int DragEnter(
            IntPtr hwndLock,
            int x,
            int y);

    	[PreserveSig]
    	int DragLeave(
            IntPtr hwndLock);

    	[PreserveSig]
    	int DragMove(
            int x,
            int y);

    	[PreserveSig]
    	int SetDragCursorImage(
            ref IImageList punk,
            int iDrag,
            int dxHotspot,
            int dyHotspot);

    	[PreserveSig]
    	int DragShowNolock(
            int fShow);

    	[PreserveSig]
    	int GetDragImage(
            ref POINT ppt,
            ref POINT pptHotspot,
            ref Guid riid,
            ref IntPtr ppv);

    	[PreserveSig]
    	int GetItemFlags(
            int i,
            ref int dwFlags);

    	[PreserveSig]
    	int GetOverlayImage(
            int iOverlay,
            ref int piIndex);
    };
    #endregion
</pre><p>Once this is done you get the handle like this (the <i>isXpOrAbove</i>
function just uses <i>System.Enivronent.OSVersion.Version</i> to check
whether you're running on XP or not:</p><pre>
    if (isXpOrAbove())
    {
        // Get the System IImageList object from the Shell:
        Guid iidImageList = new Guid("46EB5926-582E-4017-9FDF-E8998DAA0950");
        int ret = SHGetImageList(
            (int)size,
            ref iidImageList,
            ref iImageList
            );
        // the image list handle is the IUnknown pointer, but
        // using Marshal.GetIUnknownForObject doesn't return
        // the right value.  It really doesn't hurt to make
        // a second call to get the handle:
        SHGetImageListHandle((int)size, ref iidImageList, ref hIml);
    }
</pre><h2>Now You Have The Handle</h2><p>That's most of the hard work pretty much done.  Once you've got the
handle, useful functions you can perform with the ImageList are:</p><ul><li>Finding the index of the icon for the specified file</li><li>Drawing an icon</li><li>Extracting a copy of an icon</li></ul><p>If you're using the <i>IImageList</i> interface, you have all of
the ImageList declares you need; otherwise a few additional declares are
needed:</p><pre>
    [DllImport("comctl32")]
    private extern static int ImageList_DrawIndirect(
        ref IMAGELISTDRAWPARAMS pimldp);

    [DllImport("comctl32")]
    private extern static int ImageList_GetIconSize(
        IntPtr himl,
        ref int cx,
        ref int cy);

    [DllImport("comctl32")]
    private extern static IntPtr ImageList_GetIcon(
        IntPtr himl,
        int i,
        int flags);
</pre><p>To find the index of an icon in the System Image List, use the 
<i>SHGetFileInfo</i> call with the <i>SHGFI_SYSICONINDEX</i> flag:</p><pre>
    public int IconIndex(
        string fileName,
        bool forceLoadFromDisk,
        ShellIconStateConstants iconState
        )
    {
        SHGetFileInfoConstants dwFlags = 
            SHGetFileInfoConstants.SHGFI_SYSICONINDEX;
        int dwAttr = 0;
        if (size == SysImageListSize.smallIcons)
        {
            dwFlags |= SHGetFileInfoConstants.SHGFI_SMALLICON;
        }

        // We can choose whether to access the disk or not. If you don't
        // hit the disk, you may get the wrong icon if the icon is
        // not cached. Also only works for files.
        if (!forceLoadFromDisk)
        {
            dwFlags |= SHGetFileInfoConstants.SHGFI_USEFILEATTRIBUTES;
            dwAttr = FILE_ATTRIBUTE_NORMAL;
        }
        else
        {
            dwAttr = 0;
        }

        // sFileSpec can be any file. You can specify a
        // file that does not exist and still get the
        // icon, for example sFileSpec = "C:\PANTS.DOC"
        SHFILEINFO shfi = new SHFILEINFO();
        uint shfiSize = (uint)Marshal.SizeOf(shfi.GetType());
        IntPtr retVal = SHGetFileInfo(
            fileName, dwAttr, ref shfi, shfiSize,
            ((uint)(dwFlags) | (uint)iconState));

        if (retVal.Equals(IntPtr.Zero))
        {
            System.Diagnostics.Debug.Assert(
                (!retVal.Equals(IntPtr.Zero)),
                "Failed to get icon index");
            return 0;
        }
        else
        {
            return shfi.iIcon;
        }
    }
</pre><p>Once you have the index, you can draw or extract the image:</p><ul><li><strong>Extracting an Icon</strong><pre>
      public Icon Icon(int index)
      {
         Icon icon = null;

         IntPtr hIcon = IntPtr.Zero;
         if (iImageList == null)
         {
            hIcon = ImageList_GetIcon(
               hIml,
               index,
               (int)ImageListDrawItemConstants.ILD_TRANSPARENT);

         }
         else
         {
            iImageList.GetIcon(
               index,
               (int)ImageListDrawItemConstants.ILD_TRANSPARENT,
               ref hIcon);
         }

         if (hIcon != IntPtr.Zero)
         {
            icon = System.Drawing.Icon.FromHandle(hIcon);
         }            
         return icon;
      }
</pre></li><li><strong>Drawing an Icon</strong><br /><pre>
      public void DrawImage(
         IntPtr hdc,
         int index,
         int x,
         int y,
         ImageListDrawItemConstants flags
         )
      {
         IMAGELISTDRAWPARAMS pimldp = new IMAGELISTDRAWPARAMS();
         pimldp.hdcDst = hdc;
         pimldp.cbSize = Marshal.SizeOf(pimldp.GetType());
         pimldp.i = index;
         pimldp.x = x;
         pimldp.y = y;
         pimldp.rgbFg = -1;
         pimldp.fStyle = (int)flags;

         if (iImageList == null)
         {
            // Using DLL Calls:
            pimldp.hIml = this.hIml;
            int ret = ImageList_DrawEx(
                ref pimldp);
         }
         else
         {
            // Using IImageList interface:
            this.iImageList.Draw(ref pimldp);
         }

      }
</pre><p>To get a device context to draw on, use the Graphics <i>GetHdc</i> and
<i>ReleaseHdc</i> methods like this:</p><pre>
    // assuming gfx is a Graphics object:
    IntPtr hDc = gfx.GetHdc();

    // .. do drawing here

    gfx.ReleaseHdc(hDc);
</pre></li></ul><p>When drawing there are a number of other parameters you can set to
modify the alpha, saturation and colours used to render the image.  Refer
to the code for more details on using these.</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<noscript>
<A HREF="..\..\..\..\..\vb\code\libraries\compression\index.html" ><IMG SRC="..\..\..\..\..\res\compress.png" ALT="Create and read Zip files and compress your data using Zlib" WIDTH=468 HEIGHT=60 BORDER=0></A>
</noscript>

</p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">Libraries</a>&#160;.&#160;<a href="..\index.html">Shell Projects</a>&#160;.&#160;System Image List</p><br /><p class="nav"><a href="..\..\..\..\..\the_site\copyright\article.html">Copyright</a> &#169; 2003 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 11 April 2003</p></td><td></td></tr></table>
</body></html>
