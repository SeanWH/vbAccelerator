<html lang="en" >
<head>
<title>vbAccelerator - Contents of code file: SysImageListTester\SysImageList.cs</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="vbAccelerator - Contents of code file: SysImageListTester\SysImageList.cs" /><link rel="stylesheet" href="..\..\..\..\..\..\res\screen.css" media="SCREEN" /><link rel="stylesheet" href="..\..\..\..\..\..\res\print.css" media="PRINT" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><td colspan="3">
<!-- TF 468x60 JScript HORIZ NoPop code -->
<script language=javascript><!--
document.write('<scr'+'ipt language=javascript src="http://a.tribalfusion.com/j.ad?site=VBAcceleratorcom&adSpace=ROS&size=468x60&type=horiz&pop=0&requestID='+((new Date()).getTime() % 2147483648) + Math.random()+'"></scr'+'ipt>');
//-->
</script>
<noscript>
   <a href="javascript:window.alert(&quot;http://a.tribalfusion.com/i.click?site=VBAcceleratorcom&adSpace=ROS&size=468x60&requestID=1423477941\nThis link was not retrieved.&quot;)" target=_blank>
   <img src="http://cdn5.tribalfusion.com/media/493786.gif" 
                  width=468 height=60 border=0 alt="Click Here"></a>
</noscript>
<!-- TF 468x60 JScript HORIZ NoPop code -->
</td></tr><tr class="navbar"><td><a href="..\..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\..\index.html">Libraries</a>&#160;.&#160;<a href="..\..\index.html">Shell Projects</a>&#160;.&#160;<a href="..\article.html">System Image List</a>&#160;.&#160;<a href="..\sysimagelist_code.html">SysImageList Code</a>&#160;.&#160;SysImageListTester</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="..\..\..\..\..\..\res\download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="sysimagelist_code.html"><img src="..\..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />SysImageList Code</a> (48K)</p><p /><p class="nav"><a href="using_sysimagelist_code.html"><img src="..\..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />Using SysImageList Code</a> (25K)</p><br /><br /><img src="..\..\..\..\..\..\res\information.png" width="125" height="21" alt="Information" /><p class="nav">Zip:4385</p><p class="nav">&#160;&#160;<a href="..\..\..\..\..\..\..\linkto_asp\id=4385&type=zip&title=sysimagelist.html">Link to code Zip</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;C#</p><p class="nav">&#160;&#160;.NET</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="..\..\..\..\..\..\res\bugtrak.png" width="125" height="21" alt="BugTrak System" /><p class="nav">No logged bugs.</p><br /><br /><img src="..\..\..\..\..\..\res\updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="..\..\..\..\..\..\res\update.png" width="8" height="8" alt="Update" />4 Mar 2003<br />First Posted</p><br /><br /><img src="..\..\..\..\..\..\res\related.png" width="125" height="21" alt="Related Items" /><p class="nav"><img src="..\..\..\..\..\..\res\rel.png" width="8" height="8" alt="Related Item" /><a href="..\..\getting_file_icons_using_the_shell\article.html">Getting File Icons Using The Shell</a></p><br /><br /><img src="..\..\..\..\..\..\res\search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="javascript:window.alert(&quot;http://www.google.com/search\nThis link was not retrieved.&quot;)"><img src="..\..\..\..\..\..\..\..\www_google_com\logos\logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="..\..\..\..\..\..\the_site\newsite\article.html"><img src="..\..\..\..\..\..\res\newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>vbAccelerator - Contents of code file: SysImageListTester\SysImageList.cs</h1><pre>using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace vbAccelerator.Components.ImageList
{

   #region Public Enumerations
   /// &lt;summary&gt;
   /// Available system image list sizes
   /// &lt;/summary&gt;
   public enum SysImageListSize : int
   {
      /// &lt;summary&gt;
      /// System Large Icon Size (typically 32x32)
      /// &lt;/summary&gt;
      largeIcons = 0x0,
      /// &lt;summary&gt;
      /// System Small Icon Size (typically 16x16)
      /// &lt;/summary&gt;
      smallIcons = 0x1,
      /// &lt;summary&gt;
      /// System Extra Large Icon Size (typically 48x48).
      /// Only available under XP; under other OS the
      /// Large Icon ImageList is returned.
      /// &lt;/summary&gt;
      extraLargeIcons = 0x2
   }

   /// &lt;summary&gt;
   /// Flags controlling how the Image List item is 
   /// drawn
   /// &lt;/summary&gt;
   [Flags]   
   public enum ImageListDrawItemConstants : int
   {
      /// &lt;summary&gt;
      /// Draw item normally.
      /// &lt;/summary&gt;
      ILD_NORMAL = 0x0,
      /// &lt;summary&gt;
      /// Draw item transparently.
      /// &lt;/summary&gt;
      ILD_TRANSPARENT = 0x1,
      /// &lt;summary&gt;
      /// Draw item blended with 25% of the specified foreground colour
      /// or the Highlight colour if no foreground colour specified.
      /// &lt;/summary&gt;
      ILD_BLEND25 = 0x2,
      /// &lt;summary&gt;
      /// Draw item blended with 50% of the specified foreground colour
      /// or the Highlight colour if no foreground colour specified.
      /// &lt;/summary&gt;
      ILD_SELECTED = 0x4,
      /// &lt;summary&gt;
      /// Draw the icon's mask
      /// &lt;/summary&gt;
      ILD_MASK = 0x10,
      /// &lt;summary&gt;
      /// Draw the icon image without using the mask
      /// &lt;/summary&gt;
      ILD_IMAGE = 0x20,
      /// &lt;summary&gt;
      /// Draw the icon using the ROP specified.
      /// &lt;/summary&gt;
      ILD_ROP = 0x40,
      /// &lt;summary&gt;
      /// Preserves the alpha channel in dest. XP only.
      /// &lt;/summary&gt;
      ILD_PRESERVEALPHA = 0x1000,
      /// &lt;summary&gt;
      /// Scale the image to cx, cy instead of clipping it.  XP only.
      /// &lt;/summary&gt;
      ILD_SCALE = 0x2000,
      /// &lt;summary&gt;
      /// Scale the image to the current DPI of the display. XP only.
      /// &lt;/summary&gt;
      ILD_DPISCALE = 0x4000
   }
   
   /// &lt;summary&gt;
   /// Enumeration containing XP ImageList Draw State options
   /// &lt;/summary&gt;
   [Flags]   
   public enum ImageListDrawStateConstants : int
   {
      /// &lt;summary&gt;
      /// The image state is not modified. 
      /// &lt;/summary&gt;
      ILS_NORMAL = (0x00000000),
      /// &lt;summary&gt;
      /// Adds a glow effect to the icon, which causes the icon to appear to
       glow 
      /// with a given color around the edges. (Note: does not appear to be
      /// implemented)
      /// &lt;/summary&gt;
      ILS_GLOW = (0x00000001), //The color for the glow effect is passed to the
       IImageList::Draw method in the crEffect member of IMAGELISTDRAWPARAMS. 
      /// &lt;summary&gt;
      /// Adds a drop shadow effect to the icon. (Note: does not appear to be
      /// implemented)
      /// &lt;/summary&gt;
      ILS_SHADOW = (0x00000002), //The color for the drop shadow effect is
       passed to the IImageList::Draw method in the crEffect member of
       IMAGELISTDRAWPARAMS. 
      /// &lt;summary&gt;
      /// Saturates the icon by increasing each color component 
      /// of the RGB triplet for each pixel in the icon. (Note: only ever
       appears
      /// to result in a completely unsaturated icon)
      /// &lt;/summary&gt;
      ILS_SATURATE = (0x00000004), // The amount to increase is indicated by
       the frame member in the IMAGELISTDRAWPARAMS method. 
      /// &lt;summary&gt;
      /// Alpha blends the icon. Alpha blending controls the transparency 
      /// level of an icon, according to the value of its alpha channel. 
      /// (Note: does not appear to be implemented).
      /// &lt;/summary&gt;
      ILS_ALPHA = (0x00000008) //The value of the alpha channel is indicated by
       the frame member in the IMAGELISTDRAWPARAMS method. The alpha channel
       can be from 0 to 255, with 0 being completely transparent, and 255 being
       completely opaque. 
   }
   
   /// &lt;summary&gt;
   /// Flags specifying the state of the icon to draw from the Shell
   /// &lt;/summary&gt;
   [Flags]
   public enum ShellIconStateConstants
   {
      /// &lt;summary&gt;
      /// Get icon in normal state
      /// &lt;/summary&gt;
      ShellIconStateNormal = 0,
      /// &lt;summary&gt;
      /// Put a link overlay on icon 
      /// &lt;/summary&gt;
      ShellIconStateLinkOverlay = 0x8000,        
      /// &lt;summary&gt;
      /// show icon in selected state 
      /// &lt;/summary&gt;
      ShellIconStateSelected = 0x10000,
      /// &lt;summary&gt;
      /// get open icon 
      /// &lt;/summary&gt;
      ShellIconStateOpen = 0x2,              
      /// &lt;summary&gt;
      /// apply the appropriate overlays
      /// &lt;/summary&gt;
      ShellIconAddOverlays = 0x000000020,
   }
   #endregion

   #region SysImageList
   /// &lt;summary&gt;
   /// Summary description for SysImageList.
   /// &lt;/summary&gt;
   public class SysImageList : IDisposable
   {
      #region UnmanagedCode
      private const int MAX_PATH = 260;
      
      [DllImport("shell32")]
      private static extern IntPtr SHGetFileInfo (
         string pszPath, 
         int dwFileAttributes,
         ref SHFILEINFO psfi, 
         uint cbFileInfo, 
         uint uFlags);

      [DllImport("user32.dll")]
      private static extern int DestroyIcon(IntPtr hIcon);

      private const int FILE_ATTRIBUTE_NORMAL = 0x80;
      private const int FILE_ATTRIBUTE_DIRECTORY = 0x10;

      private const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x100; 
      private const int FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x2000;
      private const int FORMAT_MESSAGE_FROM_HMODULE = 0x800;
      private const int FORMAT_MESSAGE_FROM_STRING = 0x400;
      private const int FORMAT_MESSAGE_FROM_SYSTEM = 0x1000;
      private const int FORMAT_MESSAGE_IGNORE_INSERTS = 0x200;
      private const int FORMAT_MESSAGE_MAX_WIDTH_MASK = 0xFF;
      [DllImport("kernel32")]
      private extern static int FormatMessage (
         int dwFlags, 
         IntPtr lpSource, 
         int dwMessageId, 
         int dwLanguageId, 
         string lpBuffer,
         uint nSize, 
         int argumentsLong);

      [DllImport("kernel32")]
      private extern static int GetLastError();

      [DllImport("comctl32")]
      private extern static int ImageList_Draw(
         IntPtr hIml,
         int i,
         IntPtr hdcDst,
         int x,
         int y,
         int fStyle);

      [DllImport("comctl32")]
      private extern static int ImageList_DrawIndirect(
         ref IMAGELISTDRAWPARAMS pimldp);

      [DllImport("comctl32")]
      private extern static int ImageList_GetIconSize(
         IntPtr himl, 
         ref int cx, 
         ref int cy);

      [DllImport("comctl32")]
      private extern static IntPtr ImageList_GetIcon(
         IntPtr himl, 
         int i, 
         int flags);

      /// &lt;summary&gt;
      /// SHGetImageList is not exported correctly in XP.  See KB316931
      /// http://support.microsoft.com/default.aspx?scid=kb;EN-US;Q316931
      /// Apparently (and hopefully) ordinal 727 isn't going to change.
      /// &lt;/summary&gt;
      [DllImport("shell32.dll", EntryPoint = "#727")]
      private extern static int SHGetImageList(
         int iImageList,
         ref Guid riid,
         ref IImageList ppv
         );

      [DllImport("shell32.dll", EntryPoint = "#727")]
      private extern static int SHGetImageListHandle(
         int iImageList,
         ref Guid riid,
         ref IntPtr handle
         );

      #endregion
      
      #region Private Enumerations
      [Flags]      
         private enum SHGetFileInfoConstants : int
      {
         SHGFI_ICON = 0x100,                // get icon 
         SHGFI_DISPLAYNAME = 0x200,         // get display name 
         SHGFI_TYPENAME = 0x400,            // get type name 
         SHGFI_ATTRIBUTES = 0x800,          // get attributes 
         SHGFI_ICONLOCATION = 0x1000,       // get icon location 
         SHGFI_EXETYPE = 0x2000,            // return exe type 
         SHGFI_SYSICONINDEX = 0x4000,       // get system icon index 
         SHGFI_LINKOVERLAY = 0x8000,        // put a link overlay on icon 
         SHGFI_SELECTED = 0x10000,          // show icon in selected state 
         SHGFI_ATTR_SPECIFIED = 0x20000,    // get only specified attributes 
         SHGFI_LARGEICON = 0x0,             // get large icon 
         SHGFI_SMALLICON = 0x1,             // get small icon 
         SHGFI_OPENICON = 0x2,              // get open icon 
         SHGFI_SHELLICONSIZE = 0x4,         // get shell size icon 
         //SHGFI_PIDL = 0x8,                  // pszPath is a pidl 
         SHGFI_USEFILEATTRIBUTES = 0x10,     // use passed dwFileAttribute 
         SHGFI_ADDOVERLAYS = 0x000000020,     // apply the appropriate overlays
         SHGFI_OVERLAYINDEX = 0x000000040     // Get the index of the overlay
      }
      #endregion

      #region Private ImageList structures
      [StructLayout(LayoutKind.Sequential)]
         private struct RECT
      {
         int left;
         int top;
         int right;
         int bottom;
      }

      [StructLayout(LayoutKind.Sequential)]
         private struct POINT
      {
         int x;
         int y;
      }

      [StructLayout(LayoutKind.Sequential)]
         private struct IMAGELISTDRAWPARAMS            
      {
         public int cbSize;
         public IntPtr himl;
         public int i;
         public IntPtr hdcDst;
         public int x;
         public int y;
         public int cx;
         public int cy;
         public int xBitmap;        // x offest from the upperleft of bitmap
         public int yBitmap;        // y offset from the upperleft of bitmap
         public int rgbBk;
         public int rgbFg;
         public int fStyle;
         public int dwRop;
         public int fState;
         public int Frame;
         public int crEffect;
      }

      [StructLayout(LayoutKind.Sequential)]
         private struct IMAGEINFO
      {
         public IntPtr hbmImage;
         public IntPtr hbmMask;
         public int Unused1;
         public int Unused2;
         public RECT rcImage;
      }
      [StructLayout(LayoutKind.Sequential)]
         private struct SHFILEINFO
      {
         public IntPtr hIcon;
         public int iIcon;
         public int dwAttributes;
         [MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_PATH)]
         public string szDisplayName;
         [MarshalAs(UnmanagedType.ByValTStr, SizeConst=80)]
         public string szTypeName;
      }
      #endregion

      #region Private ImageList COM Interop (XP)
      [ComImportAttribute()]
         [GuidAttribute("46EB5926-582E-4017-9FDF-E8998DAA0950")]
         [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
         //helpstring("Image List"),
         interface IImageList
      {
         [PreserveSig]
         int Add(
            IntPtr hbmImage, 
            IntPtr hbmMask, 
            ref int pi);

         [PreserveSig]
         int ReplaceIcon(
            int i, 
            IntPtr hicon, 
            ref int pi);

         [PreserveSig]
         int SetOverlayImage(
            int iImage, 
            int iOverlay);

         [PreserveSig]
         int Replace(
            int i,
            IntPtr hbmImage, 
            IntPtr hbmMask);

         [PreserveSig]
         int AddMasked(
            IntPtr hbmImage, 
            int crMask, 
            ref int pi);

         [PreserveSig]
         int Draw(
            ref IMAGELISTDRAWPARAMS pimldp);

         [PreserveSig]
         int Remove(
            int i);

         [PreserveSig]
         int GetIcon(
            int i, 
            int flags, 
            ref IntPtr picon);

         [PreserveSig]
         int GetImageInfo(
            int i, 
            ref IMAGEINFO pImageInfo);

         [PreserveSig]
         int Copy(
            int iDst, 
            IImageList punkSrc, 
            int iSrc, 
            int uFlags);

         [PreserveSig]
         int Merge(
            int i1, 
            IImageList punk2, 
            int i2, 
            int dx, 
            int dy, 
            ref Guid riid, 
            ref IntPtr ppv);

         [PreserveSig]
         int Clone(
            ref Guid riid, 
            ref IntPtr ppv);

         [PreserveSig]
         int GetImageRect(
            int i, 
            ref RECT prc);

         [PreserveSig]
         int GetIconSize(
            ref int cx, 
            ref int cy);

         [PreserveSig]
         int SetIconSize(
            int cx, 
            int cy);

         [PreserveSig]
         int GetImageCount(
            ref int pi);

         [PreserveSig]
         int SetImageCount(
            int uNewCount);

         [PreserveSig]
         int SetBkColor(
            int clrBk, 
            ref int pclr);

         [PreserveSig]
         int GetBkColor(
            ref int pclr);

         [PreserveSig]
         int BeginDrag(
            int iTrack, 
            int dxHotspot, 
            int dyHotspot);

         [PreserveSig]
         int EndDrag();

         [PreserveSig]
         int DragEnter(
            IntPtr hwndLock, 
            int x, 
            int y);

         [PreserveSig]
         int DragLeave(
            IntPtr hwndLock);

         [PreserveSig]
         int DragMove(
            int x, 
            int y);

         [PreserveSig]
         int SetDragCursorImage(
            ref IImageList punk, 
            int iDrag, 
            int dxHotspot, 
            int dyHotspot);

         [PreserveSig]
         int DragShowNolock(
            int fShow);

         [PreserveSig]
         int GetDragImage(
            ref POINT ppt, 
            ref POINT pptHotspot, 
            ref Guid riid, 
            ref IntPtr ppv);
         
         [PreserveSig]
         int GetItemFlags(
            int i, 
            ref int dwFlags);

         [PreserveSig]
         int GetOverlayImage(
            int iOverlay, 
            ref int piIndex);
      };
      #endregion

      #region Member Variables
      private IntPtr hIml = IntPtr.Zero;
      private IImageList iImageList = null;
      private SysImageListSize size = SysImageListSize.smallIcons;
      private bool disposed = false;
      #endregion

      #region Implementation

      #region Properties
      /// &lt;summary&gt;
      /// Gets the hImageList handle
      /// &lt;/summary&gt;
      public IntPtr Handle
      {
         get
         {
            return this.hIml;            
         }
      }
      /// &lt;summary&gt;
      /// Gets/sets the size of System Image List to retrieve.
      /// &lt;/summary&gt;
      public SysImageListSize ImageListSize
      {
         get
         {
            return size;
         }
         set
         {
            size = value;
            create();
         }

      }

      /// &lt;summary&gt;
      /// Returns the size of the Image List Icons.
      /// &lt;/summary&gt;
      public System.Drawing.Size Size
      {
         get
         {
            int cx = 0; 
            int cy = 0;
            if (iImageList == null)
            {
               ImageList_GetIconSize(
                  hIml,
                  ref cx, 
                  ref cy);
            }
            else
            {
               iImageList.GetIconSize(ref cx, ref cy);
            }
            System.Drawing.Size sz = new System.Drawing.Size(
               cx, cy);
            return sz;
         }      
      }
      #endregion

      #region Methods
      /// &lt;summary&gt;
      /// Returns a GDI+ copy of the icon from the ImageList
      /// at the specified index.
      /// &lt;/summary&gt;
      /// &lt;param name="index"&gt;The index to get the icon for&lt;/param&gt;
      /// &lt;returns&gt;The specified icon&lt;/returns&gt;
      public Icon Icon(int index)
      {
         Icon icon = null;

         IntPtr hIcon = IntPtr.Zero;
         if (iImageList == null)
         {
            hIcon = ImageList_GetIcon(
               hIml,
               index,
               (int)ImageListDrawItemConstants.ILD_TRANSPARENT);

         }
         else
         {
            iImageList.GetIcon(
               index,
               (int)ImageListDrawItemConstants.ILD_TRANSPARENT,
               ref hIcon);
         }

         if (hIcon != IntPtr.Zero)
         {
            icon = System.Drawing.Icon.FromHandle(hIcon);
         }            
         return icon;
      }

      /// &lt;summary&gt;
      /// Return the index of the icon for the specified file, always using 
      /// the cached version where possible.
      /// &lt;/summary&gt;
      /// &lt;param name="fileName"&gt;Filename to get icon for&lt;/param&gt;
      /// &lt;returns&gt;Index of the icon&lt;/returns&gt;
      public int IconIndex(string fileName)
      {
         return IconIndex(fileName, false);
      }

      /// &lt;summary&gt;
      /// Returns the index of the icon for the specified file
      /// &lt;/summary&gt;
      /// &lt;param name="fileName"&gt;Filename to get icon for&lt;/param&gt;
      /// &lt;param name="forceLoadFromDisk"&gt;If True, then hit the disk to get the
       icon,
      /// otherwise only hit the disk if no cached icon is available.&lt;/param&gt;
      /// &lt;returns&gt;Index of the icon&lt;/returns&gt;
      public int IconIndex(
         string fileName, 
         bool forceLoadFromDisk)
      {
         return IconIndex(
            fileName, 
            forceLoadFromDisk,
            ShellIconStateConstants.ShellIconStateNormal);
      }
      
      /// &lt;summary&gt;
      /// Returns the index of the icon for the specified file
      /// &lt;/summary&gt;
      /// &lt;param name="fileName"&gt;Filename to get icon for&lt;/param&gt;
      /// &lt;param name="forceLoadFromDisk"&gt;If True, then hit the disk to get the
       icon,
      /// otherwise only hit the disk if no cached icon is available.&lt;/param&gt;
      /// &lt;param name="iconState"&gt;Flags specifying the state of the icon
      /// returned.&lt;/param&gt;
      /// &lt;returns&gt;Index of the icon&lt;/returns&gt;
      public int IconIndex(
         string fileName,
         bool forceLoadFromDisk,
         ShellIconStateConstants iconState
         )
      {
         SHGetFileInfoConstants dwFlags =
          SHGetFileInfoConstants.SHGFI_SYSICONINDEX;
         int dwAttr = 0;
         if (size == SysImageListSize.smallIcons)
         {
            dwFlags |= SHGetFileInfoConstants.SHGFI_SMALLICON;
         }

         // We can choose whether to access the disk or not. If you don't
         // hit the disk, you may get the wrong icon if the icon is
         // not cached. Also only works for files.
         if (!forceLoadFromDisk)
         {
            dwFlags |= SHGetFileInfoConstants.SHGFI_USEFILEATTRIBUTES;
            dwAttr = FILE_ATTRIBUTE_NORMAL;
         }
         else
         {            
            dwAttr = 0;
         }

         // sFileSpec can be any file. You can specify a
         // file that does not exist and still get the
         // icon, for example sFileSpec = "C:\PANTS.DOC"
         SHFILEINFO shfi = new SHFILEINFO();
         uint shfiSize = (uint)Marshal.SizeOf(shfi.GetType());
         IntPtr retVal = SHGetFileInfo( 
            fileName, dwAttr, ref shfi, shfiSize, 
            ((uint)(dwFlags) | (uint)iconState));

         if (retVal.Equals(IntPtr.Zero))
         {
            System.Diagnostics.Debug.Assert((!retVal.Equals(IntPtr.Zero)),"Faile
            d to get icon index");
            return 0;
         }
         else
         {
            return shfi.iIcon;
         }
      }

      /// &lt;summary&gt;
      /// Draws an image
      /// &lt;/summary&gt;
      /// &lt;param name="hdc"&gt;Device context to draw to&lt;/param&gt;
      /// &lt;param name="index"&gt;Index of image to draw&lt;/param&gt;
      /// &lt;param name="x"&gt;X Position to draw at&lt;/param&gt;
      /// &lt;param name="y"&gt;Y Position to draw at&lt;/param&gt;
      public void DrawImage( 
         IntPtr hdc,
         int index, 
         int x,
         int y
         )
      {
         DrawImage(hdc, index, x, y,
          ImageListDrawItemConstants.ILD_TRANSPARENT);
      }

      /// &lt;summary&gt;
      /// Draws an image using the specified flags
      /// &lt;/summary&gt;
      /// &lt;param name="hdc"&gt;Device context to draw to&lt;/param&gt;
      /// &lt;param name="index"&gt;Index of image to draw&lt;/param&gt;
      /// &lt;param name="x"&gt;X Position to draw at&lt;/param&gt;
      /// &lt;param name="y"&gt;Y Position to draw at&lt;/param&gt;
      /// &lt;param name="flags"&gt;Drawing flags&lt;/param&gt;
      public void DrawImage(
         IntPtr hdc,
         int index,
         int x,
         int y,
         ImageListDrawItemConstants flags
         )
      {
         if (iImageList == null)
         {
            int ret = ImageList_Draw(
               hIml, 
               index, 
               hdc, 
               x, 
               y, 
               (int)flags);
         }
         else
         {
            IMAGELISTDRAWPARAMS pimldp = new IMAGELISTDRAWPARAMS();
            pimldp.hdcDst = hdc;
            pimldp.cbSize = Marshal.SizeOf(pimldp.GetType());
            pimldp.i = index;
            pimldp.x = x;
            pimldp.y = y;
            pimldp.rgbFg = -1;
            pimldp.fStyle = (int)flags;
            iImageList.Draw(ref pimldp);
         }
         
      }

      /// &lt;summary&gt;
      /// Draws an image using the specified flags and specifies
      /// the size to clip to (or to stretch to if ILD_SCALE
      /// is provided).
      /// &lt;/summary&gt;
      /// &lt;param name="hdc"&gt;Device context to draw to&lt;/param&gt;
      /// &lt;param name="index"&gt;Index of image to draw&lt;/param&gt;
      /// &lt;param name="x"&gt;X Position to draw at&lt;/param&gt;
      /// &lt;param name="y"&gt;Y Position to draw at&lt;/param&gt;
      /// &lt;param name="flags"&gt;Drawing flags&lt;/param&gt;
      /// &lt;param name="cx"&gt;Width to draw&lt;/param&gt;
      /// &lt;param name="cy"&gt;Height to draw&lt;/param&gt;
      public void DrawImage(
         IntPtr hdc,
         int index,
         int x,
         int y,
         ImageListDrawItemConstants flags,
         int cx,
         int cy
         )
      {
         IMAGELISTDRAWPARAMS pimldp = new IMAGELISTDRAWPARAMS();
         pimldp.hdcDst = hdc;
         pimldp.cbSize = Marshal.SizeOf(pimldp.GetType());
         pimldp.i = index;
         pimldp.x = x;
         pimldp.y = y;
         pimldp.cx = cx;
         pimldp.cy = cy;
         pimldp.fStyle = (int)flags;
         if (iImageList == null)
         {
            pimldp.himl = hIml;
            int ret = ImageList_DrawIndirect(ref pimldp);
         }
         else
         {

            iImageList.Draw(ref pimldp);
         }
      }

      /// &lt;summary&gt;
      /// Draws an image using the specified flags and state on XP systems.
      /// &lt;/summary&gt;
      /// &lt;param name="hdc"&gt;Device context to draw to&lt;/param&gt;
      /// &lt;param name="index"&gt;Index of image to draw&lt;/param&gt;
      /// &lt;param name="x"&gt;X Position to draw at&lt;/param&gt;
      /// &lt;param name="y"&gt;Y Position to draw at&lt;/param&gt;
      /// &lt;param name="flags"&gt;Drawing flags&lt;/param&gt;
      /// &lt;param name="cx"&gt;Width to draw&lt;/param&gt;
      /// &lt;param name="cy"&gt;Height to draw&lt;/param&gt;
      /// &lt;param name="foreColor"&gt;Fore colour to blend with when using the 
      /// ILD_SELECTED or ILD_BLEND25 flags&lt;/param&gt;
      /// &lt;param name="stateFlags"&gt;State flags&lt;/param&gt;
      /// &lt;param name="glowOrShadowColor"&gt;If stateFlags include ILS_GLOW, then
      /// the colour to use for the glow effect.  Otherwise if stateFlags
       includes 
      /// ILS_SHADOW, then the colour to use for the shadow.&lt;/param&gt;
      /// &lt;param name="saturateColorOrAlpha"&gt;If stateFlags includes ILS_ALPHA,
      /// then the alpha component is applied to the icon. Otherwise if 
      /// ILS_SATURATE is included, then the (R,G,B) components are used
      /// to saturate the image.&lt;/param&gt;
      public void DrawImage(
         IntPtr hdc,
         int index,
         int x,
         int y,
         ImageListDrawItemConstants flags,
         int cx,
         int cy,
         System.Drawing.Color foreColor,
         ImageListDrawStateConstants stateFlags,
         System.Drawing.Color saturateColorOrAlpha,
         System.Drawing.Color glowOrShadowColor
         )
      {
         IMAGELISTDRAWPARAMS pimldp = new IMAGELISTDRAWPARAMS();
         pimldp.hdcDst = hdc;
         pimldp.cbSize = Marshal.SizeOf(pimldp.GetType());
         pimldp.i = index;
         pimldp.x = x;
         pimldp.y = y;
         pimldp.cx = cx;
         pimldp.cy = cy;
         pimldp.rgbFg = Color.FromArgb(0, 
            foreColor.R, foreColor.G, foreColor.B).ToArgb();
         Console.WriteLine("{0}", pimldp.rgbFg);
         pimldp.fStyle = (int)flags;
         pimldp.fState = (int)stateFlags;
         if ((stateFlags &amp; ImageListDrawStateConstants.ILS_ALPHA) ==
            ImageListDrawStateConstants.ILS_ALPHA)
         {
            // Set the alpha:
            pimldp.Frame = (int)saturateColorOrAlpha.A;
         }
         else if ((stateFlags &amp; ImageListDrawStateConstants.ILS_SATURATE) ==
            ImageListDrawStateConstants.ILS_SATURATE)
         {
            // discard alpha channel:
            saturateColorOrAlpha = Color.FromArgb(0, 
               saturateColorOrAlpha.R, 
               saturateColorOrAlpha.G, 
               saturateColorOrAlpha.B);
            // set the saturate color
            pimldp.Frame = saturateColorOrAlpha.ToArgb();
         }
         glowOrShadowColor = Color.FromArgb(0, 
            glowOrShadowColor.R, 
            glowOrShadowColor.G, 
            glowOrShadowColor.B);
         pimldp.crEffect = glowOrShadowColor.ToArgb();
         if (iImageList == null)
         {
            pimldp.himl = hIml;
            int ret = ImageList_DrawIndirect(ref pimldp);
         }
         else
         {

            iImageList.Draw(ref pimldp);
         }
      }

      /// &lt;summary&gt;
      /// Determines if the system is running Windows XP
      /// or above
      /// &lt;/summary&gt;
      /// &lt;returns&gt;True if system is running XP or above, False
       otherwise&lt;/returns&gt;
      private bool isXpOrAbove()
      {
         bool ret = false;
         if (Environment.OSVersion.Version.Major &gt; 5)
         {
            ret = true;
         }
         else if ((Environment.OSVersion.Version.Major == 5) &amp;&amp;
            (Environment.OSVersion.Version.Minor &gt;= 1))
         {
            ret = true;
         }
         return ret;
         //return false;
      }

      /// &lt;summary&gt;
      /// Creates the SystemImageList
      /// &lt;/summary&gt;
      private void create()
      {
         // forget last image list if any:
         hIml = IntPtr.Zero;

         if (isXpOrAbove())
         {
            // Get the System IImageList object from the Shell:
            Guid iidImageList = new
             Guid("46EB5926-582E-4017-9FDF-E8998DAA0950");
            int ret = SHGetImageList(
               (int)size,
               ref iidImageList,
               ref iImageList
               );
            // the image list handle is the IUnknown pointer, but 
            // using Marshal.GetIUnknownForObject doesn't return
            // the right value.  It really doesn't hurt to make
            // a second call to get the handle:
            SHGetImageListHandle((int)size, ref iidImageList, ref hIml);
         }
         else
         {
            // Prepare flags:
            SHGetFileInfoConstants dwFlags =
             SHGetFileInfoConstants.SHGFI_USEFILEATTRIBUTES |
             SHGetFileInfoConstants.SHGFI_SYSICONINDEX ;
            if (size == SysImageListSize.smallIcons)
            {
               dwFlags |= SHGetFileInfoConstants.SHGFI_SMALLICON;
            }
            // Get image list
            SHFILEINFO shfi = new SHFILEINFO();
            uint shfiSize = (uint)Marshal.SizeOf(shfi.GetType());

            // Call SHGetFileInfo to get the image list handle
            // using an arbitrary file:
            hIml = SHGetFileInfo(
               ".txt", 
               FILE_ATTRIBUTE_NORMAL, 
               ref shfi, 
               shfiSize, 
               (uint)dwFlags);
            System.Diagnostics.Debug.Assert ((hIml != IntPtr.Zero),"Failed to
             create Image List");
         }
      }
      #endregion

      #region Constructor, Dispose, Destructor
      /// &lt;summary&gt;
      /// Creates a Small Icons SystemImageList 
      /// &lt;/summary&gt;
      public SysImageList()
      {
         create();
      }
      /// &lt;summary&gt;
      /// Creates a SystemImageList with the specified size
      /// &lt;/summary&gt;
      /// &lt;param name="size"&gt;Size of System ImageList&lt;/param&gt;
      public SysImageList(SysImageListSize size)
      {
         this.size = size;
         create();
      }

      /// &lt;summary&gt;
      /// Clears up any resources associated with the SystemImageList
      /// &lt;/summary&gt;
      public void Dispose()
      {
         Dispose(true);
         GC.SuppressFinalize(this);
      }
      /// &lt;summary&gt;
      /// Clears up any resources associated with the SystemImageList
      /// when disposing is true.
      /// &lt;/summary&gt;
      /// &lt;param name="disposing"&gt;Whether the object is being disposed&lt;/param&gt;
      public virtual void Dispose(bool disposing)
      {
         if (!disposed)
         {
            if (disposing) 
            {
               if (iImageList != null)
               {
                  Marshal.ReleaseComObject(iImageList);
               }
               iImageList = null;
            }
         }
         disposed = true;
      }
      /// &lt;summary&gt;
      /// Finalise for SysImageList
      /// &lt;/summary&gt;
      ~SysImageList()
      {
         Dispose(false);
      }

   }
   #endregion

   #endregion

   #endregion

   #region SysImageListHelper
   /// &lt;summary&gt;
   /// Helper Methods for Connecting SysImageList to Common Controls
   /// &lt;/summary&gt;
   public class SysImageListHelper
   {
      #region UnmanagedMethods
      private const int LVM_FIRST = 0x1000;
      private const int LVM_SETIMAGELIST = (LVM_FIRST + 3);

      private const int LVSIL_NORMAL = 0;
      private const int LVSIL_SMALL = 1;
      private const int LVSIL_STATE = 2;

      private const int TV_FIRST = 0x1100;
      private const int TVM_SETIMAGELIST = (TV_FIRST + 9);
      
      private const int TVSIL_NORMAL = 0;
      private const int TVSIL_STATE = 2;

      [DllImport("user32", CharSet = CharSet.Auto)]
      private static extern IntPtr SendMessage(
         IntPtr hWnd, 
         int wMsg, 
         IntPtr wParam, 
         IntPtr lParam);
      #endregion

      /// &lt;summary&gt;
      /// Associates a SysImageList with a ListView control
      /// &lt;/summary&gt;
      /// &lt;param name="listView"&gt;ListView control to associate ImageList
       with&lt;/param&gt;
      /// &lt;param name="sysImageList"&gt;System Image List to associate&lt;/param&gt;
      /// &lt;param name="forStateImages"&gt;Whether to add ImageList as
       StateImageList&lt;/param&gt;
      public static void SetListViewImageList(
         ListView listView,
         SysImageList sysImageList,
         bool forStateImages
         )
      {
         IntPtr wParam = (IntPtr)LVSIL_NORMAL;
         if (sysImageList.ImageListSize == SysImageListSize.smallIcons)
         {
            wParam = (IntPtr)LVSIL_SMALL;
         }
         if (forStateImages)
         {
            wParam = (IntPtr)LVSIL_STATE;
         }
         SendMessage(
            listView.Handle,
            LVM_SETIMAGELIST,
            wParam,
            sysImageList.Handle);   
      }

      /// &lt;summary&gt;
      /// Associates a SysImageList with a TreeView control
      /// &lt;/summary&gt;
      /// &lt;param name="treeView"&gt;TreeView control to associated ImageList
       with&lt;/param&gt;
      /// &lt;param name="sysImageList"&gt;System Image List to associate&lt;/param&gt;
      /// &lt;param name="forStateImages"&gt;Whether to add ImageList as
       StateImageList&lt;/param&gt;
      public static void SetTreeViewImageList(
         TreeView treeView,
         SysImageList sysImageList,
         bool forStateImages
         )
      {
         IntPtr wParam = (IntPtr)TVSIL_NORMAL;
         if (forStateImages)
         {
            wParam = (IntPtr)TVSIL_STATE;
         }
         SendMessage(
            treeView.Handle,
            TVM_SETIMAGELIST,
            wParam,
            sysImageList.Handle);
      }      
   }
   #endregion

}
</pre><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<noscript>
<A HREF="..\..\..\..\..\..\vb\code\vbmedia\using_gdi_plus\index.html" ><IMG SRC="..\..\..\..\..\..\res\gdiplus.png" ALT="A GDI+ Library for VB - read and write PNG, JPG, TIF and GIF files, and manipulate bitmaps quickly" WIDTH=468 HEIGHT=60 BORDER=0></A>
</noscript>

</p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="..\..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\..\index.html">Libraries</a>&#160;.&#160;<a href="..\..\index.html">Shell Projects</a>&#160;.&#160;<a href="..\article.html">System Image List</a>&#160;.&#160;<a href="..\sysimagelist_code.html">SysImageList Code</a>&#160;.&#160;SysImageListTester</p><br /><p class="nav"><a href="..\..\..\..\..\..\the_site\copyright\article.html">Copyright</a> &#169; 2003 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 12 April 2003</p></td><td></td></tr></table>
</body></html>