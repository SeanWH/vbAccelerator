<html lang="en" >
<head>

<title>vbAccelerator - Adding Mouse Gesture Support to .NET Windows Applications</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="
Use of mouse gestures to control application is becoming increasingly common in the 
more sophisticated web browsers. This sample demonstrates how you can support a range 
of mouse gestures in .NET Windows Forms Applications by implementing an 
IMessageFilter.  VB.NET and C# code provided.
" /><link rel="stylesheet" href="..\..\..\..\..\res\screen.css" media="SCREEN" /><link rel="stylesheet" href="..\..\..\..\..\res\print.css" media="PRINT" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><td colspan="3">
<!-- TF 468x60 JScript HORIZ NoPop code -->
<script language=javascript><!--
document.write('<scr'+'ipt language=javascript src="http://a.tribalfusion.com/j.ad?site=VBAcceleratorcom&adSpace=ROS&size=468x60&type=horiz&pop=0&requestID='+((new Date()).getTime() % 2147483648) + Math.random()+'"></scr'+'ipt>');
//-->
</script>
<noscript>
   <a href="javascript:window.alert(&quot;http://a.tribalfusion.com/i.click?site=VBAcceleratorcom&adSpace=ROS&size=468x60&requestID=1423477941\nThis link was not retrieved.&quot;)" target=_blank>
   <img src="http://cdn5.tribalfusion.com/media/493786.gif" 
                  width=468 height=60 border=0 alt="Click Here"></a>
</noscript>
<!-- TF 468x60 JScript HORIZ NoPop code -->
</td></tr><tr class="navbar"><td><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">Libraries</a>&#160;.&#160;<a href="..\index.html">Windows Messages</a>&#160;.&#160;Adding Mouse Gesture Support to .NET Windows Applications</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="..\..\..\..\..\res\download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="mousegestures.html"><img src="..\..\..\..\..\res\get.png" width="8" height="8" alt="Download Page" />MouseGestures</a> (154K)</p><br /><br /><img src="..\..\..\..\..\res\information.png" width="125" height="21" alt="Information" /><p class="nav">Article:13000</p><p class="nav">&#160;&#160;<a href="..\..\..\..\..\..\linkto_asp\id=13000&type=article&title=adding_20mouse_20gesture_20support_20to_20_2enet_20windows_20application.html">Link to this page</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;VB5</p><p class="nav">&#160;&#160;VB6</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="..\..\..\..\..\res\bugtrak.png" width="125" height="21" alt="BugTrak System" /><p class="nav">No logged bugs.</p><br /><br /><img src="..\..\..\..\..\res\updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="..\..\..\..\..\res\update.png" width="8" height="8" alt="Update" />23 Oct 2003<br />First Posted</p><br /><br /><img src="..\..\..\..\..\res\related.png" width="125" height="21" alt="Related Items" /><br /><br /><img src="..\..\..\..\..\res\search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="javascript:window.alert(&quot;http://www.google.com/search\nThis link was not retrieved.&quot;)"><img src="..\..\..\..\..\..\..\www_google_com\logos\logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="..\..\..\..\..\the_site\newsite\article.html"><img src="..\..\..\..\..\res\newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>Adding Mouse Gesture Support to .NET Windows Applications</h1><p class="splash">Enhancing usability in mouse-driven applications</p><img src="mousegestures.png" width="216" height="256" alt="Mouse Gestures Demonstration Application" /><p /><p>
Use of mouse gestures to control application is becoming increasingly common in the 
more sophisticated web browsers. This sample demonstrates how you can support a range 
of mouse gestures in .NET Windows Forms Applications by implementing an 
<span class="code">IMessageFilter</span>.  VB.NET and C# code provided.
</p><h2>About Mouse Gestures</h2><p>Most Mac users would agree - having a right mouse button is a great thing. But you'll notice it doesn't get to do that much in Windows applications except popping up a context menu when its released. The idea of mouse gestures gives the button something more to do whilst its held down. The idea is that if you want a popup menu, you're unlikely to move the mouse significantly until you release the button. If you do, then the movement is a candidate to be interpreted as a "gesture".</p><p>In theory, you could have an unlimited number of gestures of arbitrary complexity, for example, recognising when someone draws out a picture of an octopus rather than a squid with the mouse. However, in practice gestures are most useful there aren't very many of them and they're nice and simple. The figure below shows some of the sort of gestures users find easy to get used to and aren't too challenging to recognise:</p><img src="gestures.png" width="156" height="94" alt="Simple Mouse Gestures" /><p class="caption">Simple Mouse Gestures</p><p>Even this set of gestures is more than you would normally want to support in a single application, as it is easy to forget how to draw a North then East gesture as opposed to East then North, unless you one of the alpha-males with the type of spacial intelligence all males of the species are supposedly automatically inbued with but somehow I never got. Typically, you might want to support the four main directions (left and right can represent back and next, whilst up and down can be used for closing and opening windows) and one or two of the compound gestures.</p><h2>Message Loops and Their Uses</h2><p>
The .NET Framework <span class="code">System.Windows.Forms</span> namespace includes one
feature that I'd always wanted in VB: access to the <span class="i">Message Loop</span> for 
an application.
</p><p>
All Windows applications include a single message loop. 
You can read more about the message loop in the <a href="javascript:window.alert(&quot;http://msdn.microsoft.com/\nThis link was not retrieved.&quot;)">MSDN</a> 
C++ Q&amp;A article "Sending Messages in Windows, Adding Hot Keys to your Application"
by Paul DiLascia.  Fundamentally, Windows applications work on the basis of messages. Whenever
Windows tells your application its Window needs to be repainted, or when a mouse event occurs,
a message is either <strong>sent</strong> or <strong>posted</strong> to your application.
Messages that are sent are direct 
calls to the <span class="code">WndProc</span> function of a particular Window and must be
acted upon straight away.  Messages that are posted are intended to be picked up whenever the
application has time to process them, and are directed into a queue. A Windows application 
receives messages from this queue through its message loop function. 
</p><p>
Since there is only one message loop for an application, it is a great place to pick up on
messages regardless of which Window or Control they have been directed at.  In the case
of processing Mouse Gestures, this is a requirement since you normally want to be able to act on
a Mouse Gesture regardless of which window or control the mouse is drawing over when the
gesture occurs.  The other thing about the message loop is that if you can filter out
a message from the queue rather than dispatching it as normal then to the application it 
looks like the event never occurred.
</p><h2>Working with the Message Loop in .NET</h2><p>
The .NET Framework supports reading the Message Loop by writing an object which extends the
<span class="code">IMessageFilter</span> interface.  This interface has one method,
<span class="code">PreFilterMessage</span> which provides you with the message that has
just been received and you can return either <span class="code">false</span> to continue
processing the message or <span class="code">true</span> to filter the message out.
</p><p>
To install the filter, you use the static (shared in VB.NET) <span class="code">AddMessageFilter</span>
method of the <span class="code">Application</span> object.  To uninstall it when you are
finished, call corresponding <span class="code">RemoveMessageFilter</span> method.  Note that
whilst the documentation is peppered with warnings about not doing too much in the message
filter to prevent performance degradation, you don't really need to worry about this too 
much (obviously you don't want to search your hard drives for all MP3 files during each message,
but realistically it shouldn't be a problem).
</p><h2>Implementing a MouseGesture recognizer</h2><p>
Given that information, implementing a MouseGesture has the following stages:
</p><ol><li>Configure which gestures should be recognised.</li><li>Create a message filter which looks for right-mouse button down events.</li><li>Track the mouse position until the right-mouse button is released.</li><li>If the tracking indicates that a gesture was performed, raise an event indicating
the gesture occurred, and consume the mouse event so it doesn't result in the default
right-mouse up action being performed.</li></ol><p>
Note there is a slight catch with the last stage.  If you filter a mouse up message,
Windows is thrown into a slight state of confusion since it still thinks the mouse is
captured by the control or form the mouse was initially pressed over.  This means it
ignores the next mouse down.  To resolve this, we need to tell Windows that the mouse
has been released, but since we don't want it to cause a right-click action the mouse
up needs to appear to occur outside the boundaries of the original control or form.
Unfortunately, it is not possible to <span class="i">modify</span> a message received
through the message filter.  The alternative performed here is to consume the original
mouse up and then post a new one to the same window at an off-screen location.
</p><h3>Configuring Available Mouse Gestures</h3><p>
First, the available mouse gestures which can be recognized
are configured as a series of flags so the class can be configured to only pick up
certain gestures:
</p><pre>
   /// <summary>
   /// Enumerated flag values for the mouse gestures supported by 
   /// the MouseGesture class.
   /// </summary>
   [FlagsAttribute()]
   public enum MouseGestureTypes : int
   {
      /// <summary>
      /// No mouse gesture.
      /// </summary>
      NoGesture = 0x0,
      /// <summary>
      /// Mouse Gesture move north
      /// </summary>
      NorthGesture = 0x1,
      /// <summary>
      /// Mouse Gesture move south
      /// </summary>
      SouthGesture = 0x2,
      /// <summary>
      /// Mouse Gesture move east
      /// </summary>
      EastGesture = 0x4,
      /// <summary>
      /// Mouse Gesture move west
      /// </summary>
      WestGesture = 0x8,
      /// <summary>
      /// Mouse Gesture move north-east
      /// </summary>
      NorthThenEastGesture = 0x10,
      /// <summary>
      /// Mouse Gesture move south-east
      /// </summary>
      SouthThenEastGesture = 0x20,
      /// <summary>
      /// Mouse Gesture move south-west
      /// </summary>
      SouthThenWestGesture = 0x40,
      /// <summary>
      /// Mouse Gesture move north-west
      /// </summary>		
      NorthThenWestGesture = 0x80,
      /// <summary>
      /// Mouse Gesture move north-east
      /// </summary>
      EastThenNorthGesture = 0x100,
      /// <summary>
      /// Mouse Gesture move south-east
      /// </summary>
      EastThenSouthGesture = 0x200,
      /// <summary>
      /// Mouse Gesture move south-west
      /// </summary>
      WestThenSouthGesture = 0x400,
      /// <summary>
      /// Mouse Gesture move north-west
      /// </summary>		
      WestThenNorthGesture = 0x800,
      /// <summary>
      /// All mouse gestures
      /// </summary>
      AllGestureTypes = 0xFFF
   }

   /// <summary>
   /// The configured mouse gesture types
   /// </summary>
   private MouseGestureTypes gestureTypes = MouseGestureTypes.NoGesture;


   /// <summary>
   /// Gets/sets the mouse gesture types to look for.
   /// </summary>
   public MouseGestureTypes GestureTypes
   {
      get
      {
         return this.gestureTypes;
      }
      set
      {
         this.gestureTypes = value;
      }
   }
</pre><h3>Creating the Basic Filter</h3><p>
The basic filter checks the message for right button down, tracks the 
mouse movement when it is and checks the gesture when the mouse is 
released, as well as posting the mouse up if it is needed:
</p><pre>
   /// <summary>
   /// Whether we are checking for a gesture or not.
   /// </summary>
   private bool checkingGesture = false;
   /// <summary>
   /// The recorded mouse gesture during gesture checking
   /// </summary>
   private MouseGestureTypes recordedGesture = MouseGestureTypes.NoGesture;
   /// <summary>
   /// <c>ArrayList</c> of mouse points recorded during gesture.
   /// </summary>
   private ArrayList gesture = null;


      [DllImport("user32", CharSet = CharSet.Auto)]
      private extern static int PostMessage (
         IntPtr hwnd, 
         int wMsg, 
         int wParam, 
         int lParam);

      private const int WM_ACTIVATE = 0x6;
      private const int WM_RBUTTONDOWN = 0x204;
      private const int WM_MOUSEMOVE = 0x200;
      private const int WM_RBUTTONUP = 0x205;


      /// <summary>
      /// Prefilters all application messages to check whether
      /// the message is a gesture or not.
      /// </summary>
      /// <param name="m">The Windows message to prefilter</param>
      /// <returns><c>true</c> if the message should be filtered (was a 
      /// processed gesture), <c>false</c> otherwise.</returns>
      public bool PreFilterMessage(
         ref Message m
         )
      {
         bool retValue = false;

         if (this.gestureTypes &gt; 0)
         {
            if (this.checkingGesture)
            {
               if (m.Msg == WM_MOUSEMOVE)
               {
                  AddToMouseGesture();
               }
               else if (m.Msg == WM_RBUTTONUP)
               {
                  retValue = EndMouseGesture();
                  if (retValue)
                  {
                     // Windows will skip the next mouse down if we consume
                     // a mouse up.  m cannot be modified, despite being byref,
                     // so post a new one to a location which is offscreen:
                     int offScreen = 0x7fff7fff;
                     PostMessage(m.HWnd, WM_RBUTTONUP, (int)m.WParam, offScreen);
                  }
               }
               else if (m.Msg == WM_ACTIVATE)
               {
                  this.checkingGesture = false;            
               }
            }
            else if (m.Msg == WM_RBUTTONDOWN)
            {
               BeginMouseGesture();
            }
         }
         return retValue;
      }

</pre><p><span class="code">BeginMouseGesture</span> simply initiates the <span class="code">gestures</span>
ArrayList to a new instance and sets the tracking flag whilst <span class="code">AddToMouseGesture</span>
adds the mouse position to <span class="code">gestures</span>.
</p><h3>Implemented Gesture Recognition</h3><p>
The last step is to determine which mouse gesture was performed. The code does this by detecting how far the mouse moved horizontally and vertically, then checking whether most of the travel occurred vertically or horizontally during that motion:
</p><pre>
      /// <summary>
      /// Detects whether the specified gesture was a mouse gesture or not.      
      /// </summary>
      /// <returns>True if a gesture was performed.</returns>
      private bool EndMouseGesture()
      {
         this.checkingGesture = false;

         bool retValue = false;

         // add the end point:
         gesture.Add(Cursor.Position);

         // get start and end:
         Point first = (Point) gesture[0];
         Point last = (Point) gesture[gesture.Count - 1];

         // check which directions we register a change in:
         int xDiff = first.X - last.X;
         int yDiff = first.Y - last.Y;

         bool north, south, east, west;
         north = south = east = west = false;

         if (Math.Abs(yDiff) &gt; DEFAULT_HYSTERESIS_PIXELS)
         {
            north = (yDiff &gt; 0);
            south = !north;
         }
         if (Math.Abs(xDiff) &gt; DEFAULT_HYSTERESIS_PIXELS)
         {
            west = (xDiff &gt; 0);
            east = !west;
         }
         // check for very narrow angles as these are probably not compound gestures
         if ((north || south) &amp;&amp; (east || west))
         {
            if (Math.Abs(xDiff) &gt; Math.Abs(yDiff))
            {
               if ((Math.Abs(xDiff) / (Math.Abs(yDiff) * 1.0)) &gt; 7.0)
               {
                  north = south = false;
               }
            }
            else
            {
               if ((Math.Abs(yDiff) / (Math.Abs(xDiff) * 1.0)) &gt; 7.0)
               {
                  east = west = false;
               }
            }
         }

         recordedGesture = MouseGestureTypes.NoGesture;

         if (north || south) 
         {
            if (east || west)
            {
               // compound gesture:
               recordedGesture = interpretCompoundGesture(
                  first, last, north, south, east, west);
            }
            else
            {
               // pure vertical gesture:
               if (north)
               {
                  recordedGesture = MouseGestureTypes.NorthGesture;
               }
               else
               {
                  recordedGesture = MouseGestureTypes.SouthGesture;
               }
            }
         }
         else if (east || west)
         {
            // pure horizontal gesture
            if (east)
            {
               recordedGesture = MouseGestureTypes.EastGesture;
            }
            else
            {
               recordedGesture = MouseGestureTypes.WestGesture;
            }
         }

         if (recordedGesture != MouseGestureTypes.NoGesture)
         {            
            if ((gestureTypes &amp; recordedGesture) != 0)
            {
               MouseGestureEventArgs args = new MouseGestureEventArgs(
                  recordedGesture, first, last);
               if (this.MouseGesture != null)
               {
                  this.MouseGesture(this, args);
                  retValue = args.AcceptGesture;
               }
            }         
         }

         return retValue;
      }

      private MouseGestureTypes interpretCompoundGesture(
         Point first, Point last,
         bool north, bool south, bool east, bool west)
      {
         MouseGestureTypes retValue = MouseGestureTypes.NoGesture;

         // draw a diagonal line between start &amp; end
         // and determine if most points are y above 
         // the line or not:
         int pointAbove = 0;
         int pointBelow = 0;
         
         foreach (Point point in gesture)
         {
            int diagY = ((point.X - first.X) * (first.Y - last.Y)) / 
                (first.X - last.X) + first.Y;
            if (point.Y &gt; diagY)
            {
               pointAbove++;
            }
            else
            {
               pointBelow++;
            }
         }

         if (north)
         {
            if (east)
            {
               if (pointAbove &gt; pointBelow)
               {
                  retValue = MouseGestureTypes.EastThenNorthGesture;
               }
               else
               {
                  retValue = MouseGestureTypes.NorthThenEastGesture;
               }
            }
            else
            {
               if (pointAbove &gt; pointBelow)
               {
                  retValue = MouseGestureTypes.WestThenNorthGesture;
               }
               else
               {
                  retValue = MouseGestureTypes.NorthThenWestGesture;
               }

            }
         }
         else if (south)
         {
            if (east)
            {
               if (pointAbove &gt; pointBelow)
               {
                  retValue = MouseGestureTypes.SouthThenEastGesture;
               }
               else
               {
                  retValue = MouseGestureTypes.EastThenSouthGesture;
               }
            }
            else
            {
               if (pointAbove &gt; pointBelow)
               {
                  retValue = MouseGestureTypes.SouthThenWestGesture;
               }
               else
               {
                  retValue = MouseGestureTypes.WestThenSouthGesture;
               }
            }
         }

         return retValue;
      }
</pre><p>
  This code typically generates the correct results. A better alternative to the deterministic algorithms shown above would be to use Fuzzy Logic to determine which gesture was the most likely. This is the subject of a future article, in the meantime information about implementing Fuzzy Logic please go to 
  <a href="javascript:window.alert(&quot;http://www.codeproject.com/\nThis link was not retrieved.&quot;)">CodeProject</a> 
  and search on the author "pseudonym67". 
  </p><h2>Using the <span class="code">MouseGestureFilter</span> class</h2><p>
The demonstration application shows how to use the filter.  Basically you
need code that instantiates the class, installs the filter and responds
to the <span class="code">MouseGesture</span> event:
</p><pre>
using vbAccelerator.Components.Win32;

   MouseGestureFilter mgf = new MouseGestureFilter();
   Application.AddMessageFilter(mgf);
   mgf.MouseGesture += new MouseGestureEventHandler(
      frmMouseGesture_MouseGesture);

   private void frmMouseGesture_MouseGesture(
         object sender, 
         MouseGestureEventArgs args)
   {
      // Process the gesture here, args.GestureType contains
      // the gesture that was performed.

      args.AcceptGesture = true;
   }
</pre><h2>Conclusion</h2><p>
This article provides a reusable class you can add to your application for
recognising Mouse Gestures.  It also demonstrates how you can use the Message
Loop to process mouse events regardless of which form or control they are
intended for, which can be a very useful technique.
</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<noscript>
<A HREF="..\..\..\..\..\index.html" ><IMG SRC="..\..\..\..\..\res\vbaccelad.png" ALT="vbAccelerator - Faster VB Code" WIDTH=468 HEIGHT=60 BORDER=0></A>
</noscript>

</p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="..\..\..\..\..\index.html"><img width="125" height="25" src="..\..\..\..\..\res\vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="..\..\..\..\..\index.html">Home</a>&#160;.&#160;<a href="..\..\..\..\index.html">NET</a>&#160;.&#160;<a href="..\..\..\index.html">Code</a>&#160;.&#160;<a href="..\..\index.html">Libraries</a>&#160;.&#160;<a href="..\index.html">Windows Messages</a>&#160;.&#160;Adding Mouse Gesture Support to .NET Windows Applications</p><br /><p class="nav"><a href="..\..\..\..\..\the_site\copyright\article.html">Copyright</a> &#169; 2003 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 2 November 2003</p></td><td></td></tr></table>
</body></html>